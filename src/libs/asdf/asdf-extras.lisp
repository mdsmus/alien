;;;; ** CLEAN-OP - An intelligent make clean for ASDF

(defclass clean-op (asdf:operation)
  ((for-op :accessor for-op :initarg :for-op :initform 'asdf:compile-op))
  (:documentation "Removes any files generated by an asdf component."))

(defmethod asdf:perform ((op clean-op) (c asdf:component))
  "Delete all the output files generated by the component C."
  (dolist (f (asdf:output-files (make-instance (for-op op)) c))
    (when (probe-file f)
      (delete-file f))))

(defmethod asdf:operation-done-p ((op clean-op) (c asdf:component))
  "Returns T when the output-files of (for-op OP) C don't exist."
  (dolist (f (asdf:output-files (make-instance (for-op op)) c))
    (when (probe-file f) (return-from asdf:operation-done-p nil)))
  t)

;;;; ** Creating a single .fas or .fasl file

;;;; Instead of creating images another way to distribute systems is
;;;; to create a single compiled file containing all the code. This is
;;;; only possible on some lisps, sbcl and clisp are the only ones
;;;; supported for now.

;;;; NB: Unlike the CLEAN-OP this is experimental (its now to have
;;;; problems on multiple systems with non-trivial dependencies).

(defun make-single-fasl (system-name
                         &key (op (make-instance 'asdf:load-op))
                              output-file)
  (let* ((system (asdf:find-system system-name))
         (steps (asdf::traverse op system))
         (output-file (or output-file
                          (compile-file-pathname
                           (make-pathname
                            :name (asdf:component-name system)
                            :defaults (asdf:component-pathname system)))))
         (*buffer* (make-array 4096 :element-type '(unsigned-byte 8)
                                    :adjustable t)))
    (declare (special *buffer*))
    (with-output-to-file (*fasl* output-file
                          :if-exists :error
                          :element-type '(unsigned-byte 8))
      (declare (special *fasl*))
      (dolist (s steps)
        (process-step (car s) (cdr s) output-file)))))

(defgeneric process-step (op comp output-file))

(defmethod process-step
    ((op asdf:load-op) (file asdf:cl-source-file) output-file)
  (declare (ignore output-file)
           (special *buffer* *fasl*))
  (dolist (fasl (asdf:output-files (make-instance 'asdf:compile-op) file))
    (with-input-from-file (input (truename fasl)
                           :element-type '(unsigned-byte 8))
      (setf *buffer* (adjust-array *buffer* (file-length input)))
      (read-sequence *buffer* input)
      (write-sequence *buffer* *fasl*))))

(defmethod process-step ((op asdf:operation) (comp asdf:component) output-file)
  (declare (ignore output-file))
  (format t "Ignoring step ~S on ~S.~%" op comp))
