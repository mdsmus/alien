\documentclass[10pt,english]{book}
\usepackage{lisp}

\makeindex

\title{The Common Lisp Manual}
\author{Pedro Kroger, editor}
\date{May 19, 2009}
\release{0.1}

\begin{document}

\frontmatter

\maketitle
\tableofcontents

\mainmatter

\part{About this project}
\label{part:about-this-project}

\chapter{Introduction}
\label{cha:introduction}



\chapter{Acknowledgement}
\label{cha:acknowledgement}



\chapter{Authors}
\label{cha:authors}



\part{The Common Lisp standard}
\label{part:common-lisp-standard}

\chapter{Syntax}
\label{cha:syntax}


\chapter{Numbers}

\section{Predicates}
\label{sec:number-predicates}

\begin{function}{complexp}{object}
  Return true if OBJECT is a COMPLEX, and NIL otherwise.
\end{function}

\begin{function}{evenp}{number}
  Is this integer even?
\end{function}

\begin{function}{floatp}{object}
  Return true if OBJECT is a FLOAT, and NIL otherwise.
\end{function}

\begin{function}{integerp}{object}
  Return true if OBJECT is an INTEGER, and NIL otherwise.
\end{function}

\begin{function}{logbitp}{index integer}
  Predicate returns T if bit index of integer is a 1.
\end{function}

\begin{function}{minusp}{number}
  Is this real number strictly negative?
\end{function}

\begin{function}{numberp}{object}
  Return true if OBJECT is a NUMBER, and NIL otherwise.
\end{function}

\begin{function}{oddp}{number}
  Is this integer odd?
\end{function}

\begin{function}{plusp}{number}
  Is this real number strictly positive?
\end{function}

\begin{function}{random-state-p}{object}
  Returns true if \var{object} is of type \typer{random-state},
  otherwise returns NIL.
\end{function}

\begin{function}{rationalp}{object}
  Return true if OBJECT is a RATIONAL, and NIL otherwise.
\end{function}

\begin{function}{realp}{object}
  Return true if OBJECT is a REAL, and NIL otherwise.
\end{function}

\begin{function}{zerop}{number}
  Is this number zero?
\end{function}

The following functions are predicates for the sub-interval numerical
types described in CDR 5
\url{http://cdr.eurolisp.org/document/5/extra-num-types.html}.

\begin{function}{negative-rational-p}{n}[cl-ext]
  
\end{function}

\begin{function}{non-negative-double-float-p}{n}[cl-ext]
  
\end{function}

\begin{function}{negative-fixnum-p}{n}[cl-ext]
  
\end{function}

\begin{function}{negative-double-float-p}{n}[cl-ext]
  
\end{function}

\begin{function}{negative-float-p}{n}[cl-ext]
  
\end{function}

\begin{function}{negative-integer-p}{n}[cl-ext]
  
\end{function}

\begin{function}{negative-long-float-p}{n}[cl-ext]
  
\end{function}

\begin{function}{negative-real-p}{n}[cl-ext]
  
\end{function}

\begin{function}{negative-short-float-p}{n}[cl-ext]
  
\end{function}

\begin{function}{negative-single-float-p}{n}[cl-ext]
  
\end{function}

\begin{function}{non-negative-fixnum-p}{n}[cl-ext]
  
\end{function}

\begin{function}{non-negative-float-p}{n}[cl-ext]
  
\end{function}

\begin{function}{non-negative-integer-p}{n}[cl-ext]
  
\end{function}

\begin{function}{non-negative-long-float-p}{n}[cl-ext]
  
\end{function}

\begin{function}{non-negative-rational-p}{n}[cl-ext]
  
\end{function}

\begin{function}{non-negative-real-p}{n}[cl-ext]
  
\end{function}

\begin{function}{non-negative-short-float-p}{n}[cl-ext]
  
\end{function}

\begin{function}{non-negative-single-float-p}{n}[cl-ext]
  
\end{function}

\begin{function}{non-positive-double-float-p}{n}[cl-ext]
  
\end{function}

\begin{function}{non-positive-fixnum-p}{n}[cl-ext]
  
\end{function}

\begin{function}{non-positive-float-p}{n}[cl-ext]
  
\end{function}

\begin{function}{non-positive-integer-p}{n}[cl-ext]
  
\end{function}

\begin{function}{non-positive-long-float-p}{n}[cl-ext]
  
\end{function}

\begin{function}{non-positive-rational-p}{n}[cl-ext]
  
\end{function}

\begin{function}{non-positive-real-p}{n}[cl-ext]
  
\end{function}

\begin{function}{non-positive-short-float-p}{n}[cl-ext]
  
\end{function}

\begin{function}{non-positive-single-float-p}{n}[cl-ext]
  
\end{function}

\begin{function}{positive-double-float-p}{n}[cl-ext]
  
\end{function}

\begin{function}{positive-fixnum-p}{n}[cl-ext]
  
\end{function}

\begin{function}{positive-float-p}{n}[cl-ext]
  
\end{function}

\begin{function}{positive-integer-p}{n}[cl-ext]
  
\end{function}

\begin{function}{positive-long-float-p}{n}[cl-ext]
  
\end{function}

\begin{function}{positive-rational-p}{n}[cl-ext]
  
\end{function}

\begin{function}{positive-real-p}{n}[cl-ext]
  
\end{function}

\begin{function}{positive-short-float-p}{n}[cl-ext]
  
\end{function}

\begin{function}{positive-single-float-p}{n}[cl-ext]
  
\end{function}

\section{Number comparison}
\label{sec:number-comparison}

\begin{function}{/=}{number \rest more-numbers}
  Return T if no two of its arguments are numerically equal, NIL otherwise.
\end{function}

\begin{function}{=}{number \rest more-numbers}
  Return T if all of its arguments are numerically equal, NIL otherwise.
\end{function}

\begin{function}{>}{number \rest more-numbers}
  Return T if its arguments are in strictly decreasing order, NIL otherwise.
\end{function}

\begin{function}{>=}{number \rest more-numbers}
  Return T if arguments are in strictly non-increasing order, NIL otherwise.
\end{function}

\begin{function}{<}{number \rest more-numbers}
  Return T if its arguments are in strictly increasing order, NIL otherwise.
\end{function}

\begin{function}{<=}{number \rest more-numbers}
  Return T if arguments are in strictly non-decreasing order, NIL otherwise.
\end{function}

\begin{function}{max}{number \rest more-numbers}
  Return the greatest of its arguments; among EQUALP greatest, return
the first.
\end{function}

\begin{function}{min}{number \rest more-numbers}
  Return the least of its arguments; among EQUALP least, return
the first.
\end{function}

\begin{macro}{maxf}{place \rest numbers \env env}[cl-ext]
  Modify-macro for MAX. Sets place designated by the first argument to the
maximum of its original value and NUMBERS.
\end{macro}

\begin{macro}{minf}{place \rest numbers \env env}[cl-ext]
  Modify-macro for MIN. Sets place designated by the first argument to the
minimum of its original value and NUMBERS.
\end{macro}

\section{Arithmetic Operations}
\label{sec:arithm-oper}

\begin{function}{*}{\rest args}
  Return the product of its arguments. With no args, returns 1.
\end{function}

\begin{function}{+}{\rest args}
  Return the sum of its arguments. With no args, returns 0.
\end{function}

\begin{function}{-}{number \rest more-numbers}
  Subtract the second and all subsequent arguments from the first;
  or with one argument, negate the first argument.
\end{function}

\begin{function}{/}{number \rest more-numbers}
  Divide the first argument by each of the following arguments, in turn.
  With one argument, return reciprocal.
\end{function}

\begin{function}{1+}{number}
  Return NUMBER + 1.
\end{function}

\begin{function}{1-}{number}
  Return NUMBER - 1.
\end{function}

\begin{function}{square}{n}[cl-ext]
  Return $n^2$
\end{function}

\begin{macro}{decf}{place \op delta \env env}
  The first argument is some location holding a number. This number is
  decremented by the second argument, DELTA, which defaults to 1.
\end{macro}

\begin{macro}{incf}{place \op delta \env env}
  The first argument is some location holding a number. This number is
  incremented by the second argument, DELTA, which defaults to 1.
\end{macro}

\begin{macro}{mulf}{place b \env env}[cl-ext]
  SETF NUM to the result of (* NUM B).
\end{macro}

\begin{macro}{divf}{place b \env env}[cl-ext]
  SETF NUM to the result of (/ NUM B).
\end{macro}

\begin{function}{abs}{number}
  Return the absolute value of the number.
\end{function}

\begin{function}{conjugate}{number}
  Return the complex conjugate of NUMBER. For non-complex numbers, this is
  an identity.
\end{function}

\begin{function}{gcd}{\rest integers}
  Return the greatest common divisor of the arguments, which must be
  integers. Gcd with no arguments is defined to be 0.
\end{function}

\begin{function}{lcm}{\rest integers}
  Return the least common multiple of one or more integers. LCM of no
  arguments is defined to be 1.
\end{function}

\begin{function}{signum}{number}
  Return the signal of a number as -1, 0, or 1.
\end{function}

\begin{function}{clamp}{number min max}[cl-ext]
  Clamps the NUMBER into [MIN, MAX] range. Returns MIN if NUMBER
  lesser then MIN and MAX if NUMBER is greater then MAX, otherwise
  returns NUMBER. This is a convenient way of limiting values to a set
  boundary.
\end{function}

\begin{function}{sum}{numbers \op key}[cl-ext]
  Add up all the numbers; if KEY is given, apply it to each number
  first.
\end{function}

\begin{function}{factorial}{n}[cl-ext]
  Factorial of non-negative integer N.
\end{function}

\begin{function}{subfactorial}{n}[cl-ext]
  Subfactorial of the non-negative integer N.
\end{function}

\begin{function}{lerp}{v a b}[cl-ext]
  Returns the result of linear interpolation between A and B, using the
interpolation coefficient V.
\end{function}

\begin{function}{mean}{sample}[cl-ext]
  Returns the mean of SAMPLE. SAMPLE must be a sequence of numbers.
\end{function}

\begin{function}{median}{sample}[cl-ext]
  Returns median of SAMPLE. SAMPLE must be a sequence of real numbers.
\end{function}

\begin{function}{variance}{sample \key biased}[cl-ext]
  Variance of SAMPLE. Returns the biased variance if BIASED is true (the default),
and the unbiased estimator of variance if BIASED is false. SAMPLE must be a
sequence of numbers.
\end{function}

\begin{function}{between}{x y z}[cl-ext]
  Predicate; return t iff number x is between numbers y and z.
\end{function}

\begin{function}{dot-product}{l1 l2 \aux sum}[cl-ext]
  Dot product of two lists.
\end{function}

\section{Exponential and Logarithmic Functions}
\label{sec:expon-logar-funct}

\begin{function}[10caret]{10\^{}}{n}[cl-ext]
  Return 10 to the \var{n}.
\end{function}

\begin{function}{exp}{number}
  Return e raised to the power NUMBER.
\end{function}

\begin{function}{expt}{base power}
  Return BASE raised to the POWER.
\end{function}

\begin{function}{log}{number \op base}
  Return the logarithm of NUMBER in the base BASE, which defaults to e.
\end{function}

\begin{function}{isqrt}{n}
  Return the root of the nearest integer less than n which is a perfect
   square.
\end{function}

\begin{function}{sqrt}{number}
  Return the square root of NUMBER.
\end{function}

\section{Trigonometric functions}
\label{sec:trig-funct}

See also \funr{abs} and \funr{signum} since they are extended to operate
on complex numbers.

\begin{constant}{pi}{}
  
\end{constant}

\begin{function}{acos}{number}
  Return the arc cosine of NUMBER.
\end{function}

\begin{function}{acosh}{number}
  Return the hyperbolic arc cosine of NUMBER.
\end{function}

\begin{function}{asin}{number}
  Return the arc sine of NUMBER.
\end{function}

\begin{function}{asinh}{number}
  Return the hyperbolic arc sine of NUMBER.
\end{function}

\begin{function}{atan}{y \op x}
  Return the arc tangent of Y if X is omitted or Y/X if X is supplied.
\end{function}

\begin{function}{atanh}{number}
  Return the hyperbolic arc tangent of NUMBER.
\end{function}

\begin{function}{cis}{theta}
  Return cos(Theta) + i sin(Theta), i.e. exp(i Theta).
\end{function}

\begin{function}{cos}{number}
  Return the cosine of NUMBER.
\end{function}

\begin{function}{cosh}{number}
  Return the hyperbolic cosine of NUMBER.
\end{function}

\begin{function}{phase}{number}
  Return the angle part of the polar representation of a complex number.
  For complex numbers, this is (atan (imagpart number) (realpart number)).
  For non-complex positive numbers, this is 0. For non-complex negative
  numbers this is PI.
\end{function}

\begin{function}{sin}{number}
  Return the sine of NUMBER.
\end{function}

\begin{function}{sinh}{number}
  Return the hyperbolic sine of NUMBER.
\end{function}

\begin{function}{tan}{number}
  Return the tangent of NUMBER.
\end{function}

\begin{function}{tanh}{number}
  Return the hyperbolic tangent of NUMBER.
\end{function}

\section{Type Conversions and Component Extractions}
\label{sec:type-conv-comp}

\begin{function}{float}{number \op other}
  Converts any REAL to a float. If OTHER is not provided, it returns a
  SINGLE-FLOAT if NUMBER is not already a FLOAT. If OTHER is provided, the
  result is the same float format as OTHER.
\end{function}

\begin{function}{denominator}{number}
  Return the denominator of NUMBER, which must be rational.
\end{function}

\begin{function}{numerator}{number}
  Return the numerator of NUMBER, which must be rational.
\end{function}

\begin{function}{rational}{x}
  RATIONAL produces a rational number for any real numeric argument. This is
  more efficient than RATIONALIZE, but it assumes that floating-point is
  completely accurate, giving a result that isn't as pretty.
\end{function}

\begin{function}{rationalize}{x}
  Converts any REAL to a RATIONAL.  Floats are converted to a simple rational
  representation exploiting the assumption that floats are only accurate to
  their precision.  RATIONALIZE (and also RATIONAL) preserve the invariant:
      (= x (float (rationalize x) x))
\end{function}

\begin{function}{mod}{number divisor}
  Return second result of FLOOR.
\end{function}

\begin{function}{rem}{number divisor}
  Return second result of TRUNCATE.
\end{function}

\begin{function}{ceiling}{number \op divisor}
  Return the smallest integer not less than number, or number/divisor.
  The second returned value is the remainder.
\end{function}

\begin{function}{floor}{number \op divisor}
  Return the greatest integer not greater than number, or number/divisor.
  The second returned value is (mod number divisor).
\end{function}

\begin{function}{round}{number \op divisor}
  Rounds number (or number/divisor) to nearest integer.
  The second returned value is the remainder.
\end{function}

\begin{function}{truncate}{number \op divisor}
  Return number (or number/divisor) as an integer, rounded toward 0.
  The second returned value is the remainder.
\end{function}

\begin{function}{fceiling}{number \op divisor}
  Same as CEILING, but returns first value as a float.
\end{function}

\begin{function}{ffloor}{number \op divisor}
  Same as FLOOR, but returns first value as a float.
\end{function}

\begin{function}{fround}{number \op divisor}
  Same as ROUND, but returns first value as a float.
\end{function}

\begin{function}{ftruncate}{number \op divisor}
  Same as TRUNCATE, but returns first value as a float.
\end{function}

\begin{function}{decode-float}{f}
  Return three values:
   1) a floating-point number representing the significand. This is always
      between 0.5 (inclusive) and 1.0 (exclusive).
   2) an integer representing the exponent.
   3) -1.0 or 1.0 (i.e. the sign of the argument.)
\end{function}

\begin{function}{scale-float}{f ex}
  Return the value (* f (expt (float 2 f) ex)), but with no unnecessary loss
  of precision or overflow.
\end{function}

\begin{function}{float-digits}{f}
  
\end{function}

\begin{function}{float-precision}{f}
  Return a non-negative number of significant digits in its float argument.
  Will be less than FLOAT-DIGITS if denormalized or zero.
\end{function}

\begin{function}{float-radix}{x}
  Return (as an integer) the radix b of its floating-point argument.
\end{function}

\begin{function}{float-sign}{float1 \op float2}
  Return a floating-point number that has the same sign as
   FLOAT1 and, if FLOAT2 is given, has the same absolute value
   as FLOAT2.
\end{function}

\begin{function}{integer-decode-float}{x}
  Return three values:
   1) an integer representation of the significand.
   2) the exponent for the power of 2 that the significand must be multiplied
      by to get the actual value. This differs from the DECODE-FLOAT exponent
      by FLOAT-DIGITS, since the significand has been scaled to have all its
      digits before the radix point.
   3) -1 or 1 (i.e. the sign of the argument.)
\end{function}

\begin{function}{complex}{realpart \op imagpart}
  Return a complex number with the specified real and imaginary components.
\end{function}

\begin{function}{realpart}{number}
  Extract the real part of a number.
\end{function}

\begin{function}{imagpart}{number}
  Extract the imaginary part of a number.
\end{function}

\begin{function}{upgraded-complex-part-type}{spec \op environment}
  Return the element type of the most specialized COMPLEX number type that
   can hold parts of type SPEC.
\end{function}

\section{Logic operations}
\label{sec:logic-operations}

\begin{function}{boole}{op integer1 integer2}
  Bit-wise boolean function on two integers. Function chosen by OP:
        0       BOOLE-CLR
        1       BOOLE-SET
        2       BOOLE-1
        3       BOOLE-2
        4       BOOLE-C1
        5       BOOLE-C2
        6       BOOLE-AND
        7       BOOLE-IOR
        8       BOOLE-XOR
        9       BOOLE-EQV
        10      BOOLE-NAND
        11      BOOLE-NOR
        12      BOOLE-ANDC1
        13      BOOLE-ANDC2
        14      BOOLE-ORC1
        15      BOOLE-ORC2
\end{function}

\begin{constant}{boole-1}{}
  
\end{constant}

\begin{constant}{boole-2}{}
  
\end{constant}

\begin{constant}{boole-and}{}
  
\end{constant}

\begin{constant}{boole-andc1}{}
  
\end{constant}

\begin{constant}{boole-andc2}{}
  
\end{constant}

\begin{constant}{boole-c1}{}
  
\end{constant}

\begin{constant}{boole-c2}{}
  
\end{constant}

\begin{constant}{boole-clr}{}
  
\end{constant}

\begin{constant}{boole-eqv}{}
  
\end{constant}

\begin{constant}{boole-ior}{}
  
\end{constant}

\begin{constant}{boole-nand}{}
  
\end{constant}

\begin{constant}{boole-nor}{}
  
\end{constant}

\begin{constant}{boole-orc1}{}
  
\end{constant}

\begin{constant}{boole-orc2}{}
  
\end{constant}

\begin{constant}{boole-set}{}
  
\end{constant}

\begin{constant}{boole-xor}{}
  
\end{constant}

\begin{function}{logand}{\rest integers}
  Return the bit-wise and of its arguments. Args must be integers.
\end{function}

\begin{function}{logandc1}{integer1 integer2}
  Bitwise AND (LOGNOT INTEGER1) with INTEGER2.
\end{function}

\begin{function}{logandc2}{integer1 integer2}
  Bitwise AND INTEGER1 with (LOGNOT INTEGER2).
\end{function}

\begin{function}{logcount}{integer}
  Count the number of 1 bits if INTEGER is positive, and the number of 0 bits
  if INTEGER is negative.
\end{function}

\begin{function}{logeqv}{\rest integers}
  Return the bit-wise equivalence of its arguments. Args must be integers.
\end{function}

\begin{function}{logior}{\rest integers}
  Return the bit-wise or of its arguments. Args must be integers.
\end{function}

\begin{function}{lognand}{integer1 integer2}
  Complement the logical AND of INTEGER1 and INTEGER2.
\end{function}

\begin{function}{lognor}{integer1 integer2}
  Complement the logical AND of INTEGER1 and INTEGER2.
\end{function}

\begin{function}{lognot}{number}
  Return the bit-wise logical not of integer.
\end{function}

\begin{function}{logorc1}{integer1 integer2}
  Bitwise OR (LOGNOT INTEGER1) with INTEGER2.
\end{function}

\begin{function}{logorc2}{integer1 integer2}
  Bitwise OR INTEGER1 with (LOGNOT INTEGER2).
\end{function}

\begin{function}{logtest}{integer1 integer2}
  Predicate which returns T if logand of integer1 and integer2 is not zero.
\end{function}

\begin{function}{logxor}{\rest integers}
  Return the bit-wise exclusive or of its arguments. Args must be integers.
\end{function}

\begin{function}{ash}{integer count}
  Shifts integer left by count places preserving sign. - count shifts right.
\end{function}

\begin{function}{integer-length}{integer}
  Return the number of non-sign bits in the twos-complement representation
  of INTEGER.
\end{function}

\section{Byte Manipulation Functions}
\label{sec:byte-manip-funct}

\begin{function}{byte}{size position}
  Return a byte specifier which may be used by other byte functions
  (e.g. LDB).
\end{function}

\begin{function}{byte-position}{bytespec}
  Return the position part of the byte specifier bytespec.
\end{function}

\begin{function}{byte-size}{bytespec}
  Return the size part of the byte specifier bytespec.
\end{function}

\begin{function}{deposit-field}{newbyte bytespec integer}
  Return new integer with newbyte in specified position, newbyte is not right justified.
\end{function}

\begin{function}{dpb}{newbyte bytespec integer}
  Return new integer with newbyte in specified position, newbyte is right justified.
\end{function}

\begin{function}{ldb-test}{bytespec integer}
  Return T if any of the specified bits in integer are 1's.
\end{function}

\begin{accessor}{ldb}{bytespec integer}
  Extract the specified byte from integer, and right justify result.
\end{accessor}

\begin{accessor}{mask-field}{bytespec integer}
  Extract the specified byte from integer,  but do not right justify result.
\end{accessor}

\section{Random numbers}
\label{sec:random-numbers}

See also \funr{random-state-p}

\begin{function}{random}{arg \op state}
  
\end{function}

\begin{function}{random-integer}{from to}[cl-ext]
  Return an integer chosen at random from the given interval.
\end{function}

\begin{function}{make-random-state}{\op state}
  Make a random state object. If STATE is not supplied, return a copy
  of the default random state. If STATE is a random state, then return a
  copy of it. If STATE is T then return a random state generated from
  the universal time.
\end{function}

\begin{class}{random-state}{}
  
\end{class}

\begin{variable}{*random-state*}{}
  
\end{variable}

\section{Implementation Parameters}
\label{sec:impl-param}

\begin{constant}{most-negative-double-float}{}
  
\end{constant}

\begin{constant}{most-negative-fixnum}{}
  
\end{constant}

\begin{constant}{most-negative-long-float}{}
  
\end{constant}

\begin{constant}{most-negative-short-float}{}
  
\end{constant}

\begin{constant}{most-negative-single-float}{}
  
\end{constant}

\begin{constant}{most-positive-double-float}{}
  
\end{constant}

\begin{constant}{most-positive-fixnum}{}
  
\end{constant}

\begin{constant}{most-positive-long-float}{}
  
\end{constant}

\begin{constant}{most-positive-short-float}{}
  
\end{constant}

\begin{constant}{most-positive-single-float}{}
  
\end{constant}

\begin{constant}{least-negative-double-float}{}
  
\end{constant}

\begin{constant}{least-negative-long-float}{}
  
\end{constant}

\begin{constant}{least-negative-normalized-double-float}{}
  
\end{constant}

\begin{constant}{least-negative-normalized-long-float}{}
  
\end{constant}

\begin{constant}{least-negative-normalized-short-float}{}
  
\end{constant}

\begin{constant}{least-negative-normalized-single-float}{}
  
\end{constant}

\begin{constant}{least-negative-short-float}{}
  
\end{constant}

\begin{constant}{least-negative-single-float}{}
  
\end{constant}

\begin{constant}{least-positive-double-float}{}
  
\end{constant}

\begin{constant}{least-positive-long-float}{}
  
\end{constant}

\begin{constant}{least-positive-normalized-double-float}{}
  
\end{constant}

\begin{constant}{least-positive-normalized-long-float}{}
  
\end{constant}

\begin{constant}{least-positive-normalized-short-float}{}
  
\end{constant}

\begin{constant}{least-positive-normalized-single-float}{}
  
\end{constant}

\begin{constant}{least-positive-short-float}{}
  
\end{constant}

\begin{constant}{least-positive-single-float}{}
  
\end{constant}

\begin{constant}{double-float-epsilon}{}
  
\end{constant}

\begin{constant}{double-float-negative-epsilon}{}
  
\end{constant}

\begin{constant}{long-float-epsilon}{}
  
\end{constant}

\begin{constant}{long-float-negative-epsilon}{}
  
\end{constant}

\begin{constant}{short-float-epsilon}{}
  
\end{constant}

\begin{constant}{short-float-negative-epsilon}{}
  
\end{constant}

\begin{constant}{single-float-epsilon}{}
  
\end{constant}

\begin{constant}{single-float-negative-epsilon}{}
  
\end{constant}

\section{Other extensions}
\label{sec:other-extensions}

\begin{function}{gaussian-random}{\op min max}[cl-ext]
  Returns two gaussian random double floats as the primary and secondary value,
optionally constrained by MIN and MAX. Gaussian random numbers form a standard
normal distribution around 0.0d0.
\end{function}

\begin{function}{binomial-coefficient}{n k}[cl-ext]
  Binomial coefficient of N and K, also expressed as N choose K. This is the
number of K element combinations given N choises. N must be equal to or
greater then K.
\end{function}

\begin{function}{count-permutations}{n \op k}[cl-ext]
  Number of K element permutations for a sequence of N objects.
R defaults to N
\end{function}

\begin{function}{standard-deviation}{sample \key biased}[cl-ext]
  Standard deviation of SAMPLE. Returns the biased standard deviation if
BIASED is true (the default), and the square root of the unbiased estimator
for variance if BIASED is false (which is not the same as the unbiased
estimator for standard deviation). SAMPLE must be a sequence of numbers.
\end{function}

\begin{function}{expt-mod}{n exponent modulus}[cl-ext]
  As (mod (expt n exponent) modulus), but more efficient.
\end{function}


\chapter{Characters}

\section{Predicates}
\label{sec:character-predicates}

\begin{function}{alpha-char-p}{char}
  The argument must be a character object. ALPHA-CHAR-P returns T if the
   argument is an alphabetic character, A-Z or a-z; otherwise NIL.
\end{function}

\begin{function}{alphanumericp}{char}
  Given a character-object argument, ALPHANUMERICP returns T if the
   argument is either numeric or alphabetic.
\end{function}

\begin{function}{both-case-p}{char}
  The argument must be a character object. BOTH-CASE-P returns T if the
  argument is an alphabetic character and if the character exists in
  both upper and lower case. For ASCII, this is the same as ALPHA-CHAR-P.
\end{function}

\begin{function}{char-greaterp}{character \rest more-characters}
  Return T if the arguments are in strictly decreasing alphabetic order.
   Font, bits, and case are ignored.
\end{function}

\begin{function}{char-lessp}{character \rest more-characters}
  Return T if the arguments are in strictly increasing alphabetic order.
   Font, bits, and case are ignored.
\end{function}

\begin{function}{char-not-greaterp}{character \rest more-characters}
  Return T if the arguments are in strictly non-decreasing alphabetic order.
   Font, bits, and case are ignored.
\end{function}

\begin{function}{char-not-lessp}{character \rest more-characters}
  Return T if the arguments are in strictly non-increasing alphabetic order.
   Font, bits, and case are ignored.
\end{function}

\begin{function}{characterp}{object}
  Return true if OBJECT is a CHARACTER, and NIL otherwise.
\end{function}

\begin{function}{digit-char-p}{char \op radix}
  If char is a digit in the specified radix, returns the fixnum for
  which that digit stands, else returns NIL.
\end{function}

\begin{function}{graphic-char-p}{char}
  The argument must be a character object. GRAPHIC-CHAR-P returns T if the
  argument is a printing character (space through \~{}\% in ASCII), otherwise
  returns NIL.
\end{function}

\begin{function}{lower-case-p}{char}
  The argument must be a character object; LOWER-CASE-P returns T if the
   argument is a lower-case character, NIL otherwise.
\end{function}

\begin{function}{standard-char-p}{char}
  The argument must be a character object. STANDARD-CHAR-P returns T if the
   argument is a standard character -- one of the 95 ASCII printing characters
   or <return>.
\end{function}

\begin{function}{upper-case-p}{char}
  The argument must be a character object; UPPER-CASE-P returns T if the
   argument is an upper-case character, NIL otherwise.
\end{function}

\section{Character comparison}
\label{sec:character-comparison}

\begin{function}{char-equal}{character \rest more-characters}
  Return T if all of the arguments are the same character.
  Font, bits, and case are ignored.
\end{function}

\begin{function}{char-not-equal}{character \rest more-characters}
  Return T if no two of the arguments are the same character.
   Font, bits, and case are ignored.
\end{function}

\begin{function}{char/=}{character \rest more-characters}
  Return T if no two of the arguments are the same character.
\end{function}

\begin{function}{char<}{character \rest more-characters}
  Return T if the arguments are in strictly increasing alphabetic order.
\end{function}

\begin{function}{char<=}{character \rest more-characters}
  Return T if the arguments are in strictly non-decreasing alphabetic order.
\end{function}

\begin{function}{char=}{character \rest more-characters}
  Return T if all of the arguments are the same character.
\end{function}

\begin{function}{char>}{character \rest more-characters}
  Return T if the arguments are in strictly decreasing alphabetic order.
\end{function}

\begin{function}{char>=}{character \rest more-characters}
  Return T if the arguments are in strictly non-increasing alphabetic order.
\end{function}

\section{Construction and selection}
\label{sec:character-constr-select}

\begin{constant}{char-code-limit}{}
  
\end{constant}

\begin{function}{char-code}{char}
  Return the integer code of CHAR.
\end{function}

\begin{function}{code-char}{code}
  Return the character with the code CODE.
\end{function}

\section{Conversions}
\label{sec:character-conversions}

\begin{function}{character}{object}
  Coerce OBJECT into a CHARACTER if possible. Legal inputs are
  characters, strings and symbols of length 1.
\end{function}

\begin{function}{char-upcase}{char}
  Return CHAR converted to upper-case if that is possible.  Don't convert
   lowercase eszet (U+DF).
\end{function}

\begin{function}{char-downcase}{char}
  Return CHAR converted to lower-case if that is possible.
\end{function}

\begin{function}{char-int}{char}
  Return the integer code of CHAR. (In SBCL this is the same as CHAR-CODE, as
   there are no character bits or fonts.)
\end{function}

\begin{function}{digit-char}{weight \op radix}
  All arguments must be integers. Returns a character object that
  represents a digit of the given weight in the specified radix. Returns
  NIL if no such character exists.
\end{function}

\begin{function}{char-name}{char}
  Return the name (a STRING) for a CHARACTER object.
\end{function}

\begin{function}{name-char}{name}
  Given an argument acceptable to STRING, NAME-CHAR returns a character
  whose name is that string, if one exists. Otherwise, NIL is returned.
\end{function}



\chapter{Strings}
\label{cha:strings}

See also the chapter on sequences () for functions to split strings and
since strings are array see also the chapter on arrays.

\begin{type}{string-designator}{}[cl-ext]
  A string designator type. A string designator is either a string, a
  symbol, or a character.
\end{type}

\section{Predicates}
\label{sec:string-predicates}

See also string-greaterp, \funr{string-lessp},
\funr{string-not-greaterp}, and \funr{string-not-lessp}.

\begin{function}{stringp}{object}
  Return true if OBJECT is a STRING, and NIL otherwise.
\end{function}

\begin{function}{simple-string-p}{object}
  Return true if OBJECT is a SIMPLE-STRING, and NIL otherwise.
\end{function}

\begin{function}{empty-string-p}{string}[cl-ext]
  Indicates, if a given string is empty (or being nil)
\end{function}

\section{String constants}
\label{sec:string-constants}

\begin{constant}{+lower-case-ascii-alphabet+}{}[cl-ext]
  All the lower case letters in 7 bit ASCII.
\end{constant}

\begin{constant}{+upper-case-ascii-alphabet+}{}[cl-ext]
  All the upper case letters in 7 bit ASCII.
\end{constant}

\begin{constant}{+alphanumeric-ascii-alphabet+}{}[cl-ext]
  All the letters and numbers in 7 bit ASCII.
\end{constant}

\begin{constant}{+ascii-alphabet+}{}[cl-ext]
  All letters in 7 bit ASCII.
\end{constant}

\begin{constant}{+base64-alphabet+}{}[cl-ext]
  All the characters allowed in base64 encoding.
\end{constant}

\section{String access}
\label{sec:string-access}

\begin{accessor}{char}{string index}
  Given a string and a non-negative integer index less than the length of
  the string, returns the character object representing the character at
  that position in the string.
\end{accessor}

\begin{accessor}{schar}{string index}
  SCHAR returns the character object at an indexed position in a string
   just as CHAR does, except the string must be a simple-string.
\end{accessor}

\section{Comparison}
\label{sec:string-comparison}

\begin{function}{string/=}{string1 string2 \key start1 end1 start2 end2}
  Given two strings, if the first string is not lexicographically equal
  to the second string, returns the longest common prefix (using char=)
  of the two strings. Otherwise, returns ().
\end{function}

\begin{function}{string<}{string1 string2 \key start1 end1 start2 end2}
  Given two strings, if the first string is lexicographically less than
  the second string, returns the longest common prefix (using char=)
  of the two strings. Otherwise, returns ().
\end{function}

\begin{function}{string<=}{string1 string2 \key start1 end1 start2 end2}
  Given two strings, if the first string is lexicographically less than
  or equal to the second string, returns the longest common prefix
  (using char=) of the two strings. Otherwise, returns ().
\end{function}

\begin{function}{string=}{string1 string2 \key start1 end1 start2 end2}
  Given two strings (string1 and string2), and optional integers start1,
  start2, end1 and end2, compares characters in string1 to characters in
  string2 (using char=).
\end{function}

\begin{function}{string>}{string1 string2 \key start1 end1 start2 end2}
  Given two strings, if the first string is lexicographically greater than
  the second string, returns the longest common prefix (using char=)
  of the two strings. Otherwise, returns ().
\end{function}

\begin{function}{string>=}{string1 string2 \key start1 end1 start2 end2}
  Given two strings, if the first string is lexicographically greater
  than or equal to the second string, returns the longest common prefix
  (using char=) of the two strings. Otherwise, returns ().
\end{function}

The following functions are just like \fun{string<}, \fun{string>}, \fun{string<=},
\fun{string>=}, and \fun{string/=} except they are case insensitive.

\begin{function}{string-equal}{string1 string2 \key start1 end1 start2 end2}
  Given two strings (string1 and string2), and optional integers start1,
  start2, end1 and end2, compares characters in string1 to characters in
  string2 (using char-equal).
\end{function}

\begin{function}{string-greaterp}{string1 string2 \key start1 end1 start2 end2}
  Given two strings, if the first string is lexicographically greater than
  the second string, returns the longest common prefix (using char-equal)
  of the two strings. Otherwise, returns ().
\end{function}

\begin{function}{string-lessp}{string1 string2 \key start1 end1 start2 end2}
  Given two strings, if the first string is lexicographically less than
  the second string, returns the longest common prefix (using char-equal)
  of the two strings. Otherwise, returns ().
\end{function}

\begin{function}{string-not-equal}{string1 string2 \key start1 end1 start2 end2}
  Given two strings, if the first string is not lexicographically equal
  to the second string, returns the longest common prefix (using char-equal)
  of the two strings. Otherwise, returns ().
\end{function}

\begin{function}{string-not-greaterp}{string1 string2 \key start1 end1 start2 end2}
  Given two strings, if the first string is lexicographically less than
  or equal to the second string, returns the longest common prefix
  (using char-equal) of the two strings. Otherwise, returns ().
\end{function}

\begin{function}{string-not-lessp}{string1 string2 \key start1 end1 start2 end2}
  Given two strings, if the first string is lexicographically greater
  than or equal to the second string, returns the longest common prefix
  (using char-equal) of the two strings. Otherwise, returns ().
\end{function}

\section{Construction and manipulation}
\label{sec:constr-manip}

\begin{function}{string}{x}
  Coerces X into a string. If X is a string, X is returned. If X is a
   symbol, X's pname is returned. If X is a character then a one element
   string containing that character is returned. If X cannot be coerced
   into a string, an error occurs.
\end{function}

\begin{function}{make-string}{count \key element-type (initial-element fill-char)}
  Given a character count and an optional fill character, makes and returns a
new string COUNT long filled with the fill character.
\end{function}

\begin{function}{random-string}{\op length alphabet}[cl-ext]
  Returns a random alphabetic string. The returned string will contain
  LENGTH characters chosen from the vector ALPHABET.
\end{function}

\begin{function}{string-trim}{char-bag string}
  
\end{function}

\begin{function}{string-left-trim}{char-bag string}
  
\end{function}

\begin{function}{string-right-trim}{char-bag string}
  
\end{function}

\begin{function}{string-downcase}{string \key start end}
  
\end{function}

\begin{function}{string-upcase}{string \key start end}
  
\end{function}

\begin{function}{string-capitalize}{string \key start end}
  
\end{function}

\begin{function}{nstring-downcase}{string \key start end}
  
\end{function}

\begin{function}{nstring-upcase}{string \key start end}
  
\end{function}

\begin{function}{nstring-capitalize}{string \key start end}
  
\end{function}

\begin{function}{stringify}{argument}[cl-ext]
  Coerce argument to a string.
\end{function}

\begin{function}{strcat}{\rest items}[cl-ext]
  Returns a fresh string consisting of ITEMS concat'd together.
\end{function}

\begin{function}{strcat*}{string-designators}[cl-ext]
  Concatenate all the strings in STRING-DESIGNATORS.
\end{function}

\begin{function}{join-strings}{strings}[cl-ext]
  Concatenate strings. It's a fast shorthand for \code{(concatenate
    'string string1 \ldots stringn)}.
\end{function}

\begin{function}{fold-strings}{}[cl-ext]
  
\end{function}

\begin{function}{split-tab}{string}[cl-ext]
  Utility function to split a string by tabs and remove empty
  subsequences.
\end{function}

\begin{function}{split-space}{string}[cl-ext]
  Utility function to split a string by spaces and remove empty
  subsequences.
\end{function}

\begin{function}{split-newline}{string}[cl-ext]
  Utility function to split a string by newlines and remove empty
  subsequences.
\end{function}

\begin{function}{replace-all}{part string replacement \key test}[cl-ext]
  Returns a new string in which all the occurences of the part is
  replaced with replacement. It was taken from the cl-cookbook, it's
  not as optimized as cl-ppcre, but if you just want to replace
  strings it may be faster in some cases.
\end{function}

\begin{function}{string-from-array}{array \key start end}[cl-ext]
  Assuming ARRAY is an array of ASCII chars encoded as bytes return
the corresponding string. Respect the C convention of null terminating
strings. START and END specify the zero indexed offsets of a sub range
of ARRAY.
\end{function}

\begin{function}{octets-to-string}{octets encoding}[cl-ext]
  
\end{function}

\begin{function}{string-to-octets}{string encoding}[cl-ext]
  Convert STRING, a list string, a vector of bytes according to ENCODING.

ENCODING is a keyword representing the desired character
encoding. We gurantee that :UTF-8, :UTF-16 and :ISO-8859-1 will
work as expected. Any other values are simply passed to the
underlying lisp's function and the results are implementation
dependant.

On CLISP we intern the ENCODING symbol in the CHARSET package and
pass that. On SBCL we simply pass the keyword.
\end{function}

\begin{function}{encoding-keyword-to-native}{encoding}[cl-ext]
  Convert ENCODING, a keyword, to an object the native list
accepts as an encoding.

ENCODING can be: :UTF-8, :UTF-16, or :US-ASCII and specify the
corresponding encodings. Any other keyword is passed, as is, to
the underlying lisp.
\end{function}

\section{String reading}
\label{sec:string-reading}

\begin{function}{parse-integer}{string \key start end radix junk-allowed}
  Examine the substring of string delimited by start and end
  (default to the beginning and end of the string)  It skips over
  whitespace characters and then tries to parse an integer. The
  radix parameter must be between 2 and 36.
\end{function}

\begin{function}{parse-float}{float-string \key start end radix junk-allowed type decimal-character}[cl-ext]
\end{function}

\begin{function}{parse-number}{string \key start end radix}[cl-ext]
  Given a string, and start, end, and radix parameters, produce a
  number according to the syntax definitions in the Common Lisp
  Hyperspec.  
\end{function}

\begin{function}{parse-real-number}{string \key start end radix}[cl-ext]
  Given a string, and start, end, and radix parameters, produce a
  number according to the syntax definitions in the Common Lisp
  Hyperspec---except for complex numbers.
\end{function}

\begin{function}{parse-positive-real-number}{string \key start end radix}[cl-ext]
  Given a string, and start, end, and radix parameters, produce a
  number according to the syntax definitions in the Common Lisp
  Hyperspec---except for complex numbers and negative numbers.
\end{function}


\chapter{Arrays and vectors}
\label{cha:arrays}

\section{Predicates}
\label{sec:array-predicates}

\begin{function}{arrayp}{object}
  Return true if OBJECT is an ARRAY, and NIL otherwise.
\end{function}

\begin{function}{adjustable-array-p}{array}
  Return T if (ADJUST-ARRAY ARRAY...) would return an array identical
   to the argument, this happens for complex arrays.
\end{function}

\begin{function}{array-has-fill-pointer-p}{array}
  Return T if the given ARRAY has a fill pointer, or NIL otherwise.
\end{function}

\begin{function}{array-in-bounds-p}{array \rest subscripts}
  Return T if the SUBSCIPTS are in bounds for the ARRAY, NIL otherwise.
\end{function}

\begin{function}{vectorp}{object}
  Return true if OBJECT is a VECTOR, and NIL otherwise.
\end{function}

\begin{function}{bit-vector-p}{object}
  Return true if OBJECT is a BIT-VECTOR, and NIL otherwise.
\end{function}

\begin{function}{simple-bit-vector-p}{object}
  Return true if OBJECT is a SIMPLE-BIT-VECTOR, and NIL otherwise.
\end{function}

\begin{function}{simple-vector-p}{object}
  Return true if OBJECT is a SIMPLE-VECTOR, and NIL otherwise.
\end{function}

\section{Creation}
\label{sec:array-creation}

\begin{function}{make-array}{dimensions \key element-type initial-element initial-contents adjustable
 fill-pointer displaced-to displaced-index-offset}
  
\end{function}

\begin{function}{make-displaced-array}{array \op start end}[cl-ext]
  
\end{function}

\begin{function}{copy-array}{array \key element-type fill-pointer adjustable}[cl-ext]
  Returns an undisplaced copy of ARRAY, with same fill-pointer
and adjustability (if any) as the original, unless overridden by
the keyword arguments.
\end{function}

\begin{constant}{array-dimension-limit}{}
  
\end{constant}

\begin{constant}{array-rank-limit}{}
  
\end{constant}

\begin{constant}{array-total-size-limit}{}
  
\end{constant}

\begin{function}{vector}{\rest objects}
  Construct a SIMPLE-VECTOR from the given objects.
\end{function}

\section{Access}
\label{sec:array-access}

\begin{accessor}{aref}{array \rest subscripts}
  Return the element of the ARRAY specified by the SUBSCRIPTS.
\end{accessor}

\begin{accessor}{svref}{simple-vector index}
  Return the INDEX'th element of the given Simple-Vector.
\end{accessor}

\section{Array information}
\label{sec:array-information}

\begin{function}{array-dimension}{array axis-number}
  Return the length of dimension AXIS-NUMBER of ARRAY.
\end{function}

\begin{function}{array-dimensions}{array}
  Return a list whose elements are the dimensions of the array
\end{function}

\begin{function}{array-displacement}{array}
  Return the values of :DISPLACED-TO and :DISPLACED-INDEX-offset
   options to MAKE-ARRAY, or NIL and 0 if not a displaced array.
\end{function}

\begin{function}{array-element-type}{array}
  Return the type of the elements of the array
\end{function}

\begin{function}{array-rank}{array}
  Return the number of dimensions of ARRAY.
\end{function}

\begin{function}{array-total-size}{array}
  Return the total number of elements in the Array.
\end{function}

\begin{function}{array-row-major-index}{array \rest subscripts}
  
\end{function}

\begin{accessor}{row-major-aref}{array index}
  Return the element of array corressponding to the row-major index. This is
   SETF'able.
\end{accessor}

\begin{function}{print-grid}{array \key stream key width}[cl-ext]
  Print the contents of a 2-D array, numbering the edges.
\end{function}

\section{Functions on Arrays of Bits}
\label{sec:funct-arrays-bits}

An array of bits is a specialized array whose elements are only 0 or
1.

\begin{accessor}{bit}{bit-array \rest subscripts}
  Return the bit from the BIT-ARRAY at the specified SUBSCRIPTS.
\end{accessor}

\begin{accessor}{sbit}{simple-bit-array \rest subscripts}
  Return the bit from SIMPLE-BIT-ARRAY at the specified SUBSCRIPTS.
\end{accessor}

\begin{function}{bit-and}{bit-array-1 bit-array-2 \op result-bit-array}
  Perform a bit-wise LOGAND on the elements of BIT-ARRAY-1 and BIT-ARRAY-2,
  putting the results in RESULT-BIT-ARRAY. If RESULT-BIT-ARRAY is T,
  BIT-ARRAY-1 is used. If RESULT-BIT-ARRAY is NIL or omitted, a new array is
  created. All the arrays must have the same rank and dimensions.
\end{function}

\begin{function}{bit-andc1}{bit-array-1 bit-array-2 \op result-bit-array}
  Perform a bit-wise LOGANDC1 on the elements of BIT-ARRAY-1 and BIT-ARRAY-2,
  putting the results in RESULT-BIT-ARRAY. If RESULT-BIT-ARRAY is T,
  BIT-ARRAY-1 is used. If RESULT-BIT-ARRAY is NIL or omitted, a new array is
  created. All the arrays must have the same rank and dimensions.
\end{function}

\begin{function}{bit-andc2}{bit-array-1 bit-array-2 \op result-bit-array}
  Perform a bit-wise LOGANDC2 on the elements of BIT-ARRAY-1 and BIT-ARRAY-2,
  putting the results in RESULT-BIT-ARRAY. If RESULT-BIT-ARRAY is T,
  BIT-ARRAY-1 is used. If RESULT-BIT-ARRAY is NIL or omitted, a new array is
  created. All the arrays must have the same rank and dimensions.
\end{function}

\begin{function}{bit-eqv}{bit-array-1 bit-array-2 \op result-bit-array}
  Perform a bit-wise LOGEQV on the elements of BIT-ARRAY-1 and BIT-ARRAY-2,
  putting the results in RESULT-BIT-ARRAY. If RESULT-BIT-ARRAY is T,
  BIT-ARRAY-1 is used. If RESULT-BIT-ARRAY is NIL or omitted, a new array is
  created. All the arrays must have the same rank and dimensions.
\end{function}

\begin{function}{bit-ior}{bit-array-1 bit-array-2 \op result-bit-array}
  Perform a bit-wise LOGIOR on the elements of BIT-ARRAY-1 and BIT-ARRAY-2,
  putting the results in RESULT-BIT-ARRAY. If RESULT-BIT-ARRAY is T,
  BIT-ARRAY-1 is used. If RESULT-BIT-ARRAY is NIL or omitted, a new array is
  created. All the arrays must have the same rank and dimensions.
\end{function}

\begin{function}{bit-nand}{bit-array-1 bit-array-2 \op result-bit-array}
  Perform a bit-wise LOGNAND on the elements of BIT-ARRAY-1 and BIT-ARRAY-2,
  putting the results in RESULT-BIT-ARRAY. If RESULT-BIT-ARRAY is T,
  BIT-ARRAY-1 is used. If RESULT-BIT-ARRAY is NIL or omitted, a new array is
  created. All the arrays must have the same rank and dimensions.
\end{function}

\begin{function}{bit-nor}{bit-array-1 bit-array-2 \op result-bit-array}
  Perform a bit-wise LOGNOR on the elements of BIT-ARRAY-1 and BIT-ARRAY-2,
  putting the results in RESULT-BIT-ARRAY. If RESULT-BIT-ARRAY is T,
  BIT-ARRAY-1 is used. If RESULT-BIT-ARRAY is NIL or omitted, a new array is
  created. All the arrays must have the same rank and dimensions.
\end{function}

\begin{function}{bit-not}{bit-array \op result-bit-array}
  Performs a bit-wise logical NOT on the elements of BIT-ARRAY,
  putting the results in RESULT-BIT-ARRAY. If RESULT-BIT-ARRAY is T,
  BIT-ARRAY is used. If RESULT-BIT-ARRAY is NIL or omitted, a new array is
  created. Both arrays must have the same rank and dimensions.
\end{function}

\begin{function}{bit-orc1}{bit-array-1 bit-array-2 \op result-bit-array}
  Perform a bit-wise LOGORC1 on the elements of BIT-ARRAY-1 and BIT-ARRAY-2,
  putting the results in RESULT-BIT-ARRAY. If RESULT-BIT-ARRAY is T,
  BIT-ARRAY-1 is used. If RESULT-BIT-ARRAY is NIL or omitted, a new array is
  created. All the arrays must have the same rank and dimensions.
\end{function}

\begin{function}{bit-orc2}{bit-array-1 bit-array-2 \op result-bit-array}
  Perform a bit-wise LOGORC2 on the elements of BIT-ARRAY-1 and BIT-ARRAY-2,
  putting the results in RESULT-BIT-ARRAY. If RESULT-BIT-ARRAY is T,
  BIT-ARRAY-1 is used. If RESULT-BIT-ARRAY is NIL or omitted, a new array is
  created. All the arrays must have the same rank and dimensions.
\end{function}

\begin{function}{bit-xor}{bit-array-1 bit-array-2 \op result-bit-array}
  Perform a bit-wise LOGXOR on the elements of BIT-ARRAY-1 and BIT-ARRAY-2,
  putting the results in RESULT-BIT-ARRAY. If RESULT-BIT-ARRAY is T,
  BIT-ARRAY-1 is used. If RESULT-BIT-ARRAY is NIL or omitted, a new array is
  created. All the arrays must have the same rank and dimensions.
\end{function}

\section{Fill pointer}
\label{sec:fill-pointer}

\begin{accessor}{fill-pointer}{vector}
  Return the FILL-POINTER of the given VECTOR.
\end{accessor}

\begin{function}{vector-pop}{array}
  Decrease the fill pointer by 1 and return the element pointed to by the
  new fill pointer.
\end{function}

\begin{function}{vector-push}{new-el array}
  Attempt to set the element of ARRAY designated by its fill pointer
   to NEW-EL, and increment the fill pointer by one. If the fill pointer is
   too large, NIL is returned, otherwise the index of the pushed element is
   returned.
\end{function}

\begin{function}{vector-push-extend}{new-element vector \op min-extension}
  
\end{function}

\section{Changing dimensions}
\label{sec:changing-dimensions}

\begin{function}{adjust-array}{array dimensions \key element-type initial-element initial-contents
 fill-pointer displaced-to displaced-index-offset}
  Adjust ARRAY's dimensions to the given DIMENSIONS and stuff.
\end{function}

\section{Type upgrading}
\label{sec:type-upgrading}

\begin{function}{upgraded-array-element-type}{spec \op environment}
  Return the element type that will actually be used to implement an array
   with the specifier :ELEMENT-TYPE Spec.
\end{function}


\chapter{Lists}
\label{cha:lists}

\section{Predicates}
\label{sec:list-predicates}

\begin{function}{consp}{object}
  Return true if OBJECT is a CONS, and NIL otherwise.
\end{function}

\begin{function}{listp}{object}
  Return true if OBJECT is a LIST, and NIL otherwise.
\end{function}

\begin{function}{endp}{object}
  This is the recommended way to test for the end of a proper list. It
  returns true if OBJECT is NIL, false if OBJECT is a CONS, and an error
  for any other type of OBJECT.
\end{function}

\begin{function}{null}{object}
  Return true if OBJECT is a NULL, and NIL otherwise.
\end{function}

\begin{function}{atom}{object}
  Return true if OBJECT is an ATOM, and NIL otherwise.
\end{function}

\begin{function}{tailp}{object list}
  Return true if OBJECT is the same as some tail of LIST, otherwise
   returns false. LIST must be a proper list or a dotted list.
\end{function}

\begin{function}{setp}{object \key test key}[cl-ext]
  Returns true if OBJECT is a list that denotes a set, NIL otherwise. A list
denotes a set if each element of the list is unique under KEY and TEST.
\end{function}

\begin{function}{subsetp}{list1 list2 \key key test test-not}
  Return T if every element in LIST1 is also in LIST2.
\end{function}

\begin{function}{circular-list-p}{object}[cl-ext]
  Returns true if OBJECT is a circular list, NIL otherwise.
\end{function}

\begin{function}{circular-tree-p}{object}[cl-ext]
  Returns true if OBJECT is a circular tree, NIL otherwise.
\end{function}

\begin{function}{proper-list-p}{object}[cl-ext]
  Returns true if OBJECT is a proper list.
\end{function}

\section{conses}
\label{sec:conses}

\begin{function}{cons}{se1 se2}
  Return a list with SE1 as the CAR and SE2 as the CDR.
\end{function}

\begin{function}{ensure-cons}{cons}[cl-ext]
  If CONS is a cons, it is returned. Otherwise returns a fresh cons with CONS
  in the car, and NIL in the cdr.
\end{function}

\begin{accessor}{car}{list}
  Return the 1st object in a list.
\end{accessor}

\begin{function}{ensure-car}{thing}[cl-ext]
  If THING is a CONS, its CAR is returned. Otherwise THING is returned.
\end{function}

\begin{accessor}{cdr}{list}
  Return all but the first object in a list.
\end{accessor}

\begin{accessor}{caar}{list}
  Return the car of the 1st sublist.
\end{accessor}

\begin{accessor}{cadr}{list}
  Return the 2nd object in a list.
\end{accessor}

\begin{accessor}{cdar}{list}
  Return the cdr of the 1st sublist.
\end{accessor}

\begin{accessor}{cddr}{list}
  Return all but the 1st two objects of a list.
\end{accessor}

\begin{accessor}{caaar}{list}
  Return the 1st object in the caar of a list.
\end{accessor}

\begin{accessor}{caadr}{list}
  Return the 1st object in the cadr of a list.
\end{accessor}

\begin{accessor}{cadar}{list}
  Return the car of the cdar of a list.
\end{accessor}

\begin{accessor}{caddr}{list}
  Return the 1st object in the cddr of a list.
\end{accessor}

\begin{accessor}{cdaar}{list}
  Return the cdr of the caar of a list.
\end{accessor}

\begin{accessor}{cdadr}{list}
  Return the cdr of the cadr of a list.
\end{accessor}

\begin{accessor}{cddar}{list}
  Return the cdr of the cdar of a list.
\end{accessor}

\begin{accessor}{cdddr}{list}
  Return the cdr of the cddr of a list.
\end{accessor}

\begin{accessor}{caaaar}{list}
  Return the car of the caaar of a list.
\end{accessor}

\begin{accessor}{caaadr}{list}
  Return the car of the caadr of a list.
\end{accessor}

\begin{accessor}{caadar}{list}
  Return the car of the cadar of a list.
\end{accessor}

\begin{accessor}{caaddr}{list}
  Return the car of the caddr of a list.
\end{accessor}

\begin{accessor}{cadaar}{list}
  Return the car of the cdaar of a list.
\end{accessor}

\begin{accessor}{cadadr}{list}
  Return the car of the cdadr of a list.
\end{accessor}

\begin{accessor}{caddar}{list}
  Return the car of the cddar of a list.
\end{accessor}

\begin{accessor}{cadddr}{list}
  Return the car of the cdddr of a list.
\end{accessor}

\begin{accessor}{cdaaar}{list}
  Return the cdr of the caaar of a list.
\end{accessor}

\begin{accessor}{cdaadr}{list}
  Return the cdr of the caadr of a list.
\end{accessor}

\begin{accessor}{cdadar}{list}
  Return the cdr of the cadar of a list.
\end{accessor}

\begin{accessor}{cdaddr}{list}
  Return the cdr of the caddr of a list.
\end{accessor}

\begin{accessor}{cddaar}{list}
  Return the cdr of the cdaar of a list.
\end{accessor}

\begin{accessor}{cddadr}{list}
  Return the cdr of the cdadr of a list.
\end{accessor}

\begin{accessor}{cdddar}{list}
  Return the cdr of the cddar of a list.
\end{accessor}

\begin{accessor}{cddddr}{list}
  Return the cdr of the cdddr of a list.
\end{accessor}

\section{Lists}
\label{sec:lists}

\begin{function}{list}{\rest args}
  Return constructs and returns a list of its arguments.
\end{function}

\begin{function}{ensure-list}{thing}[cl-ext]
  Returns THING as a list.

If THING is already a list (as per listp) it is returned,
otherwise a one element list containing THING is returned.
\end{function}

\begin{function}{list*}{arg \rest others}
  Return a list of the arguments with last cons a dotted pair.
\end{function}

\begin{function}{make-list}{size \key initial-element}
  Constructs a list with size elements each set to value
\end{function}

\begin{function}{list-length}{list}
  Return the length of the given List, or Nil if the List is circular.
\end{function}

\begin{function}{length=1}{list}[cl-ext]
  Is x a list of length 1?
\end{function}

\begin{accessor}{nth}{n list}
  Return the nth object in a list where the car is the zero-th element.
\end{accessor}

\begin{accessor}{first}{list}
  Return the 1st object in a list or NIL if the list is empty.
\end{accessor}

\begin{accessor}{second}{list}
  Return the 2nd object in a list or NIL if there is no 2nd object.
\end{accessor}

\begin{accessor}{third}{list}
  Return the 3rd object in a list or NIL if there is no 3rd object.
\end{accessor}

\begin{accessor}{fourth}{list}
  Return the 4th object in a list or NIL if there is no 4th object.
\end{accessor}

\begin{accessor}{fifth}{list}
  Return the 5th object in a list or NIL if there is no 5th object.
\end{accessor}

\begin{accessor}{sixth}{list}
  Return the 6th object in a list or NIL if there is no 6th object.
\end{accessor}

\begin{accessor}{seventh}{list}
  Return the 7th object in a list or NIL if there is no 7th object.
\end{accessor}

\begin{accessor}{eighth}{list}
  Return the 8th object in a list or NIL if there is no 8th object.
\end{accessor}

\begin{accessor}{ninth}{list}
  Return the 9th object in a list or NIL if there is no 9th object.
\end{accessor}

\begin{accessor}{tenth}{list}
  Return the 10th object in a list or NIL if there is no 10th object.
\end{accessor}

\begin{accessor}{rest}{list}
  Means the same as the cdr of a list.
\end{accessor}

\begin{function}{nthcdr}{n list}
  Performs the cdr function n times on a list.
\end{function}

\begin{function}{last}{list \op n}
  Return the last N conses (not the last element!) of a list.
\end{function}

\begin{function}{lastcar}{list}[cl-ext]
  Returns the last element of LIST. Signals a type-error if LIST is not a
proper list.
\end{function}

\begin{function}{butlast}{list \op n}
  
\end{function}

\begin{function}{nbutlast}{list \op n}
  
\end{function}

\begin{function}{append}{\rest lists}
  Construct a new list by concatenating the list arguments
\end{function}

\begin{macro}{appendf}{place \rest lists \env env}[cl-ext]
  Modify-macro for APPEND. Appends LISTS to the place designated by the first
argument.
\end{macro}

\begin{function}{append1}{\rest itens}[cl-ext]
  Append itens in the same list regardless if itens are lists or
  symbols.
\end{function}

\begin{function}{copy-list}{list}
  Return a new list which is EQUAL to LIST. LIST may be improper.
\end{function}

\begin{function}{revappend}{x y}
  Return (append (reverse x) y).
\end{function}

\begin{function}{nconc}{\rest lists}
  Concatenates the lists given as arguments (by changing them)
\end{function}

\begin{macro}{nconcf}{place \rest lists \env env}[cl-ext]
  Modify-macro for NCONC. Concatenates LISTS to place designated by the first
argument.
\end{macro}

\begin{function}{nreconc}{x y}
  Return (NCONC (NREVERSE X) Y).
\end{function}

\begin{macro}{push}{obj place \env env}
  Takes an object and a location holding a list. Conses the object onto
  the list, returning the modified list. OBJ is evaluated before PLACE.
\end{macro}

\begin{macro}{pushnew}{obj place \rest keys \key key test test-not \env env}
  Takes an object and a location holding a list. If the object is
  already in the list, does nothing; otherwise, conses the object onto
  the list. Returns the modified list. If there is a :TEST keyword, this
  is used for the comparison.
\end{macro}

\begin{macro}{push*}{place \rest items \env env}[cl-ext]
  Pushes every element of ITEMS onto LIST. Equivalent to calling PUSH
  with each element of ITEMS.
\end{macro}

\begin{macro}{pop}{place \env env}
  The argument is a location holding a list. Pops one item off the front
  of the list and returns it.
\end{macro}

\begin{function}{ldiff}{list object}
  Return a new list, whose elements are those of LIST that appear before
   OBJECT. If OBJECT is not a tail of LIST, a copy of LIST is returned.
   LIST must be a proper list or a dotted list.
\end{function}

\begin{function}{partition}{list \rest lambdas}[cl-ext]
  Split LIST into sub lists according to LAMBDAS. Each element of LIST
  will be passed to each element of LAMBDAS, the first function in
  LAMBDAS which returns T will cause that element to be collected into
  the corresponding list.
\end{function}

\section{Alteration of lists}
\label{sec:alteration-lists}

It's usually considered better style to modify a list with
\macr{setf} (for example \code{(setf (car list) 'foo)}) instead of
using the following functions.

\begin{function}{rplaca}{cons x}
  Change the CAR of CONS to X and return the CONS.
\end{function}

\begin{function}{rplacd}{cons x}
  Change the CDR of CONS to X and return the CONS.
\end{function}

\section{Substitution of expressions}
\label{sec:subst-expr}

\begin{function}{subst}{new old tree \key key test test-not}
  Substitutes new for subtrees matching old.
\end{function}

\begin{function}{subst-if}{new test tree \key key}
  Substitutes new for subtrees for which test is true.
\end{function}

\begin{function}{subst-if-not}{new test tree \key key}
  Substitutes new for subtrees for which test is false.
\end{function}

\begin{function}{nsubst}{new old tree \key key test test-not}
  Substitute NEW for subtrees matching OLD.
\end{function}

\begin{function}{nsubst-if}{new test tree \key key}
  Substitute NEW for subtrees of TREE for which TEST is true.
\end{function}

\begin{function}{nsubst-if-not}{new test tree \key key}
  Substitute NEW for subtrees of TREE for which TEST is false.
\end{function}

\begin{function}{sublis}{alist tree \key key test test-not}
  Substitute from ALIST into TREE nondestructively.
\end{function}

\begin{function}{nsublis}{alist tree \key key test test-not}
  Substitute from ALIST into TRUE destructively.
\end{function}

\section{Sets}
\label{sec:sets}

See also \funr{subsetp} and \funr{tailp}.

\begin{function}{set-equal}{list1 list2 \key test key}[cl-ext]
  Returns true if every element of LIST1 matches some element of LIST2 and
every element of LIST2 matches some element of LIST1. Otherwise returns false.
\end{function}

\begin{function}{member}{item list \key key test test-not}
  Return the tail of LIST beginning with first element satisfying EQLity,
   :TEST, or :TEST-NOT with the given ITEM.
\end{function}

\begin{function}{member-if}{test list \key key}
  Return tail of LIST beginning with first element satisfying TEST.
\end{function}

\begin{function}{member-if-not}{test list \key key}
  Return tail of LIST beginning with first element not satisfying TEST.
\end{function}

\begin{function}{member-equal}{item list}[cl-ext]
  
\end{function}

\begin{function}{adjoin}{item list \key key test test-not}
  Add ITEM to LIST unless it is already a member
\end{function}

\begin{function}{union}{list1 list2 \key key test test-not}
  Return the union of LIST1 and LIST2.
\end{function}

\begin{function}{nunion}{list1 list2 \key key test test-not}
  Destructively return the union of LIST1 and LIST2.
\end{function}

\begin{macro}{unionf}{place list \env env}[cl-ext]
  Modify-macro for UNION. Saves the union of LIST and the contents of the
place designated by the first argument to the designated place.
\end{macro}

\begin{macro}{nunionf}{place list \env env}[cl-ext]
  Modify-macro for NUNION. Saves the union of LIST and the contents of the
place designated by the first argument to the designated place. May modify
either argument.
\end{macro}

\begin{function}{intersection}{list1 list2 \key key test test-not}
  Return the intersection of LIST1 and LIST2.
\end{function}

\begin{function}{nintersection}{list1 list2 \key key test test-not}
  Destructively return the intersection of LIST1 and LIST2.
\end{function}

\begin{function}{set-difference}{list1 list2 \key key test test-not}
  Return the elements of LIST1 which are not in LIST2.
\end{function}

\begin{function}{nset-difference}{list1 list2 \key key test test-not}
  Destructively return the elements of LIST1 which are not in LIST2.
\end{function}

\begin{function}{set-exclusive-or}{list1 list2 \key key test test-not}
  Return new list of elements appearing exactly once in LIST1 and LIST2.
\end{function}

\begin{function}{nset-exclusive-or}{list1 list2 \key key test test-not}
  Destructively return a list with elements which appear but once in LIST1
   and LIST2.
\end{function}

\section{Circular lists}
\label{sec:circular-lists}

\begin{function}{circular-list}{\rest elements}[cl-ext]
  Creates a circular list of ELEMENTS.
\end{function}

\begin{function}{make-circular-list}{length \key initial-element}[cl-ext]
  Creates a circular list of LENGTH with the given INITIAL-ELEMENT.
\end{function}

\section{Trees}
\label{sec:trees}

\begin{function}{tree-equal}{x y \key test test-not}
  Return T if X and Y are isomorphic trees with identical leaves.
\end{function}

\begin{function}{copy-tree}{object}
  Recursively copy trees of conses.
\end{function}

\begin{macro}{dotree}{name \body body}[cl-ext]
  Evaluate BODY with NAME bound to every element in TREE. Return RET-VAL.
\end{macro}

\begin{function}{flatten}{tree}[cl-ext]
  Traverses the tree in order, collecting non-null leaves into a list.
\end{function}

%% TODO: needs better implementation
\begin{function}{unflatten}{list n}[cl-ext]
  Split a list by size n.
\end{function}

\begin{function}{transpose-list}{list}[cl-ext]
  Transpose a matrix represented as a list.
\end{function}

\section{Association and property lists}
\label{sec:association-lists}

\begin{function}{copy-alist}{alist}
  Return a new association list which is EQUAL to ALIST.
\end{function}

\begin{function}{acons}{key datum alist}
  Construct a new alist by adding the pair (KEY . DATUM) to ALIST.
\end{function}

\begin{function}{pairlis}{keys data \op alist}
  Construct an association list from KEYS and DATA (adding to ALIST).
\end{function}

\begin{function}{assoc}{item alist \key key test test-not}
  Return the cons in ALIST whose car is equal (by a given test or EQL) to
   the ITEM.
\end{function}

\begin{function}{assoc-if}{predicate alist \key key}
  Return the first cons in ALIST whose CAR satisfies PREDICATE. If
   KEY is supplied, apply it to the CAR of each cons before testing.
\end{function}

\begin{function}{assoc-if-not}{predicate alist \key key}
  Return the first cons in ALIST whose CAR does not satisfy PREDICATE.
  If KEY is supplied, apply it to the CAR of each cons before testing.
\end{function}

\begin{function}{rassoc}{item alist \key key test test-not}
  Return the cons in ALIST whose CDR is equal (by a given test or EQL) to
   the ITEM.
\end{function}

\begin{function}{rassoc-if}{predicate alist \key key}
  Return the first cons in ALIST whose CDR satisfies PREDICATE. If KEY
  is supplied, apply it to the CDR of each cons before testing.
\end{function}

\begin{function}{rassoc-if-not}{predicate alist \key key}
  Return the first cons in ALIST whose CDR does not satisfy PREDICATE.
  If KEY is supplied, apply it to the CDR of each cons before testing.
\end{function}

\begin{accessor}{get}{symbol indicator \op default}
  Look on the property list of SYMBOL for the specified INDICATOR. If this
  is found, return the associated value, else return DEFAULT.
\end{accessor}

\begin{function}{remprop}{symbol indicator}
  Look on property list of SYMBOL for property with specified
  INDICATOR. If found, splice this indicator and its value out of
  the plist, and return the tail of the original list starting with
  INDICATOR. If not found, return () with no side effects.

  NOTE: The ANSI specification requires REMPROP to return true (not false)
  or false (the symbol NIL). Portable code should not rely on any other value.
\end{function}

\begin{accessor}{symbol-plist}{symbol}
  Return SYMBOL's property list.
\end{accessor}

\begin{accessor}{getf}{place indicator \op default}
  Search the property list stored in Place for an indicator EQ to INDICATOR.
  If one is found, return the corresponding value, else return DEFAULT.
\end{accessor}

\begin{function}{get-properties}{place indicator-list}
  Like GETF, except that INDICATOR-LIST is a list of indicators which will
  be looked for in the property list stored in PLACE. Three values are
  returned, see manual for details.
\end{function}

\begin{macro}{remf}{place indicator \env env}
  Place may be any place expression acceptable to SETF, and is expected
  to hold a property list or (). This list is destructively altered to
  remove the property specified by the indicator. Returns T if such a
  property was present, NIL if not.
\end{macro}

\begin{macro}{doplist}{key \body body}[cl-ext]
  Iterates over elements of PLIST. BODY can be preceded by
declarations, and is like a TAGBODY. RETURN may be used to terminate
the iteration early. If RETURN is not used, returns VALUES.
\end{macro}

\begin{function}{remove-from-plist}{plist \rest keys}[cl-ext]
  Returns a propery-list with same keys and values as PLIST, except that keys
in the list designated by KEYS and values corresponding to them are removed.
The returned property-list may share structure with the PLIST, but PLIST is
not destructively modified. Keys are compared using EQ.
\end{function}

\begin{macro}{remove-from-plistf}{place \rest keys \env env}[cl-ext]
  
\end{macro}

\begin{function}{delete-from-plist}{plist \rest keys}[cl-ext]
  Just like REMOVE-FROM-PLIST, but this version may destructively modify the
provided plist.
\end{function}

\begin{macro}{delete-from-plistf}{place \rest keys \env env}[cl-ext]
  
\end{macro}

\begin{macro}{remf-keywords}{place \rest keywords \env env}[cl-ext]
  Creates a copy of PLIST without the properties identified by KEYWORDS.
\end{macro}

\begin{function}{remove-keywords}{plist \rest keywords}[cl-ext]
  Creates a copy of PLIST without the listed KEYWORDS.
\end{function}

\begin{function}{plist-to-alist}{plist}[cl-ext]
  Returns an association list containing the same keys and values as the
property list PLIST in the same order.
\end{function}

\begin{function}{alist-to-plist}{alist}[cl-ext]
  Returns a property list containing the same keys and values as the
association list ALIST in the same order.
\end{function}

\begin{function}{list-to-alist}{list}[cl-ext]
  Convert a flat list into an alist.
\end{function}

\section{Mapping}
\label{sec:mapping}

Some mapping functions work only with lists, for more general mapping
functions see the chapter on sequences (chapter \ref{cha:sequences}) and
iteration (chapter \ref{cha:iteration}).

\begin{function}{mapc}{function list \rest more-lists}
  Apply FUNCTION to successive elements of lists. Return the second argument.
\end{function}

\begin{function}{mapcan}{function list \rest more-lists}
  Apply FUNCTION to successive elements of LIST. Return NCONC of FUNCTION
   results.
\end{function}

\begin{function}{mapcar}{function list \rest more-lists}
  Apply FUNCTION to successive elements of LIST. Return list of FUNCTION
   return values.
\end{function}

\begin{function}{mapcon}{function list \rest more-lists}
  Apply FUNCTION to successive CDRs of lists. Return NCONC of results.
\end{function}

\begin{function}{mapl}{function list \rest more-lists}
  Apply FUNCTION to successive CDRs of list. Return NIL.
\end{function}

\begin{function}{maplist}{function list \rest more-lists}
  Apply FUNCTION to successive CDRs of list. Return list of results.
\end{function}

\begin{function}{mappend}{function \rest lists}[cl-ext]
  Applies FUNCTION to respective element(s) of each LIST, appending all the
all the result list to a single list. FUNCTION must return a list.
\end{function}

\section{List of numbers}
\label{sec:list-numbers}

\begin{function}{range}{[start] end [step]}
  Return a list of numbers from \var{start} to \var{end}, inclusive,
  by \var{step}. With only one argument it will return a list of
  numbers from 0 to \var{end}. Numeric contagion from \var{step} and
  \var{start} is applied to the other numbers.
\begin{devnote}
  The function RANGE here is similar to python's range in the way it
  handle arguments and to bash's seq.
\end{devnote}
\end{function}

\begin{function}{map-range}{function start end \op step}[cl-ext]
  Return a list with numbers from \var{min} to \var{max} by \var{step}
  and apply \var{function} to each element of the list.
\end{function}

\begin{macro}{do-range}{(index \op min max step return value) \body body}[cl-ext]
  
\end{macro}

\begin{function}{iota}{n \key start step}[cl-ext]
  Return a list of n numbers, starting from START (with numeric
  contagion from STEP applied), each consequtive number being the sum
  of the previous one and STEP. START defaults to 0 and STEP to 1.
\end{function}

\begin{function}{map-iota}{function n \key start step}[cl-ext]
  Calls FUNCTION with N numbers, starting from START (with numeric contagion
from STEP applied), each consequtive number being the sum of the previous one
and STEP. START defaults to 0 and STEP to 1. Returns N.
\end{function}

\begin{function}{map-product}{function list \rest more-lists}[cl-ext]
  Returns a list containing the results of calling FUNCTION with one argument
from LIST, and one from each of MORE-LISTS for each combination of arguments.
In other words, returns the product of LIST and MORE-LISTS using FUNCTION.
\end{function}

\chapter{Sequences}
\label{cha:sequences}

\begin{type}{proper-sequence}{}[cl-ext]
  
\end{type}

\section{Predicates}
\label{sec:sequence-predicates}

\begin{function}{emptyp}{sequence}[cl-ext]
  Returns true if SEQUENCE is an empty sequence. Signals an error if
  SEQUENCE is not a sequence
\end{function}

\begin{function}{every}{pred first-seq \rest more-seqs}
  Apply PREDICATE to the 0-indexed elements of the sequences, then
  possibly to those with index 1, and so on. Return NIL as soon
  as any invocation of PREDICATE returns NIL, or T if every invocation
  is non-NIL.
\end{function}

\begin{function}{some}{pred first-seq \rest more-seqs}
  Apply PREDICATE to the 0-indexed elements of the sequences, then
  possibly to those with index 1, and so on. Return the first
  non-NIL value encountered, or NIL if the end of any sequence is reached.
\end{function}

\begin{function}{notany}{pred first-seq \rest more-seqs}
  Apply PREDICATE to the 0-indexed elements of the sequences, then
  possibly to those with index 1, and so on. Return NIL as soon
  as any invocation of PREDICATE returns a non-NIL value, or T if the end
  of any sequence is reached.
\end{function}

\begin{function}{notevery}{pred first-seq \rest more-seqs}
  Apply PREDICATE to 0-indexed elements of the sequences, then
  possibly to those with index 1, and so on. Return T as soon
  as any invocation of PREDICATE returns NIL, or NIL if every invocation
  is non-NIL.
\end{function}

\begin{function}{mismatch}{sequence1 sequence2 \rest args \key from-end test test-not start1 end1 start2
    end2 key}
  The specified subsequences of SEQUENCE1 and SEQUENCE2 are compared
  element-wise. If they are of equal length and match in every element, the
  result is NIL. Otherwise, the result is a non-negative integer, the index
  within SEQUENCE1 of the leftmost position at which they fail to match; or,
  if one is shorter than and a matching prefix of the other, the index within
  SEQUENCE1 beyond the last position tested is returned. If a non-NIL
  :FROM-END argument is given, then one plus the index of the rightmost
  position in which the sequences differ is returned.
\end{function}

\section{Simple sequence functions}
\label{sec:simple-sequ-funct}

\begin{accessor}{elt}{sequence index}
  Return the element of SEQUENCE specified by INDEX.
\end{accessor}

\begin{function}{first-elt}{sequence}[cl-ext]
  Returns the first element of SEQUENCE. Signals a type-error if SEQUENCE is
  not a sequence, or is an empty sequence.
\end{function}

\begin{function}{last-elt}{sequence}[cl-ext]
  Returns the last element of SEQUENCE. Signals a type-error if SEQUENCE is
  not a proper sequence, or is an empty sequence.
\end{function}

\begin{function}{random-elt}{sequence \key start end}[cl-ext]
  Returns a random element from SEQUENCE bounded by START and END.
  Signals an error if the SEQUENCE is not a proper sequence.
\end{function}

\begin{accessor}{subseq}{sequence start \op end}
  Return a copy of a subsequence of SEQUENCE starting with element number
  START and continuing to the end of SEQUENCE or the optional END.
\end{accessor}

\begin{function}{copy-seq}{sequence}
  Return a copy of SEQUENCE which is EQUAL to SEQUENCE but not EQ.
\end{function}

\begin{function}{copy-sequence}{type sequence}[cl-ext]
  Returns a fresh sequence of TYPE, which has the same elements as
  SEQUENCE.
\end{function}

\begin{function}{length}{sequence}
  Return an integer that is the length of SEQUENCE.
\end{function}

\begin{function}{length=}{\rest sequences}[cl-ext]
  Takes any number of sequences or integers in any order. Returns true
  iff the length of all the sequences and the integers are equal.
  Hint: there's a compiler macro that expands into more efficient code
  if the first argument is a literal integer.
\end{function}

\begin{function}{tail}{seq \op how-many}[cl-ext]
  Returns the last HOW-MANY elements of the sequence SEQ. HOW-MANY is
  greater than (length SEQ) then all of SEQ is returned.
\end{function}

\begin{function}{head}{seq \op how-many}[cl-ext]
  Returns the first HOW-MANY elements of SEQ.
\end{function}

\begin{function}{but-head}{seq \op how-many}[cl-ext]
  Returns SEQ with the first HOW-MANY elements removed.
\end{function}

\begin{function}{but-tail}{seq \op how-many}[cl-ext]
  Returns SEQ with the last HOW-MANY elements removed.
\end{function}

\begin{function}{sequence-of-length-p}{sequence length}[cl-ext]
  Return true if SEQUENCE is a sequence of length LENGTH. Signals an error if
  SEQUENCE is not a sequence. Returns FALSE for circular lists.
\end{function}

\begin{function}{reverse}{sequence}
  Return a new sequence containing the same elements but in reverse order.
\end{function}

\begin{function}{nreverse}{sequence}
  Return a sequence of the same elements in reverse order; the argument
  is destroyed.
\end{function}

\begin{function}{make-sequence}{type length \key initial-element}
  Return a sequence of the given TYPE and LENGTH, with elements initialized
  to INITIAL-ELEMENT.
\end{function}

\begin{function}{starts-with}{object sequence \key test key}[cl-ext]
  Returns true if SEQUENCE is a sequence whose first element is EQL to OBJECT.
  Returns NIL if the SEQUENCE is not a sequence or is an empty sequence.
\end{function}

\begin{function}{starts-with-subseq}{prefix sequence \rest args \key return-suffix \akeys}[cl-ext]
  Test whether the first elements of SEQUENCE are the same (as per TEST) as the elements of PREFIX.

  If RETURN-SUFFIX is T the functions returns, as a second value, a
  displaced array pointing to the sequence after PREFIX.
\end{function}

\begin{function}{ends-with}{object sequence \key test key}[cl-ext]
  Returns true if SEQUENCE is a sequence whose last element is EQL to OBJECT.
  Returns NIL if the SEQUENCE is not a sequence or is an empty sequence. Signals
  an error if SEQUENCE is an improper list.
\end{function}

\begin{function}{ends-with-subseq}{suffix sequence \key test}[cl-ext]
  Test whether SEQUENCE ends with SUFFIX. In other words: return true if
  the last (length SUFFIX) elements of SEQUENCE are equal to SUFFIX.
\end{function}

\begin{function}{read-sequence}{seq stream \key start end}
  Destructively modify SEQ by reading elements from STREAM.
  That part of SEQ bounded by START and END is destructively modified by
  copying successive elements into it from STREAM. If the end of file
  for STREAM is reached before copying all elements of the subsequence,
  then the extra elements near the end of sequence are not updated, and
  the index of the next element is returned.
\end{function}

\begin{function}{read-sequence*}{sequence stream \key start end}[cl-ext]
  Like READ-SEQUENCE except the sequence is returned as well.

  The second value returned is READ-SEQUENCE's primary value, the
  primary value returned by READ-SEQUENCE* is the medified
  sequence.
\end{function}

\begin{function}{levenshtein-distance}{source target \key test}[cl-ext]
  Levenshtein distance is a metric for measuring the amount of
  difference between two sequences.
\end{function}

\section{Concatenating, Mapping, and Reducing Sequences}
\label{sec:conc-mapp-reduc}

\begin{function}{concatenate}{output-type-spec \rest sequences}
  Return a new sequence of all the argument sequences concatenated together
  which shares no structure with the original argument sequences of the
  specified OUTPUT-TYPE-SPEC.
\end{function}

\begin{function}{map}{result-type function first-sequence \rest more-sequences}
  
\end{function}

\begin{function}{map-into}{result-sequence function \rest sequences}
  
\end{function}

\begin{function}{reduce}{function sequence \rest args \key key from-end start end initial-value}
  
\end{function}

\begin{function}{map-combinations}{function sequence \key start end length copy}[cl-ext]
  Calls FUNCTION with each combination of LENGTH constructable from the
  elements of the subsequence of SEQUENCE delimited by START and END. START
  defaults to 0, END to length of SEQUENCE, and LENGTH to the length of the
  delimited subsequence. (So unless LENGTH is specified there is only a single
  combination, which has the same elements as the delimited subsequence.) If
  COPY is true (the default) each combination is freshly allocated. If COPY is
  false all combinations are EQ to each other, in which case consequences are
  specified if a combination is modified by FUNCTION.
\end{function}

\begin{function}{map-derangements}{function sequence \key start end copy}[cl-ext]
  Calls FUNCTION with each derangement of the subsequence of SEQUENCE denoted
  by the bounding index designators START and END. Derangement is a permutation
  of the sequence where no element remains in place. SEQUENCE is not modified,
  but individual derangements are EQ to each other. Consequences are unspecified
  if calling FUNCTION modifies either the derangement or SEQUENCE.
\end{function}

\begin{function}{map-permutations}{function sequence \key start end length copy}[cl-ext]
  Calls function with each permutation of LENGTH constructable
  from the subsequence of SEQUENCE delimited by START and END. START
  defaults to 0, END to length of the sequence, and LENGTH to the
  length of the delimited subsequence.
\end{function}

\section{Filtering and modifying sequences}
\label{sec:filt-modify-sequ}

\begin{function}{fill}{sequence item \key start end}
  Replace the specified elements of SEQUENCE with ITEM.
\end{function}

\begin{function}{replace}{sequence1 sequence2 \rest args \key start1 end1 start2 end2}
  The target sequence is destructively modified by copying successive
  elements into it from the source sequence.
\end{function}

\begin{function}{remove}{item sequence \rest args \key from-end test test-not start end count key}
  Return a copy of SEQUENCE with elements satisfying the test (default is
  EQL) with ITEM removed.
\end{function}

\begin{function}{remove-if}{predicate sequence \rest args \key from-end start end count key}
  Return a copy of sequence with elements satisfying PREDICATE removed.
\end{function}

\begin{function}{remove-if-not}{predicate sequence \rest args \key from-end start end count key}
  Return a copy of sequence with elements not satisfying PREDICATE removed.
\end{function}

\begin{macro}{removef}{place item \rest remove-keywords \env env}[cl-ext]
  Modify-macro for REMOVE. Sets place designated by the first argument
  to the result of calling REMOVE with ITEM, place, and the
  REMOVE-KEYWORDS.
\end{macro}

\begin{function}{delete}{item sequence \rest args \key from-end test test-not start end count key}
  Return a sequence formed by destructively removing the specified ITEM from
  the given SEQUENCE.
\end{function}

\begin{function}{delete-if}{predicate sequence \rest args \key from-end start key end count}
  Return a sequence formed by destructively removing the elements satisfying
  the specified PREDICATE from the given SEQUENCE.
\end{function}

\begin{function}{delete-if-not}{predicate sequence \rest args \key from-end start end key count}
  Return a sequence formed by destructively removing the elements not
  satisfying the specified PREDICATE from the given SEQUENCE.
\end{function}

\begin{macro}{deletef}{place item \rest remove-keywords \env env}[cl-ext]
  Modify-macro for DELETE. Sets place designated by the first argument
  to the result of calling DELETE with ITEM, place, and the
  REMOVE-KEYWORDS.
\end{macro}

\begin{function}{remove-duplicates}{sequence \rest args \key test test-not start end from-end key}
  The elements of SEQUENCE are compared pairwise, and if any two match,
  the one occurring earlier is discarded, unless FROM-END is true, in
  which case the one later in the sequence is discarded. The resulting
  sequence is returned.

  The :TEST-NOT argument is deprecated.
\end{function}

\begin{function}{delete-duplicates}{sequence \rest args \key test test-not start end from-end key}
  The elements of SEQUENCE are examined, and if any two match, one is
  discarded. The resulting sequence, which may be formed by destroying the
  given sequence, is returned.

  The :TEST-NOT argument is deprecated.
\end{function}

\begin{function}{substitute}{new old sequence \rest args \key from-end test test-not start count end key}
  Return a sequence of the same kind as SEQUENCE with the same elements,
  except that all elements equal to OLD are replaced with NEW.
\end{function}

\begin{function}{substitute-if}{new predicate sequence \rest args \key from-end start end count key}
  Return a sequence of the same kind as SEQUENCE with the same elements
  except that all elements satisfying the PRED are replaced with NEW.
\end{function}

\begin{function}{substitute-if-not}{new predicate sequence \rest args \key from-end start end count key}
  Return a sequence of the same kind as SEQUENCE with the same elements
  except that all elements not satisfying the PRED are replaced with NEW.
\end{function}

\begin{function}{nsubstitute}{new old sequence \rest args \key from-end test test-not end count key start}
  Return a sequence of the same kind as SEQUENCE with the same elements
  except that all elements equal to OLD are replaced with NEW. SEQUENCE
  may be destructively modified.
\end{function}

\begin{function}{nsubstitute-if}{new predicate sequence \rest args \key from-end start end count key}
  Return a sequence of the same kind as SEQUENCE with the same elements
  except that all elements satisfying PREDICATE are replaced with NEW.
  SEQUENCE may be destructively modified.
\end{function}

\begin{function}{nsubstitute-if-not}{new predicate sequence \rest args \key from-end start end count key}
  Return a sequence of the same kind as SEQUENCE with the same elements
  except that all elements not satisfying PREDICATE are replaced with NEW.
  SEQUENCE may be destructively modified.
\end{function}

\begin{function}{rotate}{sequence \op n}[cl-ext]
  Returns a sequence of the same type as SEQUENCE, with the elements
  of SEQUENCE rotated by N: N elements are moved from the end of the
  sequence to the front if N is positive, and -N elements moved from
  the front to the end if N is negative. SEQUENCE must be a proper
  sequence. N must be an integer, defaulting to 1. If absolute value
  of N is greater then the length of the sequence, the results are
  identical to calling ROTATE with (* (SIGNUM N) (MOD N (LENGTH
  SEQUENCE))). The original sequence may be destructively altered, and
  result sequence may share structure with it.
\end{function}

\begin{function}{shuffle}{sequence \key start end}[cl-ext]
  Returns a random permutation of SEQUENCE bounded by START and END.
  Permuted sequence may share storage with the original one. Signals
  an error if SEQUENCE is not a proper sequence.
\end{function}

\section{Searching sequences}
\label{sec:searching-sequences}

\begin{function}{search}{sequence1 sequence2 \rest args \key from-end test test-not start1 end1 start2
    end2 key}
  
\end{function}

\begin{function}{find}{item sequence \rest args \key from-end start end key test test-not}
  
\end{function}

\begin{function}{find-if}{predicate sequence \rest args \key from-end start end key}
  
\end{function}

\begin{function}{find-if-not}{predicate sequence \rest args \key from-end start end key}
  
\end{function}

\begin{function}{find-anywhere}{item tree}[cl-ext]
  Does item occur anywhere in tree?
\end{function}

\begin{function}{find-all}{item sequence \rest keyword-args \key test test-not \akeys}[cl-ext]
  Find all those elements of sequence that match item, according to
  the keywords. Doesn't alter sequence.
\end{function}

\begin{function}{position}{item sequence \rest args \key from-end start end key test test-not}
  
\end{function}

\begin{function}{position-if}{predicate sequence \rest args \key from-end start end key}
  
\end{function}

\begin{function}{position-if-not}{predicate sequence \rest args \key from-end start end key}
  
\end{function}

\begin{function}{count}{item sequence \rest args \key from-end start end key test test-not}
  Return the number of elements in SEQUENCE satisfying a test with ITEM,
  which defaults to EQL.
\end{function}

\begin{function}{count-if}{pred sequence \rest args \key from-end start end key}
  Return the number of elements in SEQUENCE satisfying PRED(el).
\end{function}

\begin{function}{count-if-not}{pred sequence \rest args \key from-end start end key}
  Return the number of elements in SEQUENCE not satisfying TEST(el).
\end{function}

\section{Sorting and Merging}
\label{sec:sorting-merging}

\begin{function}{sort}{sequence predicate \rest args \key key}
  Destructively sort SEQUENCE. PREDICATE should return non-NIL if
  ARG1 is to precede ARG2.
\end{function}

\begin{function}{sort*}{sequence predicate \key key}[cl-ext]
  Sort without altering the sequence.
\end{function}

\begin{function}{stable-sort}{sequence predicate \rest args \key key}
  Destructively sort SEQUENCE. PREDICATE should return non-NIL if
  ARG1 is to precede ARG2.
\end{function}

\begin{function}{merge}{result-type sequence1 sequence2 predicate \key key}
  Merge the sequences SEQUENCE1 and SEQUENCE2 destructively into a
  sequence of type RESULT-TYPE using PREDICATE to order the elements.
\end{function}

\section{Splitting sequences}
\label{sec:splitting-sequences}

\begin{function}{split-sequence}{delimiter seq \key count
    remove-empty-subseqs from-end start end test test-not key}
  Return a list of subsequences in seq delimited by delimiter.

  If :remove-empty-subseqs is NIL, empty subsequences will be included
  in the result; otherwise they will be discarded.  All other keywords
  work analogously to those for CL:SUBSTITUTE.  In particular, the
  behaviour of :from-end is possibly different from other versions of
  this function; :from-end values of NIL and T are equivalent unless
  :count is supplied. The second return value is an index suitable as an
  argument to CL:SUBSEQ into the sequence indicating where processing
  stopped.
\end{function}

\begin{function}{split-sequence-if}{predicate seq \key count
    remove-empty-subseqs from-end start end key}
  Return a list of subsequences in seq delimited by items satisfying
  predicate.

  If :remove-empty-subseqs is NIL, empty subsequences will be included
  in the result; otherwise they will be discarded.  All other keywords
  work analogously to those for CL:SUBSTITUTE-IF.  In particular, the
  behaviour of :from-end is possibly different from other versions of
  this function; :from-end values of NIL and T are equivalent unless
  :count is supplied. The second return value is an index suitable as an
  argument to CL:SUBSEQ into the sequence indicating where processing
  stopped.  
\end{function}

\begin{function}{split-sequence-if-not}{predicate seq \key count
    remove-empty-subseqs from-end start end key}
  Return a list of subsequences in seq delimited by items satisfying
  (CL:COMPLEMENT predicate).

  If :remove-empty-subseqs is NIL, empty subsequences will be included
  in the result; otherwise they will be discarded. All other keywords
  work analogously to those for CL:SUBSTITUTE-IF-NOT. In particular,
  the behaviour of :from-end is possibly different from other versions
  of this function; :from-end values of NIL and T are equivalent
  unless :count is supplied. The second return value is an index
  suitable as an argument to CL:SUBSEQ into the sequence indicating
  where processing stopped.
\end{function}


\chapter{Hash Tables}

\section{Predicate}
\label{sec:hashtable-predicate}

\begin{function}{hash-table-p}{object}
  
\end{function}

\section{Hash table creation}
\label{sec:hash-table-creation}

\begin{function}{make-hash-table}{\key test size rehash-size rehash-threshold weakness synchronized}
  Create and return a new hash table. The keywords are as follows:
  \begin{description}
  \item [:TEST] Indicates what kind of test to use.
  \item [:SIZE] A hint as to how many elements will be put in this hash
    table.
  \item [:REHASH-SIZE] Indicates how to expand the table when it
    fills up. If an integer, add space for that many elements. If a
    floating point number (which must be greater than 1.0),
    multiply the size by that amount.
  \item [:REHASH-THRESHOLD] Indicates how dense the table can become before
    forcing a rehash. Can be any positive number <=1, with density
    approaching zero as the threshold approaches 0. Density 1 means an
    average of one entry per bucket.
  \item [:WEAKNESS] If NIL (the default) it is a normal non-weak hash table.
    If one of :KEY, :VALUE, :KEY-AND-VALUE, :KEY-OR-VALUE it is a weak
    hash table.
    Depending on the type of weakness the lack of references to the
    key and the value may allow for removal of the entry. If WEAKNESS
    is :KEY and the key would otherwise be garbage the entry is eligible
    for removal from the hash table. Similarly, if WEAKNESS is :VALUE
    the life of an entry depends on its value's references. If WEAKNESS
    is :KEY-AND-VALUE and either the key or the value would otherwise be
    garbage the entry can be removed. If WEAKNESS is :KEY-OR-VALUE and
    both the key and the value would otherwise be garbage the entry can
    be removed.
  \item [:SYNCHRONIZED] If NIL (the default), the hash-table may
    have multiple concurrent readers, but results are undefined if
    a thread writes to the hash-table concurrently with another
    reader or writer. If T, all concurrent accesses are safe, but
    note that CLHS 3.6 (Traversal Rules and Side Effects) remains
    in force. See also: SB-EXT:WITH-LOCKED-HASH-TABLE. This keyword
    argument is experimental, and may change incompatibly or be
    removed in the future.
  \end{description}
\end{function}

\begin{function}{build-hash-table}{hash-spec inital-contents}[cl-ext]
  Create a hash table containing ``INITAL-CONTENTS''.
\end{function}

\begin{macro}{deflookup-table}{name \key var reader writer rem-er at-redefinition documentation test initial-contents}[cl-ext]
  Creates a hash table and the associated accessors.
\end{macro}

\begin{function}{copy-hash-table}{table \key key test size rehash-size rehash-threshold}[cl-ext]
  Returns a copy of hash table TABLE, with the same keys and values
as the TABLE. The copy has the same properties as the original, unless
overridden by the keyword arguments.

Before each of the original values is set into the new hash-table, KEY
is invoked on the value. As KEY defaults to CL:IDENTITY, a shallow
copy is returned by default.
\end{function}

\section{Hash table access and modification}
\label{sec:hash-table-access}

\begin{accessor}{gethash}{key hash-table \op default}
  Finds the entry in HASH-TABLE whose key is KEY and returns the
associated value and T as multiple values, or returns DEFAULT and NIL
if there is no such entry. Entries can be added using SETF.
\end{accessor}

\begin{function}{ensure-gethash}{key hash-table \op default}[cl-ext]
  Like GETHASH, but if KEY is not found in the HASH-TABLE saves the DEFAULT
under key before returning it. Secondary return value is true if key was
already in the table.
\end{function}

\begin{function}{remhash}{key hash-table}
  Remove the entry in HASH-TABLE associated with KEY. Return T if
there was such an entry, or NIL if not.
\end{function}

\begin{function}{clrhash}{hash-table}
  This removes all the entries from HASH-TABLE and returns the hash
table itself.
\end{function}

\begin{function}{hash-table-keys}{table}[cl-ext]
  Returns a list containing the keys of hash table TABLE.
\end{function}

\begin{function}{hash-table-values}{table}[cl-ext]
  Returns a list containing the values of hash table TABLE.
\end{function}

\section{Hash table mapping and iteration}
\label{sec:hash-table-mapping}

\begin{macro}{with-hash-table-iterator}{name \body body}
  WITH-HASH-TABLE-ITERATOR ((name hash-table) \&body body)

Provides a method of manually looping over the elements of a hash-table. NAME
is bound to a generator-macro that, within the scope of the invocation,
returns one or three values. The first value tells whether any objects remain
in the hash table. When the first value is non-NIL, the second and third
values are the key and the value of the next object.

Consequences are undefined if HASH-TABLE is mutated during execution of BODY,
except for changing or removing elements corresponding to the current key. The
applies to all threads, not just the curren one -- even for synchronized
hash-tables. If the table may be mutated by another thread during iteration,
use eg. SB-EXT:WITH-LOCKED-HASH-TABLE to protect the WITH-HASH-TABLE-ITERATOR
for.
\end{macro}

\begin{function}{maphash}{function-designator hash-table}
  For each entry in HASH-TABLE, call the designated two-argument function on
the key and value of the entry. Return NIL.

Consequences are undefined if HASH-TABLE is mutated during the call to
MAPHASH, except for changing or removing elements corresponding to the
current key. The applies to all threads, not just the current one --
even for synchronized hash-tables. If the table may be mutated by
another thread during iteration, use eg. SB-EXT:WITH-LOCKED-HASH-TABLE
to protect the MAPHASH call.
\end{function}

\begin{function}{maphash-keys}{hash-table}[cl-ext]
  Like MAPHASH, but calls FUNCTION with each key in the hash table TABLE.
\end{function}

\begin{function}{maphash-values}{hash-table}[cl-ext]
  Like MAPHASH, but calls FUNCTION with each value in the hash table TABLE.
\end{function}

\section{Hash table information}
\label{sec:hash-table-inform}

\begin{function}{hash-table-count}{hash-table}
  Return the number of entries in the given HASH-TABLE.
\end{function}

\begin{function}{hash-table-rehash-size}{instance}
  Return the rehash-size HASH-TABLE was created with.
\end{function}

\begin{function}{hash-table-rehash-threshold}{instance}
  Return the rehash-threshold HASH-TABLE was created with.
\end{function}

\begin{function}{hash-table-size}{hash-table}
  Return a size that can be used with MAKE-HASH-TABLE to create a hash
   table that can hold however many entries HASH-TABLE can hold without
   having to be grown.
\end{function}

\begin{function}{hash-table-test}{instance}
  Return the test function HASH-TABLE was created with.
\end{function}

\section{Hash table conversion}
\label{sec:hash-table-conv}

\begin{function}{plist-to-hash}{plist \rest hash-table-initargs}[cl-ext]
  Returns a hash table containing the keys and values of the property list
PLIST. Hash table is initialized using the HASH-TABLE-INITARGS.
\end{function}

\begin{function}{alist-to-hash}{alist \rest hash-table-initargs}[cl-ext]
  Returns a hash table containing the keys and values of the association list
ALIST. Hash table is initialized using the HASH-TABLE-INITARGS.
\end{function}

\begin{function}{hash-to-alist}{hash-table}[cl-ext]
  Returns an association list containing the keys and values of hash
  table.
\end{function}

\begin{function}{hash-to-plist}{hash-table}[cl-ext]
  Returns a property list containing the keys and values of hash
  table.
\end{function}

\section{Primitive hash function}
\label{sec:prim-hash-funct}

\begin{function}{sxhash}{x}
  Returns an implementation dependent hash code for an object.
\end{function}

\chapter{Structures}

\begin{macro}{defstruct}{name-and-options \rest slot-descriptions}
  DEFSTRUCT {Name | (Name Option*)} {Slot | (Slot [Default] {Key Value}*)}
   Define the structure type Name. Instances are created by MAKE-<name>,
   which takes \&KEY arguments allowing initial slot values to the specified.
   A SETF'able function <name>-<slot> is defined for each slot to read and
   write slot values. <name>-p is a type predicate.

   Popular DEFSTRUCT options (see manual for others):

   (:CONSTRUCTOR Name)
   (:PREDICATE Name)
       Specify the name for the constructor or predicate.

   (:CONSTRUCTOR Name Lambda-List)
       Specify the name and arguments for a BOA constructor
       (which is more efficient when keyword syntax isn't necessary.)

   (:INCLUDE Supertype Slot-Spec*)
       Make this type a subtype of the structure type Supertype. The optional
       Slot-Specs override inherited slot options.

   Slot options:

   :TYPE Type-Spec
       Asserts that the value of this slot is always of the specified type.

   :READ-ONLY {T | NIL}
       If true, no setter function is defined for this slot.
\end{macro}

\begin{function}{copy-structure}{structure}
  Return a copy of STRUCTURE with the same (EQL) slot values.
\end{function}



\chapter{Streams}
\label{cha:streams}

\section{Predicates}
\label{sec:stream-predicates}

\begin{function}{streamp}{stream}
  
\end{function}

\begin{function}{input-stream-p}{stream}
  Can STREAM perform input operations?
\end{function}

\begin{function}{open-stream-p}{stream}
  Return true if STREAM is not closed. A default method is provided
  by class FUNDAMENTAL-STREAM which returns true if CLOSE has not been
  called on the stream.
\end{function}

\begin{function}{output-stream-p}{stream}
  Can STREAM perform output operations?
\end{function}

\begin{function}{interactive-stream-p}{stream}
  Is STREAM an interactive stream?
\end{function}

\section{Standard streams}
\label{sec:standard-streams}

\begin{variable}{*standard-input*}{}
  
\end{variable}

\begin{variable}{*standard-output*}{}
  
\end{variable}

\begin{variable}{*error-output*}{}
  
\end{variable}

\begin{variable}{*query-io*}{}
  
\end{variable}

\begin{variable}{*terminal-io*}{}
  
\end{variable}

\begin{variable}{*trace-output*}{}
  
\end{variable}

\begin{variable}{*debug-io*}{}
  
\end{variable}

\section{Creating streams}
\label{sec:creating-streams}

\begin{function}{make-synonym-stream}{symbol}
  
\end{function}

\begin{function}{make-broadcast-stream}{\rest streams}
  
\end{function}

\begin{function}{make-concatenated-stream}{\rest streams}
  Return a stream which takes its input from each of the streams in turn,
   going on to the next at EOF.
\end{function}

\begin{function}{make-echo-stream}{input-stream output-stream}
  Return a bidirectional stream which gets its input from INPUT-STREAM and
   sends its output to OUTPUT-STREAM. In addition, all input is echoed to
   the output stream.
\end{function}

\begin{function}{make-string-input-stream}{string \op start end}
  Return an input stream which will supply the characters of STRING between
  START and END in order.
\end{function}

\begin{function}{make-string-output-stream}{\key element-type \aux buffer}
  Return an output stream which will accumulate all output given it for the
benefit of the function GET-OUTPUT-STREAM-STRING.
\end{function}

\begin{function}{make-two-way-stream}{input-stream output-stream}
  Return a bidirectional stream which gets its input from INPUT-STREAM and
   sends its output to OUTPUT-STREAM.
\end{function}

\begin{function}{get-output-stream-string}{stream}
  
\end{function}

\begin{macro}{with-open-stream}{var \body forms-decls}
  
\end{macro}

\begin{macro}{with-input-from-string}{var \body forms-decls}
  
\end{macro}

\begin{macro}{with-output-to-string}{var \body forms-decls}
  
\end{macro}

\begin{function}{copy-stream}{input output \op element-type}[cl-ext]
  Reads data from FROM and writes it to TO. Both FROM and TO must be streams,
they will be passed to read-sequence/write-sequence and must have compatable
element-types.
\end{function}

\section{Operations on streams}
\label{sec:operations-streams}

\begin{function}{stream-element-type}{stream}
  Return a type specifier for the kind of object returned by the
  STREAM. The class FUNDAMENTAL-CHARACTER-STREAM provides a default method
  which returns CHARACTER.
\end{function}

\begin{function}{close}{stream \key abort}
  Close the given STREAM. No more I/O may be performed, but
  inquiries may still be made. If :ABORT is true, an attempt is made
  to clean up the side effects of having created the stream.
\end{function}

\begin{function}{broadcast-stream-streams}{instance}
  
\end{function}

\begin{function}{concatenated-stream-streams}{instance}
  
\end{function}

\begin{function}{echo-stream-input-stream}{instance}
  
\end{function}

\begin{function}{echo-stream-output-stream}{instance}
  
\end{function}

\begin{function}{synonym-stream-symbol}{instance}
  
\end{function}

\begin{function}{two-way-stream-input-stream}{instance}
  
\end{function}

\begin{function}{two-way-stream-output-stream}{instance}
  
\end{function}

\begin{function}{stream-external-format}{stream}
  
\end{function}


\chapter{Input and Output}
\label{cha:input-output}

\section{The readtable}
\label{sec:readtable}

\begin{variable}{*read-base*}{}
  
\end{variable}

\begin{variable}{*read-eval*}{}
  
\end{variable}

\begin{variable}{*read-suppress*}{}
  
\end{variable}

\begin{variable}{*readtable*}{}
  
\end{variable}

\begin{function}{copy-readtable}{\op from-readtable to-readtable}
  
\end{function}

\begin{function}{readtablep}{object}
  
\end{function}

\begin{function}{set-syntax-from-char}{to-char from-char \op to-readtable from-readtable}
  Causes the syntax of TO-CHAR to be the same as FROM-CHAR in the optional
readtable (defaults to the current readtable). The FROM-TABLE defaults to the
standard Lisp readtable when NIL.
\end{function}

\begin{function}{set-macro-character}{char function \op non-terminatingp rt-designator}
  Causes CHAR to be a macro character which invokes FUNCTION when seen
   by the reader. The NON-TERMINATINGP flag can be used to make the macro
   character non-terminating, i.e. embeddable in a symbol name.
\end{function}

\begin{function}{get-macro-character}{char \op rt-designator}
  Return the function associated with the specified CHAR which is a macro
  character, or NIL if there is no such function. As a second value, return
  T if CHAR is a macro character which is non-terminating, i.e. which can
  be embedded in a symbol name.
\end{function}

\begin{function}{make-dispatch-macro-character}{char \op non-terminating-p rt}
  Cause CHAR to become a dispatching macro character in readtable (which
   defaults to the current readtable). If NON-TERMINATING-P, the char will
   be non-terminating.
\end{function}

\begin{function}{get-dispatch-macro-character}{disp-char sub-char \op rt-designator}
  Return the macro character function for SUB-CHAR under DISP-CHAR
   or NIL if there is no associated function.
\end{function}

\begin{function}{set-dispatch-macro-character}{disp-char sub-char function \op rt-designator}
  Cause FUNCTION to be called whenever the reader reads DISP-CHAR
   followed by SUB-CHAR.
\end{function}

\begin{accessor}{readtable-case}{readtable}
  
\end{accessor}

\section{Printer}
\label{sec:printer}

\begin{variable}{*print-readably*}{}
  
\end{variable}

\begin{variable}{*print-escape*}{}
  
\end{variable}

\begin{variable}{*print-circle*}{}
  
\end{variable}

\begin{variable}{*print-pretty*}{}
  
\end{variable}

\begin{variable}{*print-base*}{}
  
\end{variable}

\begin{variable}{*print-radix*}{}
  
\end{variable}

\begin{variable}{*print-case*}{}
  
\end{variable}

\begin{variable}{*print-array*}{}
  
\end{variable}

\begin{variable}{*print-gensym*}{}
  
\end{variable}

\begin{variable}{*print-length*}{}
  
\end{variable}

\begin{variable}{*print-level*}{}
  
\end{variable}

\begin{macro}{with-standard-io-syntax}{\body body}
  Bind the reader and printer control variables to values that enable READ
   to reliably read the results of PRINT. These values are:
       *PACKAGE*                        the COMMON-LISP-USER package
       *PRINT-ARRAY*                    T
       *PRINT-BASE*                     10
       *PRINT-CASE*                     :UPCASE
       *PRINT-CIRCLE*                   NIL
       *PRINT-ESCAPE*                   T
       *PRINT-GENSYM*                   T
       *PRINT-LENGTH*                   NIL
       *PRINT-LEVEL*                    NIL
       *PRINT-LINES*                    NIL
       *PRINT-MISER-WIDTH*              NIL
       *PRINT-PRETTY*                   NIL
       *PRINT-RADIX*                    NIL
       *PRINT-READABLY*                 T
       *PRINT-RIGHT-MARGIN*             NIL
       *READ-BASE*                      10
       *READ-DEFAULT-FLOAT-FORMAT*      SINGLE-FLOAT
       *READ-EVAL*                      T
       *READ-SUPPRESS*                  NIL
       *READTABLE*                      the standard readtable
\end{macro}

\section{Input from character streams}
\label{sec:input-from-character}

See also \funr{parse-integer} and \funr{read-sequence}.

\begin{function}{read}{\op stream eof-error-p eof-value recursive-p}
  Read the next Lisp value from STREAM, and return it.
\end{function}

\begin{variable}{*read-default-float-format*}{}
  
\end{variable}

\begin{function}{read-preserving-whitespace}{\op stream eof-error-p eof-value recursive-p}
  Read from STREAM and return the value read, preserving any whitespace
   that followed the object.
\end{function}

\begin{function}{read-delimited-list}{endchar \op input-stream recursive-p}
  Read Lisp values from INPUT-STREAM until the next character after a
   value's representation is ENDCHAR, and return the objects as a list.
\end{function}

\begin{function}{read-line}{\op stream eof-error-p eof-value recursive-p}
  
\end{function}

\begin{function}{read-char}{\op stream eof-error-p eof-value recursive-p}
  
\end{function}

\begin{function}{unread-char}{character \op stream}
  
\end{function}

\begin{function}{peek-char}{\op peek-type stream eof-error-p eof-value recursive-p}
  
\end{function}

\begin{function}{listen}{\op stream}
  
\end{function}

\begin{function}{read-char-no-hang}{\op stream eof-error-p eof-value recursive-p}
  
\end{function}

\begin{function}{clear-input}{\op stream}
  
\end{function}

\begin{function}{read-from-string}{string \op eof-error-p eof-value \key start end preserve-whitespace}
  The characters of string are successively given to the lisp reader
   and the lisp object built by the reader is returned. Macro chars
   will take effect.
\end{function}

\section{Input from binary}
\label{sec:input-from-binary}

\begin{function}{read-byte}{stream \op eof-error-p eof-value}
  
\end{function}

\section{Output to character streams}
\label{sec:outp-char-stre}

See also \funr{print-grid}.

\begin{function}{write}{object \key stream escape radix base circle
    pretty level length case array gensym readably right-margin
    miser-width lines pprint-dispatch}

  Output OBJECT to the specified stream, defaulting to
  *STANDARD-OUTPUT*

(stream stream) (escape *print-escape*) (radix *print-radix*)
 (base *print-base*) (circle *print-circle*) (pretty *print-pretty*)
 (level *print-level*) (length *print-length*) (case *print-case*)
 (array *print-array*) (gensym *print-gensym*) (readably *print-readably*)
 (right-margin *print-right-margin*) (miser-width *print-miser-width*)
 (lines *print-lines*) (pprint-dispatch *print-pprint-dispatch*)
\end{function}

\begin{function}{prin1}{object \op stream}
  Output a mostly READable printed representation of OBJECT on the specified
  STREAM.
\end{function}

\begin{function}{print}{object \op stream}
  Output a newline, the mostly READable printed representation of OBJECT, and
  space to the specified STREAM.
\end{function}

\begin{function}{pprint}{object \op stream}
  Prettily output OBJECT preceded by a newline.
\end{function}

\begin{function}{princ}{object \op stream}
  Output an aesthetic but not necessarily READable printed representation
  of OBJECT on the specified STREAM.
\end{function}

\begin{function}{write-to-string}{object \key escape radix base circle
    pretty level length case array gensym readably right-margin
    miser-width lines pprint-dispatch}

  Return the printed representation of OBJECT as a string.

(escape *print-escape*) (radix *print-radix*) (base *print-base*)
 (circle *print-circle*) (pretty *print-pretty*) (level *print-level*)
 (length *print-length*) (case *print-case*) (array *print-array*)
 (gensym *print-gensym*) (readably *print-readably*)
 (right-margin *print-right-margin*) (miser-width *print-miser-width*)
 (lines *print-lines*) (pprint-dispatch *print-pprint-dispatch*)
\end{function}

\begin{function}{prin1-to-string}{object}
  Return the printed representation of OBJECT as a string with
   slashification on.
\end{function}

\begin{function}{princ-to-string}{object}
  Return the printed representation of OBJECT as a string with
  slashification off.
\end{function}

\begin{function}{write-char}{character \op stream}
  
\end{function}

\begin{function}{write-string}{string \op stream \key start end}
  
\end{function}

\begin{function}{write-sequence}{seq stream \key start end}
  Write the elements of SEQ bounded by START and END to STREAM.
\end{function}

\begin{function}{terpri}{\op stream}
  
\end{function}

\begin{function}{write-line}{string \op stream \key start end}
  
\end{function}

\begin{function}{fresh-line}{\op stream}
  
\end{function}

\begin{function}{finish-output}{\op stream}
  
\end{function}

\begin{function}{force-output}{\op stream}
  
\end{function}

\begin{function}{clear-output}{\op stream}
  
\end{function}

\begin{macro}{print-unreadable-object}{object \body body}
  Output OBJECT to STREAM with "\#<" prefix, ">" suffix, optionally
  with object-type prefix and object-identity suffix, and executing the
  code in BODY to provide possible further output.
\end{macro}

\section{Output to binary}
\label{sec:output-binary}

\begin{function}{write-byte}{integer stream}
  
\end{function}

\section{Formatted output}
\label{sec:formatted-output}

\begin{function}{format}{destination control-string \rest format-arguments}
  Provides various facilities for formatting output.
  CONTROL-STRING contains a string to be output, possibly with embedded
  directives, which are flagged with the escape character "\~{}\%". Directives
  generally expand into additional text to be output, usually consuming one
  or more of the FORMAT-ARGUMENTS in the process. A few useful directives
  are:
        \~{}\%A or \~{}\%nA   Prints one argument as if by PRINC
        \~{}\%S or \~{}\%nS   Prints one argument as if by PRIN1
        \~{}\%D or \~{}\%nD   Prints one argument as a decimal integer
        \~{}\%\%          Does a TERPRI
        \~{}\%\&          Does a FRESH-LINE
  where n is the width of the field in which the object is printed.

  DESTINATION controls where the result will go. If DESTINATION is T, then
  the output is sent to the standard output stream. If it is NIL, then the
  output is returned in a string as the value of the call. Otherwise,
  DESTINATION must be a stream to which the output will be sent.

  Example:   (FORMAT NIL "The answer is \~{}\%D." 10) => "The answer is 10."

  FORMAT has many additional capabilities not described here. Consult the
  manual for details.
\end{function}

\section{Querying the user}
\label{sec:querying-user}

\begin{function}{y-or-n-p}{\op format-string \rest arguments}
  Y-OR-N-P prints the message, if any, and reads characters from
   *QUERY-IO* until the user enters y or Y as an affirmative, or either
   n or N as a negative answer. It asks again if you enter any other
   characters.
\end{function}

\begin{function}{yes-or-no-p}{\op format-string \rest arguments}
  YES-OR-NO-P is similar to Y-OR-N-P, except that it clears the
   input buffer, beeps, and uses READ-LINE to get the strings
   YES or NO.
\end{function}


\chapter{File system interface}
\label{cha:file-syst-interf}

\section{Predicates}
\label{sec:predicates-3}

\begin{function}{wild-pathname-p}{pathname \op field-key}
  Predicate for determining whether pathname contains any wildcards.
\end{function}

\begin{function}{pathname-match-p}{in-pathname in-wildname}
  Pathname matches the wildname template?
\end{function}

\begin{function}{pathnamep}{object}
  
\end{function}

\begin{function}{directory-pathname-p}{pathspec}[cl-ext]
  Returns NIL if PATHSPEC (a pathname designator) does not designate a
  directory, PATHSPEC otherwise. It is irrelevant whether file or
  directory designated by PATHSPEC does actually exist.
\end{function}

\begin{function}{directory-exists-p}{pathspec}[cl-ext]
  Checks whether the file named by the pathname designator PATHSPEC
  exists and if it is a directory. Returns its truename if this is the
  case, NIL otherwise. The truename is returned in directory form as
  if by PATHNAME-AS-DIRECTORY.
\end{function}

\begin{function}{file-exists-p}{pathspec}[cl-ext]
  Checks whether the file named by the pathname designator PATHSPEC
  exists and returns its truename if this is the case, NIL otherwise.
  The truename is returned in ``canonical'' form, i.e. the truename of
  a directory is returned as if by PATHNAME-AS-DIRECTORY.
\end{function}

\section{Filenames}
\label{sec:filenames}

Extended wildcards

\begin{function}{translate-pathname}{source from-wildname to-wildname \key}
  Use the source pathname to translate the from-wildname's wild and
   unspecified elements into a completed to-pathname based on the to-wildname.
\end{function}

Logical pathnames

\begin{function}{translate-logical-pathname}{pathname \key}
  Translate PATHNAME to a physical pathname, which is returned.
\end{function}

\begin{class}{logical-pathname}{pathspec}
  Converts the pathspec argument to a logical-pathname and returns it.
\end{class}

\begin{accessor}{logical-pathname-translations}{host}
  Return the (logical) host object argument's list of translations.
\end{accessor}

\begin{function}{logical-pathname}{pathspec}
  Converts the pathspec argument to a logical-pathname and returns it.
\end{function}

\begin{function}{load-logical-pathname-translations}{host}
  
\end{function}

Pathname functions

\begin{variable}{*default-pathname-defaults*}{}
  
\end{variable}

\begin{function}{pathname}{pathspec}
  Convert PATHSPEC (a pathname designator) into a pathname.
\end{function}

\begin{function}{truename}{pathspec}
  If PATHSPEC is a pathname that names an existing file, return
a pathname that denotes a canonicalized name for the file.  If
pathspec is a stream associated with a file, return a pathname
that denotes a canonicalized name for the file associated with
the stream.

An error of type FILE-ERROR is signalled if no such file exists
or if the file system is such that a canonicalized file name
cannot be determined or if the pathname is wild.

Under Unix, the TRUENAME of a symlink that links to itself or to
a file that doesn't exist is considered to be the name of the
broken symlink itself.
\end{function}

\begin{function}{parse-namestring}{thing \op host defaults \key start end junk-allowed}
  
\end{function}

\begin{function}{merge-pathnames}{pathname \op defaults default-version}
  Construct a filled in pathname by completing the unspecified components
   from the defaults.
\end{function}

\begin{function}{make-pathname}{\key host device directory name type version defaults case}
  Makes a new pathname from the component arguments. Note that host is
a host-structure or string.
\end{function}

\begin{function}{pathname-as-file}{pathname}[cl-ext]
  Converts the non-wild pathname designator PATHNAME to file form.
\end{function}

\begin{function}{pathname-as-directory}{pathspec}[cl-ext]
  Converts the non-wild pathname designator PATHSPEC to directory
form.
\end{function}

\begin{function}{pathname-device}{pathname \key case}
  Return PATHNAME's device.
\end{function}

\begin{function}{pathname-directory}{pathname \key case}
  Return PATHNAME's directory.
\end{function}

\begin{function}{pathname-host}{pathname \key case}
  Return PATHNAME's host.
\end{function}

\begin{function}{pathname-name}{pathname \key case}
  Return PATHNAME's name.
\end{function}

\begin{function}{pathname-type}{pathname \key case}
  Return PATHNAME's type.
\end{function}

\begin{function}{pathname-version}{pathname}
  Return PATHNAME's version.
\end{function}

\begin{function}{namestring}{pathname}
  Construct the full (name)string form of the pathname.
\end{function}

\begin{function}{file-namestring}{pathname}
  Return a string representation of the name used in the pathname.
\end{function}

\begin{function}{host-namestring}{pathname}
  Return a string representation of the name of the host in the pathname.
\end{function}

\begin{function}{directory-namestring}{pathname}
  Return a string representation of the directories used in the pathname.
\end{function}

\begin{function}{enough-namestring}{pathname \op defaults}
  Return an abbreviated pathname sufficent to identify the pathname relative
   to the defaults.
\end{function}

\begin{function}{user-homedir-pathname}{\op host}
  Return the home directory of the user as a pathname. If the HOME
environment variable has been specified, the directory it designates
is returned; otherwise obtains the home directory from the operating
system.
\end{function}

\section{Dealing with files}
\label{sec:dealing-with-files}

\subsection{Reading and writing files}
\label{sec:read-writ}

\begin{function}{open}{filename \key direction element-type if-exists if-does-not-exist
 external-format \aux direction if-does-not-exist if-exists}
  Return a stream which reads from or writes to FILENAME.
  Defined keywords:
   :DIRECTION - one of :INPUT, :OUTPUT, :IO, or :PROBE
   :ELEMENT-TYPE - the type of object to read or write, default BASE-CHAR
   :IF-EXISTS - one of :ERROR, :NEW-VERSION, :RENAME, :RENAME-AND-DELETE,
                       :OVERWRITE, :APPEND, :SUPERSEDE or NIL
   :IF-DOES-NOT-EXIST - one of :ERROR, :CREATE or NIL
  See the manual for details.
\end{function}

\begin{macro}{with-open-file}{stream \body body}
  
\end{macro}

\begin{macro}{with-input-from-file}{stream-name file-name \rest args
    \key direction \akeys \body body}[cl-ext]
  Evaluate BODY with STREAM-NAME bound to an input-stream from file
FILE-NAME. ARGS is passed directly to open.
\end{macro}

\begin{macro}{with-output-to-file}{stream-name file-name \rest args
    \key direction \akeys \body body}[cl-ext]
  Evaluate BODY with STREAM-NAME to an output stream on the file
FILE-NAME. ARGS is sent as is to the call te open. It will supersed
file-name if it exists.
\begin{devnote}
  The supersed thing is not originaly in alexandria, but I think it's
  more useful.
\end{devnote}
\end{macro}

\begin{function}{write-string-into-file}{string pathname \key if-exists if-does-not-exist external-format}[cl-ext]
  Write STRING to PATHNAME.

The EXTERNAL-FORMAT parameter will be passed to
ENCODING-KEYWORD-TO-NATIVE, see ENCODING-KEYWORD-TO-NATIVE to
possible values.
\end{function}

\begin{function}{read-file-into-string}{pathname \key buffer-size external-format}[cl-ext]
  Return the contents of PATHNAME as a fresh string.

The file specified by PATHNAME will be read one ELEMENT-TYPE
element at a time, the EXTERNAL-FORMAT and ELEMENT-TYPEs must be
compatible.

The EXTERNAL-FORMAT parameter will be passed to
ENCODING-KEYWORD-TO-NATIVE, see ENCODING-KEYWORD-TO-NATIVE to
possible values.
\end{function}

\subsection{Operations on files}
\label{sec:operations-files}

\begin{function}{rename-file}{file new-name}
  Rename FILE to have the specified NEW-NAME. If FILE is a stream open to a
  file, then the associated file is renamed.
\end{function}

\begin{function}{delete-file}{file}
  Delete the specified FILE.
\end{function}

\begin{function}{delete-directory-and-files}{dirname \key if-does-not-exist}[cl-ext]
  Recursively deletes all files and directories within the directory
  designated by the non-wild pathname designator DIRNAME including
  DIRNAME itself. IF-DOES-NOT-EXIST must be one of :ERROR or :IGNORE
  where :ERROR means that an error will be signaled if the directory
  DIRNAME does not exist.
\end{function}

\begin{function}{probe-file}{pathspec}
  Return the truename of PATHSPEC if the truename can be found,
or NIL otherwise.  See TRUENAME for more information.
\end{function}

\begin{function}{ensure-directories-exist}{pathspec \key verbose mode}
  Test whether the directories containing the specified file
  actually exist, and attempt to create them if they do not.
  The MODE argument is a CMUCL/SBCL-specific extension to control
  the Unix permission bits.
\end{function}

\begin{function}{copy-file}{from to \key if-to-exists element-type}[cl-ext]
  Copies the file designated by the non-wild pathname designator FROM
  to the file designated by the non-wild pathname designator TO. If
  OVERWRITE is true overwrites the file designtated by TO if it
  exists.
\end{function}

\begin{function}{file-write-date}{pathspec}
  Return the write date of the file specified by PATHSPEC.
An error of type FILE-ERROR is signaled if no such file exists,
or if PATHSPEC is a wild pathname.
\end{function}

\begin{function}{file-author}{pathspec}
  Return the author of the file specified by PATHSPEC. Signal an
error of type FILE-ERROR if no such file exists, or if PATHSPEC
is a wild pathname.
\end{function}

\begin{function}{file-position}{stream \op position}
  
\end{function}

\begin{function}{file-length}{stream}
  
\end{function}

\begin{function}{file-string-length}{stream object}
  
\end{function}

\begin{function}{mkdir}{dir}[cl-ext]
  
\end{function}

\begin{function}{rmdir}{dir}[cl-ext]
  
\end{function}

\begin{function}{default-directory}{}[cl-ext]
  
\end{function}

\begin{function}{chdir}{dir}[cl-ext]
  Change directory and set default pathname.
\end{function}

\begin{macro}{with-dir}{directory \body body}[cl-ext]
  Execute body after changing directory. Change back to previous
  directory after executing body.
\end{macro}

Loading files

See \funr{load}, \funr{make-load-form} and
\funr{make-load-form-saving-slots}

Accessing directories

\begin{function}{directory}{pathname \key resolve-symlinks}
  Return a list of PATHNAMEs, each the TRUENAME of a file that matched the
   given pathname. Note that the interaction between this ANSI-secified
   TRUENAMEing and the semantics of the Unix filesystem (symbolic links..)
   means this function can sometimes return files which don't have the same
   directory as PATHNAME.  If :RESOLVE-SYMLINKS is NIL, don't resolve
   symbolic links in matching filenames.
\end{function}

\begin{function}{walk-directory}{dirname fn \key directories
    if-does-not-exist test}[cl-ext]
  Recursively applies the function FN to all files within the
  directory named by the non-wild pathname designator DIRNAME and all
  of its sub-directories. FN will only be applied to files for which
  the function TEST returns a true value. If DIRECTORIES is not NIL,
  FN and TEST are applied to directories as well. If DIRECTORIES is
  :DEPTH-FIRST, FN will be applied to the directory's contents first.
  If DIRECTORIES is :BREADTH-FIRST and TEST returns NIL, the
  directory's content will be skipped. IF-DOES-NOT-EXIST must be one
  of :ERROR or :IGNORE where :ERROR means that an error will be
  signaled if the directory DIRNAME does not exist.
\end{function}

\begin{function}{list-directory}{dirname}[cl-ext]
  Returns a fresh list of pathnames corresponding to the truenames of
  all files within the directory named by the non-wild pathname
  designator DIRNAME. The pathnames of sub-directories are returned in
  directory form---see \funr{pathname-as-directory}
\end{function}

\begin{function}{directory-wildcard}{dirname}[cl-ext]
  Returns a wild pathname designator that designates all files within
  the directory named by the non-wild pathname designator DIRNAME.
\end{function}


\chapter{Pretty printing}
\label{cha:pretty-printing}

\section{Control variables}
\label{sec:control-variables}

\begin{variable}{*print-pprint-dispatch*}{}
  
\end{variable}

\begin{variable}{*print-right-margin*}{}
  
\end{variable}

\begin{variable}{*print-miser-width*}{}
  
\end{variable}

\begin{variable}{*print-lines*}{}
  
\end{variable}

\section{Dynamic control of the arrangement of output}
\label{sec:dynam-contr-arrang}

\begin{function}{pprint-newline}{kind \op stream}
  Output a conditional newline to STREAM (which defaults to
   *STANDARD-OUTPUT*) if it is a pretty-printing stream, and do
   nothing if not. KIND can be one of:
     :LINEAR - A line break is inserted if and only if the immediatly
        containing section cannot be printed on one line.
     :MISER - Same as LINEAR, but only if ``miser-style'' is in effect.
        (See *PRINT-MISER-WIDTH*.)
     :FILL - A line break is inserted if and only if either:
       (a) the following section cannot be printed on the end of the
           current line,
       (b) the preceding section was not printed on a single line, or
       (c) the immediately containing section cannot be printed on one
           line and miser-style is in effect.
     :MANDATORY - A line break is always inserted.
   When a line break is inserted by any type of conditional newline, any
   blanks that immediately precede the conditional newline are ommitted
   from the output and indentation is introduced at the beginning of the
   next line. (See PPRINT-INDENT.)
\end{function}

\begin{macro}{pprint-logical-block}{stream-symbol \body body \env env}
  Group some output into a logical block. STREAM-SYMBOL should be either a
   stream, T (for *TERMINAL-IO*), or NIL (for *STANDARD-OUTPUT*). The printer
   control variable *PRINT-LEVEL* is automatically handled.
\end{macro}

\begin{macro}{pprint-exit-if-list-exhausted}{}
  
\end{macro}

\begin{macro}{pprint-pop}{}
  
\end{macro}

\begin{function}{pprint-indent}{relative-to n \op stream}
  Specify the indentation to use in the current logical block if
STREAM (which defaults to *STANDARD-OUTPUT*) is a pretty-printing
stream and do nothing if not. (See PPRINT-LOGICAL-BLOCK.) N is the
indentation to use (in ems, the width of an ``m'') and RELATIVE-TO can
be either:

     :BLOCK - Indent relative to the column the current logical block
        started on.

     :CURRENT - Indent relative to the current column.

The new indentation value does not take effect until the following
line break.
\end{function}

\begin{function}{pprint-tab}{kind colnum colinc \op stream}
  If STREAM (which defaults to *STANDARD-OUTPUT*) is a pretty-printing
   stream, perform tabbing based on KIND, otherwise do nothing. KIND can
   be one of:
     :LINE - Tab to column COLNUM. If already past COLNUM tab to the next
       multiple of COLINC.
     :SECTION - Same as :LINE, but count from the start of the current
       section, not the start of the line.
     :LINE-RELATIVE - Output COLNUM spaces, then tab to the next multiple of
       COLINC.
     :SECTION-RELATIVE - Same as :LINE-RELATIVE, but count from the start
       of the current section, not the start of the line.
\end{function}

\begin{function}{pprint-fill}{stream list \op colon? atsign?}
  Output LIST to STREAM putting :FILL conditional newlines between each
   element. If COLON? is NIL (defaults to T), then no parens are printed
   around the output. ATSIGN? is ignored (but allowed so that PPRINT-FILL
   can be used with the \~{}\%/.../ format directive.
\end{function}

\begin{function}{pprint-linear}{stream list \op colon? atsign?}
  Output LIST to STREAM putting :LINEAR conditional newlines between each
   element. If COLON? is NIL (defaults to T), then no parens are printed
   around the output. ATSIGN? is ignored (but allowed so that PPRINT-LINEAR
   can be used with the \~{}\%/.../ format directive.
\end{function}

\begin{function}{pprint-tabular}{stream list \op colon? atsign? tabsize}
  Output LIST to STREAM tabbing to the next column that is an even multiple
   of TABSIZE (which defaults to 16) between each element. :FILL style
   conditional newlines are also output between each element. If COLON? is
   NIL (defaults to T), then no parens are printed around the output.
   ATSIGN? is ignored (but allowed so that PPRINT-TABULAR can be used with
   the \~{}\%/.../ format directive.
\end{function}

\begin{generic}{print-object}{object stream}
  
\end{generic}

\begin{macro}{defprint-object}{self \body body}[cl-ext]
  Define a print-object method using print-unreadable-object.
\end{macro}

\section{Format interface}
\label{sec:form-direct-interf}

See also \funr{format}

\begin{function}[format-pprint]{format}{destination control-string \rest format-arguments}
\begin{list}{}{}
\item \verb!~W!
\item \verb!~_!
\item \verb!~<str~:>!
\item \verb!~I!
\item \verb!~:T!
\item \verb!~/name/!
\end{list}
\end{function}

\begin{macro}{formatter}{control-string}
  
\end{macro}

\section{Pretty printing dispatch tables}
\label{sec:pretty-print-disp}

\begin{function}{copy-pprint-dispatch}{\op table}
  
\end{function}

\begin{function}{pprint-dispatch}{object \op table}
  
\end{function}

\begin{function}{set-pprint-dispatch}{type function \op priority table}
  
\end{function}


\chapter{Functions}

\section{Extensions}
\label{sec:fun-extensions}

\begin{function}{ensure-function}{function-designator}[cl-ext]
  Returns the function designated by FUNCTION-DESIGNATOR:
if FUNCTION-DESIGNATOR is a function, it is returned, otherwise
it must be a function name and its FDEFINITION is returned.
\end{function}

\begin{function}{disjoin}{predicate \rest more-predicates}[cl-ext]
  Returns a function that applies each of PREDICATE and MORE-PREDICATE
functions in turn to its arguments, returning the primary value of the first
predicate that returns true, without calling the remaining predicates.
If none of the predicates returns true, NIL is returned.
\end{function}

\begin{function}{conjoin}{predicate \rest more-predicates}[cl-ext]
  Returns a function that applies each of PREDICATE and MORE-PREDICATE
functions in turn to its arguments, returning NIL if any of the predicates
returns false, without calling the remaining predicates. If none of the
predicates returns false, returns the primary value of the last predicate.
\end{function}

\begin{function}{compose}{function \rest more-functions}[cl-ext]
  Returns a function composed of FUNCTION and MORE-FUNCTIONS that applies its
arguments to to each in turn, starting from the rightmost of MORE-FUNCTIONS,
and then calling the next one with the primary value of the last.
\end{function}

\begin{function}{multiple-value-compose}{function \rest more-functions}[cl-ext]
  Returns a function composed of FUNCTION and MORE-FUNCTIONS that applies
its arguments to to each in turn, starting from the rightmost of
MORE-FUNCTIONS, and then calling the next one with all the return values of
the last.
\end{function}

\begin{function}{curry}{function \rest arguments}[cl-ext]
  Returns a function that applies ARGUMENTS and the arguments
it is called with to FUNCTION.
\end{function}

\begin{function}{rcurry}{function \rest arguments}[cl-ext]
  Returns a function that applies the arguments it is called
with and ARGUMENTS to FUNCTION.
\end{function}

\begin{macro}{named-lambda}{name lambda-list \body body}[cl-ext]
  Expands into a lambda-expression within whose BODY NAME denotes the
  corresponding function. Just like lambda except BODY can make recursive
  calls to the lambda by calling the function NAME.
\end{macro}

\begin{function}{make-reducer}{function \op initial-value}[cl-ext]
  Create a function which, starting with INITIAL-VALUE, reduces
any other values into a single final value.

FUNCTION will be called with two values: the current value and
the new value, in that order. FUNCTION should return exactly one
value.

The reducing function can be called with n arguments which will
be applied to FUNCTION one after the other (left to right) and
will return the new value.

If the reducing function is called with no arguments it will
return the current value.
\end{function}

\begin{macro}{with-reducer}{name \body body}[cl-ext]
  Locally bind NAME to a reducing function. The arguments
FUNCTION and INITIAL-VALUE are passed directly to MAKE-REDUCER.
\end{macro}

\begin{function}{make-collector}{\op initial-value}[cl-ext]
  Create a collector function.

A Collector function will collect, into a list, all the values
passed to it in the order in which they were passed. If the
callector function is called without arguments it returns the
current list of values.
\end{function}

\begin{macro}{with-collector}{name \body body}[cl-ext]
  Bind NAME to a collector function and execute BODY. If
  FROM-END is true the collector will actually be a pusher, (see
  MAKE-PUSHER), otherwise NAME will be bound to a collector,
  (see MAKE-COLLECTOR).
\end{macro}

\begin{macro}{with-collectors}{names \body body}[cl-ext]
  Bind multiple collectors. Each element of NAMES should be a
  list as per WITH-COLLECTOR's first orgument.
\end{macro}

\section{Macros}
\label{sec:macros}

\begin{macro}{with-gensyms}{names \body forms}[cl-ext]
  Binds each variable named by a symbol in NAMES to a unique symbol around
FORMS. Each of NAMES must either be either a symbol, or of the form:

 (symbol string-designator)

Bare symbols appearing in NAMES are equivalent to:

 (symbol symbol)

The string-designator is used as the argument to GENSYM when constructing the
unique symbol the named variable will be bound to.
\end{macro}

\begin{macro}{with-unique-names}{names \body forms}[cl-ext]
  Alias for WITH-GENSYMS.
\end{macro}

\begin{macro}{once-only}{specs \body forms}[cl-ext]
  Each SPEC must be either a NAME, or a (NAME INITFORM), with plain
NAME using the named variable as initform.

Evaluates FORMS with names rebound to temporary variables, ensuring
that each is evaluated only once.
\end{macro}

\begin{function}{parse-body}{body \key documentation whole}[cl-ext]
  Parses BODY into (values remaining-forms declarations doc-string).
Documentation strings are recognized only if DOCUMENTATION is true.
Syntax errors in body are signalled and WHOLE is used in the signal
arguments when given.
\end{function}

\begin{function}{parse-ordinary-lambda-list}{lambda-list}[cl-ext]
  Parses an ordinary lambda-list, returning as multiple values:

 1. Required parameters.
 2. Optional parameter specifications, normalized into form (NAME INIT SUPPLIEDP)
    where SUPPLIEDP is NIL if not present.
 3. Name of the rest parameter, or NIL.
 4. Keyword parameter specifications, normalized into form ((KEYWORD-NAME NAME) INIT SUPPLIEDP)
    where SUPPLIEDP is NIL if not present.
 5. Boolean indicating \&ALLOW-OTHER-KEYS presence.
 6. \&AUX parameter specifications, normalized into form (NAME INIT).

Signals a PROGRAM-ERROR is the lambda-list is malformed.
\end{function}

\begin{macro}{rebind}{bindings \body body}[cl-ext]
  
\end{macro}

\begin{macro}{rebinding}{bindings \body body}[cl-ext]
  Bind each var in BINDINGS to a gensym, bind the gensym to
var's value via a let, return BODY's value wrapped in this let.

Evaluates a series of forms in the lexical environment that is
formed by adding the binding of each VAR to a fresh, uninterned
symbol, and the binding of that fresh, uninterned symbol to VAR's
original value, i.e., its value in the current lexical
environment.

The uninterned symbol is created as if by a call to GENSYM with the
string denoted by PREFIX - or, if PREFIX is not supplied, the string
denoted by VAR - as argument.

The forms are evaluated in order, and the values of all but the last
are discarded (that is, the body is an implicit PROGN).
\end{macro}


\chapter{Control Structures}
\label{cha:control-structures}

\section{Predicates}
\label{sec:control-predicates}

\begin{function}{eq}{obj1 obj2}
  Return T if OBJ1 and OBJ2 are the same object, otherwise NIL.
\end{function}

\begin{function}{eql}{x y}
  
\end{function}

\begin{function}{equal}{x y}
  Return T if X and Y are EQL or if they are structured components whose
elements are EQUAL. Strings and bit-vectors are EQUAL if they are the same
length and have identical components. Other arrays must be EQ to be EQUAL.
\end{function}

\begin{function}{equalp}{x y}
  
\end{function}

\begin{function}{not}{object}
  Return T if X is NIL, otherwise return NIL.
\end{function}

\begin{function}{constantp}{form \op environment}
  True of any FORM that has a constant value: self-evaluating objects,
keywords, defined constants, quote forms. Additionally the
constant-foldability of some function calls special forms is recognized. If
ENVIRONMENT is provided the FORM is first macroexpanded in it.
\end{function}

\begin{function}{functionp}{object}
  Return true if OBJECT is a FUNCTION, and NIL otherwise.
\end{function}

\section{Constants and Variables}
\label{sec:constants-variables}

\begin{macro}{defconstant}{name value \op documentation}
  Define a global constant, saying that the value is constant and may be
  compiled into code. If the variable already has a value, and this is not
  EQL to the new value, the code is not portable (undefined behavior). The
  third argument is an optional documentation string for the variable.
\end{macro}

\begin{macro}{define-constant}{name initial-value \key test documentation}[cl-ext]
  Ensures that the global variable named by NAME is a constant with a value
that is equal under TEST to the result of evaluating INITIAL-VALUE. TEST is a
/function designator/ that defaults to EQL. If DOCUMENTATION is given, it
becomes the documentation string of the constant.

Signals an error if NAME is already a bound non-constant variable.

Signals an error if NAME is already a constant variable whose value is not
equal under TEST to result of evaluating INITIAL-VALUE.
\end{macro}

\begin{function}{variable-special-p}{symbol}[cl-ext]
  Return T if the symbol names a global special variable.
\end{function}

\begin{function}{variable-not-special}{symbol}[cl-ext]
  Undo the global special declaration. This returns a \emph{new}
  symbol with the same name, package, fdefinition, and plist as the
  argument. This can be confused by imported symbols. Also,
  (FUNCTION-LAMBDA-EXPRESSION (FDEFINITION NEW)) will return the OLD
  (uninterned!) symbol as its 3rd value. BEWARE!
\end{function}

\begin{macro}{defparameter}{var val \op doc}
  Define a parameter that is not normally changed by the program,
  but that may be changed without causing an error. Declare the
  variable special and sets its value to VAL, overwriting any
  previous value. The third argument is an optional documentation
  string for the parameter.
\end{macro}

\begin{macro}{defvar}{var \op val doc}
  Define a global variable at top level. Declare the variable
  SPECIAL and, optionally, initialize it. If the variable already has a
  value, the old value is not clobbered. The third argument is an optional
  documentation string for the variable.
\end{macro}

\begin{macro}{defsubst}{name arglist \body body}[cl-ext]
  Declare an inline defun.
\end{macro}

\begin{macro}{defcustom}{name type init doc}[cl-ext]
  Define a typed global variable.
\end{macro}

\begin{macro}{def-special-environment}{name \key \rest vars}[cl-ext]
  Define two macros for dealing with groups or related special variables.

ACCESSOR is defined as a macro: (defmacro ACCESSOR (VARS \&rest
BODY)).  Each element of VARS will be bound to the
current (dynamic) value of the special variable.

BINDER is defined as a macro for introducing (and binding new)
special variables. It is basically a readable LET form with the
prorpe declarations appended to the body. The first argument to
BINDER must be a form suitable as the first argument to LET.

ACCESSOR defaults to a new symbol in the same package as NAME
which is the concatenation of "WITH-" NAME. BINDER is built as
"BIND-" and BINDER* is BINDER "*".
\end{macro}

\begin{specialop}{let}{bindings \body body}
  LET ({(var [value]) | var}*) declaration* form*

During evaluation of the FORMS, bind the VARS to the result of evaluating the
VALUE forms. The variables are bound in parallel after all of the VALUES forms
have been evaluated.
\end{specialop}

\begin{specialop}{let*}{bindings \body body}
  LET* ({(var [value]) | var}*) declaration* form*

Similar to LET, but the variables are bound sequentially, allowing each VALUE
form to reference any of the previous VARS.
\end{specialop}

\begin{macro}{let1}{var val \body body}[cl-ext]
  
\end{macro}

\begin{macro}{if-let}{bindings \body then-form}[cl-ext]
  Creates new variable bindings, and conditionally executes either
THEN-FORM or ELSE-FORM. ELSE-FORM defaults to NIL.

BINDINGS must be either single binding of the form:

 (variable initial-form)

or a list of bindings of the form:

 ((variable-1 initial-form-1)
  (variable-2 initial-form-2)
  ...
  (variable-n initial-form-n))

All initial-forms are executed sequentially in the specified order. Then all
the variables are bound to the corresponding values.

If all variables were bound to true values, the THEN-FORM is executed with the
bindings in effect, otherwise the ELSE-FORM is executed with the bindings in
effect.
\end{macro}

\begin{macro}{when-let}{bindings \body forms}[cl-ext]
  Creates new variable bindings, and conditionally executes FORMS.

BINDINGS must be either single binding of the form:

 (variable initial-form)

or a list of bindings of the form:

 ((variable-1 initial-form-1)
  (variable-2 initial-form-2)
  ...
  (variable-n initial-form-n))

All initial-forms are executed sequentially in the specified order. Then all
the variables are bound to the corresponding values.

If all variables were bound to true values, then FORMS are executed as an
implicit PROGN.
\end{macro}

\begin{macro}{when-let*}{bindings \body forms}[cl-ext]
  Creates new variable bindings, and conditionally executes FORMS.

BINDINGS must be either single binding of the form:

 (variable initial-form)

or a list of bindings of the form:

 ((variable-1 initial-form-1)
  (variable-2 initial-form-2)
  ...
  (variable-n initial-form-n))

Each initial-form is executed in turn, and the variable bound to the
corresponding value. Initial-form expressions can refer to variables
previously bound by the WHEN-LET*.

Execution of WHEN-LET* stops immediately if any initial-form evaluates to NIL.
If all initial-forms evaluate to true, then FORMS are executed as an implicit
PROGN.
\end{macro}

\section{Reference}
\label{sec:reference}

\begin{specialop}{quote}{thing}
Return VALUE without evaluating it.
\end{specialop}

\begin{specialop}{function}{thing}
  FUNCTION name

Return the lexically apparent definition of the function NAME. NAME may also
be a lambda expression.
\end{specialop}

\begin{accessor}{symbol-value}{symbol}
  Return SYMBOL's current bound value.
\end{accessor}

\begin{accessor}{symbol-function}{symbol}
  Return SYMBOL's current function definition. Settable with SETF.
\end{accessor}

\begin{accessor}{fdefinition}{name}
  Return name's global function definition taking care to respect any
   encapsulations and to return the innermost encapsulated definition.
   This is SETF'able.
\end{accessor}

\begin{function}{boundp}{symbol}
  Return non-NIL if SYMBOL is bound to a value.
\end{function}

\begin{function}{fboundp}{name}
  Return true if name has a global function definition.
\end{function}

\begin{function}{special-operator-p}{symbol}
  If the symbol globally names a special form, return T, otherwise NIL.
\end{function}

\section{Assignment}
\label{sec:assignment}

See also \macr{setf}.

\begin{specialop}{setq}{\rest pairs}
\end{specialop}

\begin{macro}{psetq}{\rest pairs}
  PSETQ {var value}*
   Set the variables to the values, like SETQ, except that assignments
   happen in parallel, i.e. no assignments take place until all the
   forms have been evaluated.
\end{macro}

\begin{function}{set}{symbol new-value}
  Set SYMBOL's value cell to NEW-VALUE.
\end{function}

\section{Generalized variables}
\label{sec:gener-vari}

\begin{macro}{setf}{\rest args \env env}
  Takes pairs of arguments like SETQ. The first is a place and the second
  is the value that is supposed to go into that place. Returns the last
  value. The place argument may be any of the access forms for which SETF
  knows a corresponding setting form.
\end{macro}

\begin{macro}{psetf}{\rest args \env env}
  This is to SETF as PSETQ is to SETQ. Args are alternating place
  expressions and values to go into those places. All of the subforms and
  values are determined, left to right, and only then are the locations
  updated. Returns NIL.
\end{macro}

\begin{macro}{shiftf}{\whole form \rest args \env env}
  One or more SETF-style place expressions, followed by a single
   value expression. Evaluates all of the expressions in turn, then
   assigns the value of each expression to the place on its left,
   returning the value of the leftmost.
\end{macro}

\begin{macro}{rotatef}{\rest args \env env}
  Takes any number of SETF-style place expressions. Evaluates all of the
   expressions in turn, then assigns to each place the value of the form to
   its right. The rightmost form gets the value of the leftmost.
   Returns NIL.
\end{macro}

\begin{macro}{define-modify-macro}{name lambda-list function \op doc-string}
  Creates a new read-modify-write macro like PUSH or INCF.
\end{macro}

\begin{macro}{defsetf}{access-fn \rest rest}
  Associates a SETF update function or macro with the specified access
  function or macro. The format is complex. See the manual for details.
\end{macro}

\begin{macro}{define-setf-expander}{access-fn lambda-list \body body}
  Syntax like DEFMACRO, but creates a setf expander function. The body
  of the definition must be a form that returns five appropriate values.
\end{macro}

\begin{function}{get-setf-expansion}{form \op environment}
  Return five values needed by the SETF machinery: a list of temporary
   variables, a list of values with which to fill them, a list of temporaries
   for the new values, the setting function, and the accessing function.
\end{function}

\section{Functions and function invocation}
\label{sec:function-invocation}

\begin{function}{apply}{function arg \rest arguments}
  Apply FUNCTION to a list of arguments produced by evaluating ARGUMENTS in
  the manner of LIST*. That is, a list is made of the values of all but the
  last argument, appended to the value of the last argument, which must be a
  list.
\end{function}

\begin{function}{funcall}{function \rest arguments}
  Call FUNCTION with the given ARGUMENTS.
\end{function}

\begin{function}{funcall-if}{function argument}[cl-ext]

\end{function}

\begin{constant}{call-arguments-limit}{}
  
\end{constant}

\begin{macro}{defun}{\env env name args \body body}
  Define a function at top level.
\end{macro}

\begin{macro}{lambda}{\whole whole args \body body}
  
\end{macro}

\begin{specialop}{flet}{definitions \body body}
  FLET ({(name lambda-list declaration* form*)}*) declaration* body-form*

Evaluate the BODY-FORMS with local function definitions. The bindings do
not enclose the definitions; any use of NAME in the FORMS will refer to the
lexically apparent function definition in the enclosing environment.
\end{specialop}

\begin{specialop}{labels}{definitions \body body}
  LABELS ({(name lambda-list declaration* form*)}*) declaration* body-form*

Evaluate the BODY-FORMS with local function definitions. The bindings enclose
the new definitions, so the defined functions can call themselves or each
other.
\end{specialop}

\begin{function}{complement}{function}
  Return a new function that returns T whenever FUNCTION returns NIL and
   NIL whenever FUNCTION returns non-NIL.
\end{function}

\begin{function}{constantly}{value}
  Return a function that always returns VALUE.
\end{function}

\begin{function}{identity}{thing}
  This function simply returns what was passed to it.
\end{function}

\begin{function}{function-lambda-expression}{fun}
  Return (VALUES DEFINING-LAMBDA-EXPRESSION CLOSURE-P NAME), where
  DEFINING-LAMBDA-EXPRESSION is NIL if unknown, or a suitable argument
  to COMPILE otherwise, CLOSURE-P is non-NIL if the function's definition
  might have been enclosed in some non-null lexical environment, and
  NAME is some name (for debugging only) or NIL if there is no name.
\end{function}

\begin{constant}{lambda-parameters-limit}{}
  
\end{constant}

\section{Undefining variables, functions, and classes}
\label{sec:undef-vari-funct}

\begin{function}{makunbound}{symbol}
  Make SYMBOL unbound, removing any value it may currently have.
\end{function}

\begin{function}{fmakunbound}{name}
  Make NAME have no global function definition.
\end{function}

\section{Simple sequencing}
\label{sec:simple-sequencing}

\begin{specialop}{progn}{\rest forms}
  PROGN form*

Evaluates each FORM in order, returning the values of the last form. With no
forms, returns NIL.
\end{specialop}

\begin{macro}{prog1}{result \body body}
  
\end{macro}

\begin{macro}{prog2}{form1 result \body body}
  
\end{macro}

\section{Macros}
\label{sec:macros-1}

\begin{macro}{defmacro}{name lambda-list \rest body}
  
\end{macro}

\begin{macro}{define-compiler-macro}{name lambda-list \body body}
  Define a compiler-macro for NAME.
\end{macro}

\begin{macro}{define-symbol-macro}{name expansion}
  
\end{macro}

\begin{specialop}{macrolet}{definitions \rest body}
  MACROLET ({(name lambda-list form*)}*) body-form*

Evaluate the BODY-FORMS in an environment with the specified local macros
defined. Name is the local macro name, LAMBDA-LIST is a DEFMACRO style
destructuring lambda list, and the FORMS evaluate to the expansion.
\end{specialop}

\begin{specialop}{symbol-macrolet}{macrobindings \body body}
  SYMBOL-MACROLET ({(name expansion)}*) decl* form*

Define the NAMES as symbol macros with the given EXPANSIONS. Within the
body, references to a NAME will effectively be replaced with the EXPANSION.
\end{specialop}

\begin{constant}{lambda-list-keywords}{}
  
\end{constant}

\begin{macro}{destructuring-bind}{lambda-list expression \body body}
  Bind the variables in LAMBDA-LIST to the corresponding values in the
tree structure resulting from the evaluation of EXPRESSION.
\end{macro}

\section{Conditionals}
\label{sec:conditionals}

\begin{specialop}{if}{test then \op else}
  IF predicate then [else]

If PREDICATE evaluates to false, evaluate THEN and return its values,
otherwise evaluate ELSE and return its values. ELSE defaults to NIL.
\end{specialop}

\begin{macro}{if-bind}{var test \body then/else}[cl-ext]
  Anaphoric IF control structure.

VAR (a symbol) will be bound to the primary value of TEST. If
TEST returns a true value then THEN will be executed, otherwise
ELSE will be executed.
\end{macro}

\begin{macro}{aif}{test then \op else}[cl-ext]
  Just like IF-BIND but the var is always IT. Very useful with
  functions like GETHASH.
\end{macro}

\begin{macro}{cond}{\rest clauses}
  
\end{macro}

\begin{macro}{acond}{\rest clauses}[cl-ext]
  Just like cond-bind except the var is automatically IT.
\end{macro}

\begin{macro}{cond-bind}{var \body clauses}[cl-ext]
  Just like COND but VAR will be bound to the result of the
  condition in the clause when executing the body of the clause.
\end{macro}

\begin{macro}{when}{test \body forms}
  If the first argument is true, the rest of the forms are
evaluated as a PROGN.
\end{macro}

\begin{macro}{awhen}{test \body body}[cl-ext]
  Just like when expect the symbol IT will be
  bound to the result of TEST in BODY.
\end{macro}

\begin{macro}{when-bind}{var test \body body}[cl-ext]
  Just like when except VAR will be bound to the
  result of TEST in BODY.
\end{macro}

\begin{macro}{unless}{test \body forms}
  If the first argument is not true, the rest of the forms are
evaluated as a PROGN.
\end{macro}

\begin{macro}{while*}{test \body body}[cl-ext]
  Repeat BODY while TEST is true. You may exit the loop with
  (RETURN-FROM WHILE).
  \begin{devnote}
    The original name in arnesi is while, but the symbol conflicts
    with while in iterate.
  \end{devnote}
\end{macro}

\begin{macro}{whichever}{\rest possibilities \env env}[cl-ext]
  Evaluates exactly one of POSSIBILITIES, chosen at random.
\end{macro}

\begin{macro}{case}{keyform \body cases}
  CASE Keyform {({(Key*) | Key} Form*)}*
  Evaluates the Forms in the first clause with a Key EQL to the value of
  Keyform. If a singleton key is T then the clause is a default clause.
\end{macro}

\begin{macro}{list-match-case}{target \body clauses}[cl-ext]
  
\end{macro}

\begin{macro}{awhile}{test \body body}[cl-ext]
  Just like WHILE, but the result of TEST is bound to IT.

You may exit the loop with (RETURN-FROM AWHILE).
\end{macro}

\begin{macro}{until*}{test \body body}[cl-ext]
  Repeat BODY until TEST is false. You may exit the loop with
  (RETURN-FROM UNTIL).
  \begin{devnote}
    The original name in arnesi is until, but the symbol conflicts
    with while in iterate.
  \end{devnote}
\end{macro}

\begin{macro}{ccase}{keyform \body cases}
  CCASE Keyform {({(Key*) | Key} Form*)}*
  Evaluates the Forms in the first clause with a Key EQL to the value of
  Keyform. If none of the keys matches then a correctable error is
  signalled.
\end{macro}

\begin{macro}{typecase}{keyform \body cases}
  TYPECASE Keyform {(Type Form*)}*
  Evaluates the Forms in the first clause for which TYPEP of Keyform and Type
  is true.
\end{macro}

\begin{macro}{ctypecase}{keyform \body cases}
  CTYPECASE Keyform {(Type Form*)}*
  Evaluates the Forms in the first clause for which TYPEP of Keyform and Type
  is true. If no form is satisfied then a correctable error is signalled.
\end{macro}

\begin{macro}{ecase}{keyform \body cases}
  ECASE Keyform {({(Key*) | Key} Form*)}*
  Evaluates the Forms in the first clause with a Key EQL to the value of
  Keyform. If none of the keys matches then an error is signalled.
\end{macro}

\begin{macro}{etypecase}{keyform \body cases}
  ETYPECASE Keyform {(Type Form*)}*
  Evaluates the Forms in the first clause for which TYPEP of Keyform and Type
  is true. If no form is satisfied then an error is signalled.
\end{macro}

\begin{macro}{switch}{\whole whole object \body clauses}[cl-ext]
  Evaluates first matching clause, returning its values, or evaluates and
returns the values of DEFAULT if no keys match.
\end{macro}

\begin{macro}{cswitch}{\whole whole object \body clauses}[cl-ext]
  Like SWITCH, but signals a continuable error if no key matches.
\end{macro}

\begin{macro}{eswitch}{\whole whole object \body clauses}[cl-ext]
  Like SWITCH, but signals an error if no key matches.
\end{macro}

\begin{macro}{and}{\rest forms}
  
\end{macro}

\begin{macro}{aand}{\rest forms}[cl-ext]
  
\end{macro}

\begin{macro}{and-bind}{var \rest forms}[cl-ext]
  
\end{macro}

\begin{macro}{or}{\rest forms}
  
\end{macro}

\begin{macro}{xor}{\rest datums}[cl-ext]
  Evaluates its argument one at a time, from left to right. If more then one
argument evaluates to a true value no further DATUMS are evaluated, and NIL is
returned as both primary and secondary value. If exactly one argument
evaluates to true, its value is returned as the primary value after all the
arguments have been evaluated, and T is returned as the secondary value. If no
arguments evaluate to true NIL is retuned as primary, and T as secondary
value.
\end{macro}

\begin{specialop}{progv}{vars vals \body body}
  
\end{specialop}

\begin{specialop}{locally}{\body body}
  LOCALLY declaration* form*

Sequentially evaluate the FORMS in a lexical environment where the
DECLARATIONS have effect. If LOCALLY is a top level form, then the FORMS are
also processed as top level forms.
\end{specialop}

\section{Blocks and exits}
\label{sec:blocks-exits}

\begin{specialop}{block}{name \rest forms}
  BLOCK name form*

Evaluate the FORMS as a PROGN. Within the lexical scope of the body,
RETURN-FROM can be used to exit the form.
\end{specialop}

\begin{macro}{return}{\op value}
  
\end{macro}

\begin{specialop}{return-from}{name \op value}
  RETURN-FROM block-name value-form

Evaluate the VALUE-FORM, returning its values from the lexically enclosing
block BLOCK-NAME. This is constrained to be used only within the dynamic
extent of the block.
\end{specialop}

\section{Multiple values}
\label{sec:multiple-values}

\begin{accessor}{values}{\rest values}
  Return all arguments, in order, as values.
\end{accessor}

\begin{constant}{multiple-values-limit}{}
  
\end{constant}

\begin{function}{values-list}{list}
  Return all of the elements of LIST, in order, as values.
\end{function}

\begin{macro}{multiple-value-list}{value-form}
  
\end{macro}

\begin{specialop}{multiple-value-call}{fun \rest args}
  MULTIPLE-VALUE-CALL function values-form*

Call FUNCTION, passing all the values of each VALUES-FORM as arguments,
values from the first VALUES-FORM making up the first argument, etc.
\end{specialop}

\begin{specialop}{multiple-value-prog1}{values-form \rest forms}
  MULTIPLE-VALUE-PROG1 values-form form*

Evaluate VALUES-FORM and then the FORMS, but return all the values of
VALUES-FORM.
\end{specialop}

\begin{macro}{multiple-value-bind}{vars value-form \body body}
  
\end{macro}

\begin{macro}{multiple-value-setq}{vars value-form}
  
\end{macro}

\begin{macro}{nth-value}{n form}
  Evaluate FORM and return the Nth value (zero based). This involves no
  consing when N is a trivial constant integer.
\end{macro}

\begin{macro}{nth-value-or}{nth-value \body forms}[cl-ext]
  Evaluates FORM arguments one at a time, until the NTH-VALUE returned by one
of the forms is non-NIL. It then returns all the values returned by evaluating
that form. If none of the forms return a non-nil nth value, this form returns
NIL.
\end{macro}

\section{Dynamic non-local exits}
\label{sec:dynamic-non-local}

\begin{specialop}{catch}{tag \body body}
  CATCH tag form*

Evaluate TAG and instantiate it as a catcher while the body forms are
evaluated in an implicit PROGN. If a THROW is done to TAG within the dynamic
scope of the body, then control will be transferred to the end of the body and
the thrown values will be returned.
\end{specialop}

\begin{specialop}{throw}{tag result}
  THROW tag form

Do a non-local exit, return the values of FORM from the CATCH whose tag is EQ
to TAG.
\end{specialop}

\begin{specialop}{unwind-protect}{protected \body cleanup}
  UNWIND-PROTECT protected cleanup*

Evaluate the form PROTECTED, returning its values. The CLEANUP forms are
evaluated whenever the dynamic scope of the PROTECTED form is exited (either
due to normal completion or a non-local exit such as THROW).
\end{specialop}

\begin{macro}{unwind-protect-case}{\op protected-form \body clauses}[cl-ext]
  Like CL:UNWIND-PROTECT, but you can specify the circumstances that
the cleanup CLAUSES are run.

ABORT-FLAG is the name of a variable that will be bound to T in
CLAUSES if the PROTECTED-FORM aborted preemptively, and to NIL
otherwise.
\end{macro}


\chapter{Iteration}
\label{cha:iteration}

See also mapping (section \ref{sec:mapping}) and filtering (section
\ref{sec:filt-modify-sequ}).

\section{Simple iteration}
\label{sec:simple-iteration}

See also \macr{do-range}

\begin{macro}{dolist}{var \body body \env env}
  
\end{macro}

\begin{macro}{dotimes}{var \body body}
  
\end{macro}

\begin{macro}{dolist*}{iterator \body body}[cl-ext]
  Like DOLIST but destructuring-binds the elements of LIST.

If ITERATOR is a symbol then dolist* is just like dolist EXCEPT
that it creates a fresh binding.
\end{macro}

\section{Loop}
\label{sec:loop}

\begin{macro}{loop}{\env env \rest keywords-and-forms}
  
\end{macro}

\section{Iterate}
\label{sec:iterate}

Iterate was written originaly by Jonathan Amsterdam and was adapted to
to ANSI Common Lisp in 2003 by Andreas Fuchs. Andreas also wrote the
the ITERATE driver for postgresql queries via PG (http://cliki.net/pg).

\section{General iteration}
\label{sec:general-iteration}

\begin{macro}{do}{varlist endlist \body body}
  DO ({(Var [Init] [Step])}*) (Test Exit-Form*) Declaration* Form*
  Iteration construct. Each Var is initialized in parallel to the value of the
  specified Init form. On subsequent iterations, the Vars are assigned the
  value of the Step form (if any) in parallel. The Test is evaluated before
  each evaluation of the body Forms. When the Test is true, the Exit-Forms
  are evaluated as a PROGN, with the result being the value of the DO. A block
  named NIL is established around the entire expansion, allowing RETURN to be
  used as an alternate exit mechanism.
\end{macro}

\begin{macro}{do*}{varlist endlist \body body}
  DO* ({(Var [Init] [Step])}*) (Test Exit-Form*) Declaration* Form*
  Iteration construct. Each Var is initialized sequentially (like LET*) to the
  value of the specified Init form. On subsequent iterations, the Vars are
  sequentially assigned the value of the Step form (if any). The Test is
  evaluated before each evaluation of the body Forms. When the Test is true,
  the Exit-Forms are evaluated as a PROGN, with the result being the value
  of the DO. A block named NIL is established around the entire expansion,
  allowing RETURN to be used as an laternate exit mechanism.
\end{macro}

\section{The program feature}
\label{sec:program-feature}

\begin{specialop}{tagbody}{\rest statements}
  TAGBODY {tag | statement}*

Define tags for use with GO. The STATEMENTS are evaluated in order ,skipping
TAGS, and NIL is returned. If a statement contains a GO to a defined TAG
within the lexical scope of the form, then control is transferred to the next
statement following that tag. A TAG must an integer or a symbol. A STATEMENT
must be a list. Other objects are illegal within the body.
\end{specialop}

\begin{macro}{prog}{varlist \body body-decls}
  
\end{macro}

\begin{macro}{prog*}{varlist \body body-decls}
  
\end{macro}

\begin{specialop}{go}{tag}
  GO tag

Transfer control to the named TAG in the lexically enclosing TAGBODY. This is
constrained to be used only within the dynamic extent of the TAGBODY.
\end{specialop}

\chapter{Object oriented programming}
\label{cha:object-orient-progr}

See also \genfunr{print-object}.

\section{Classes}
\label{sec:classes}

\begin{macro}{defclass}{\env env name direct-superclasses direct-slots \rest options}
  
\end{macro}

\begin{macro}{defclass-struct}{name-and-options supers \rest slots}[cl-ext]
  Define a class in a similar way structures are defined

NAME-AND-OPTIONS:

  name-symbol |
  ( name-symbol [ (:conc-name conc-name ) ]
                [ (:predicate predicate-name ) ]
                class-option* )

SUPERS - a list of super classes passed directly to DEFCLASS.

SLOTS - a list of slot forms:

  name |
  ( name [ init-arg ] [ slot-options* ] )
\end{macro}

\begin{accessor}{find-class}{symbol \op errorp environment}
  
\end{accessor}

\begin{generic}{class-name}{class}
  
\end{generic}

\begin{function}{class-of}{x}
  
\end{function}

\begin{function}{class-name-of}{obj}[cl-ext]
  
\end{function}

\begin{generic}{change-class}{instance new-class-name \rest initargs \akeys}
  
\end{generic}

\subsection{Class instances}
\label{sec:class-instances}

\begin{generic}{make-instance}{class \rest initargs \akeys}
  
\end{generic}

\begin{generic}{reinitialize-instance}{gf \rest args \key
    direct-superclasses lambda-list argument-precedence-order \akeys}
  
\end{generic}

\begin{generic}{make-instances-obsolete}{class}
  
\end{generic}

\begin{generic}{initialize-instance}{gf \key lambda-list argument-precedence-order \akeys}
  
\end{generic}

\begin{generic}{update-instance-for-different-class}{previous current \rest initargs}
  
\end{generic}

\begin{generic}{update-instance-for-redefined-class}{instance added-slots discarded-slots property-list \rest initargs}
  
\end{generic}

\begin{generic}{allocate-instance}{class \rest initargs}
  
\end{generic}

\subsection{Class slots}
\label{sec:class-slots}

\begin{function}{slot-exists-p}{object slot-name}
  
\end{function}

\begin{function}{slot-boundp}{object slot-name}
  
\end{function}

\begin{function}{slot-value}{object slot-name}
  
\end{function}

\begin{function}{slot-makunbound}{object slot-name}
  
\end{function}

\begin{macro}{with-slots}{slots instance \body body}
  
\end{macro}

\begin{macro}{with-accessors}{slots instance \body body}
  
\end{macro}

\begin{macro}{with-accessors*}{accessor-names object \body body}
  Just like WITH-ACCESSORS, but if the slot-entry is a symbol assume
  the variable and accessor name are the same.
\end{macro}

\begin{generic}{slot-missing}{class instance slot-name operation \op new-value}
  
\end{generic}

\begin{generic}{slot-unbound}{class instance slot-name}
  
\end{generic}

\begin{generic}{shared-initialize}{generic-function slot-names \key
    method-combination method-class documentation declarations
    argument-precedence-order lambda-list name slot-definition
    slot-name definition-source direct-default-initargs direct-slots
    direct-superclasses force type protocol allocation
    allocation-class qualifiers specializers function (method-cell
    method-cell) \akeys}
\end{generic}

\begin{function}{class-slot-list}{class \op all}[cl-ext]
  Return the list of slots of a CLASS. CLASS can be a symbol, a class
  object (as returned by \funr{class-of}) or an instance of a class.
  If the second optional argument ALL is non-NIL (default), all slots
  are returned, otherwise only the slots with :allocation type
  :instance are returned.
\end{function}

\begin{function}{class-slot-initargs}{class \op all}[cl-ext]
  Return the list of initargs of a CLASS. CLASS can be a symbol, a
  class object (as returned by \funr{class-of}) or an instance of a
  class. If the second optional argument ALL is non-NIL (default),
  initargs for all slots are returned, otherwise only the slots with
  :allocation type :instance are returned.
\end{function}

\begin{function}{structure-slots}{struct}[cl-ext]
  Return the list of structure slot names.
\end{function}

\begin{function}{structure-keyword-constructor}{struct}[cl-ext]
  Return the structure keyword constructor name.
\end{function}

\begin{function}{structure-boa-constructors}{struct}[cl-ext]
  Return the list of structure BOA constructor names.
\end{function}

\begin{function}{structure-copier}{struct}[cl-ext]
  Return the structure copier name.  
\end{function}

\begin{function}{structure-predicate}{struct}[cl-ext]
  Return the structure predicate name.
\end{function}

\subsection{Generic functions and methods}
\label{sec:generic-functions}

\begin{function}{generic-method-p}{}
  
\end{function}

\begin{macro}{defgeneric}{fun-name lambda-list \body options}
  
\end{macro}

\begin{function}{ensure-generic-function}{fun-name \rest all-keys \key environment source-location \akeys}
  
\end{function}

\begin{macro}{defmethod}{\rest args}
  
\end{macro}

\begin{generic}{add-method}{generic-function method}
  
\end{generic}

\begin{generic}{remove-method}{generic-function method}
  
\end{generic}

\begin{generic}{find-method}{generic-function qualifiers specializers \op errorp}
  
\end{generic}

\begin{generic}{compute-applicable-methods}{generic-function arguments}
  
\end{generic}

\begin{function}{call-next-method}{\rest args}
  
\end{function}

\begin{generic}{no-applicable-method}{generic-function \rest args}
  
\end{generic}

\begin{generic}{no-next-method}{generic-function method \rest args}
  
\end{generic}

\begin{function}{invalid-method-error}{method format-control \rest format-arguments}
  
\end{function}

\begin{function}{method-combination-error}{format-control \rest format-arguments}
  
\end{function}

\begin{generic}{function-keywords}{method}
  
\end{generic}

\begin{generic}{method-qualifiers}{m}
  
\end{generic}

\subsection{Method combination}
\label{sec:method-combination}

\begin{macro}{define-method-combination}{\whole form \rest args}
  
\end{macro}

\begin{macro}{call-method}{method \op next-method-list}
  
\end{macro}



\chapter{Types}
\label{cha:types}

Se also Declarations, 

\section{Types and Classes}
\label{sec:types-classes}

For any class there is always a type with the same name.

\begin{function}{typep}{object type \op environment}
  Is OBJECT of type TYPE?
\end{function}

\begin{function}{subtypep}{type1 type2 \op environment}
  Return two values indicating the relationship between type1 and type2.
  If values are T and T, type1 definitely is a subtype of type2.
  If values are NIL and T, type1 definitely is not a subtype of type2.
  If values are NIL and NIL, it couldn't be determined.
\end{function}

\begin{function}{type=}{type1 type2}[cl-ext]
  Returns a primary value of T is TYPE1 and TYPE2 are the same type,
and a secondary value that is true is the type equality could be reliably
determined: primary value of NIL and secondary value of T indicates that the
types are not equivalent.
\end{function}

\begin{function}{coerce}{object output-type-spec}
  Coerce the Object to an object of type Output-Type-Spec.
\end{function}

\begin{macro}{coercef}{place type-spec \env env}[cl-ext]
  Modify-macro for COERCE.
\end{macro}

\begin{function}{type-of}{object}
  Return the type of OBJECT.
\end{function}

\begin{function}{of-type}{type}[cl-ext]
  Returns a function of one argument, which returns true when its argument is
of TYPE.
\end{function}

\begin{macro}{check-type}{place type \op type-string \env env}
  Signal a restartable error of type TYPE-ERROR if the value of PLACE
is not of the specified type. If an error is signalled and the restart
is used to return, this can only return if the STORE-VALUE restart is
invoked. In that case it will store into PLACE and start over.
\end{macro}

\begin{macro}{deftype}{name lambda-list \body body}
  Define a new type, with syntax like DEFMACRO.
\end{macro}

\section{Sub-interval Numerical Types}
\label{sec:sub-interv-numer}

Sub-interval numerical types is described in
\cite{antoniotti08:subinterval}.

\begin{type}{negative-double-float}{}[cl-ext]
  
\end{type}

\begin{type}{negative-fixnum}{}[cl-ext]
  
\end{type}

\begin{type}{negative-float}{}[cl-ext]
  
\end{type}

\begin{type}{negative-integer}{}[cl-ext]
  
\end{type}

\begin{type}{negative-long-float}{}[cl-ext]
  
\end{type}

\begin{type}{negative-rational}{}[cl-ext]
  
\end{type}

\begin{type}{negative-real}{}[cl-ext]
  
\end{type}

\begin{type}{negative-short-float}{}[cl-ext]
  
\end{type}

\begin{type}{negative-single-float}{}[cl-ext]
  
\end{type}

\begin{type}{non-negative-double-float}{}[cl-ext]
  
\end{type}

\begin{type}{non-negative-fixnum}{}[cl-ext]
  
\end{type}

\begin{type}{non-negative-float}{}[cl-ext]
  
\end{type}

\begin{type}{non-negative-integer}{}[cl-ext]
  
\end{type}

\begin{type}{non-negative-long-float}{}[cl-ext]
  
\end{type}

\begin{type}{non-negative-rational}{}[cl-ext]
  
\end{type}

\begin{type}{non-negative-real}{}[cl-ext]
  
\end{type}

\begin{type}{non-negative-short-float}{}[cl-ext]
  
\end{type}

\begin{type}{non-negative-single-float}{}[cl-ext]
  
\end{type}

\begin{type}{non-positive-double-float}{}[cl-ext]
  
\end{type}

\begin{type}{non-positive-fixnum}{}[cl-ext]
  
\end{type}

\begin{type}{non-positive-float}{}[cl-ext]
  
\end{type}

\begin{type}{non-positive-integer}{}[cl-ext]
  
\end{type}

\begin{type}{non-positive-long-float}{}[cl-ext]
  
\end{type}

\begin{type}{non-positive-rational}{}[cl-ext]
  
\end{type}

\begin{type}{non-positive-real}{}[cl-ext]
  
\end{type}

\begin{type}{non-positive-short-float}{}[cl-ext]
  
\end{type}

\begin{type}{non-positive-single-float}{}[cl-ext]
  
\end{type}

\begin{type}{positive-double-float}{}[cl-ext]
  
\end{type}

\begin{type}{positive-fixnum}{}[cl-ext]
  
\end{type}

\begin{type}{positive-float}{}[cl-ext]
  
\end{type}

\begin{type}{positive-integer}{}[cl-ext]
  
\end{type}

\begin{type}{positive-long-float}{}[cl-ext]
  
\end{type}

\begin{type}{positive-rational}{}[cl-ext]
  
\end{type}

\begin{type}{positive-real}{}[cl-ext]
  
\end{type}

\begin{type}{positive-short-float}{}[cl-ext]
  
\end{type}

\begin{type}{positive-single-float}{}[cl-ext]
  
\end{type}

\begin{type}{array-index}{}[cl-ext]
  
\end{type}

\begin{type}{array-length}{}[cl-ext]
  
\end{type}



\chapter{Packages and Symbols}
\label{cha:packages-symbols}

\section{Predicates}
\label{sec:predicates}

\begin{function}{symbolp}{object}
  Return true if OBJECT is a SYMBOL, and NIL otherwise.
\end{function}

\begin{function}{packagep}{object}
  
\end{function}

\begin{function}{keywordp}{object}
  Return true if Object is a symbol in the "KEYWORD" package.
\end{function}

\section{Packages}
\label{sec:packages}

\begin{variable}{*package*}{}
  
\end{variable}

\begin{macro}{defpackage}{package \rest options}
  Defines a new package called PACKAGE. Each of OPTIONS should be one of the
   following: 
    (NICKNAMES {package-name}*)
    (SIZE <integer>)
    (SHADOW {symbol-name}*)
    (SHADOWING-IMPORT-FROM <package-name> {symbol-name}*)
    (USE {package-name}*)
    (IMPORT-FROM <package-name> {symbol-name}*)
    (INTERN {symbol-name}*)
    (EXPORT {symbol-name}*)
    (IMPLEMENT {package-name}*)
    (LOCK boolean)
    (DOCUMENTATION doc-string)
   All options except SIZE, LOCK, and :DOCUMENTATION can be used multiple
   times.
\end{macro}

\begin{function}{make-package}{name \key use nicknames internal-symbols external-symbols}
  Make a new package having the specified NAME, NICKNAMES, and USE
list. :INTERNAL-SYMBOLS and :EXTERNAL-SYMBOLS are estimates for the number of
internal and external symbols which will ultimately be present in the package.
The default value of USE is implementation-dependent, and in this
implementation it is NIL.
\end{function}

\begin{function}{rename-package}{package name \op nicknames}
  Changes the name and nicknames for a package.
\end{function}

\begin{macro}{in-package}{string-designator}
  
\end{macro}

\begin{function}{use-package}{packages-to-use \op package}
  Add all the PACKAGES-TO-USE to the use list for PACKAGE so that the
external symbols of the used packages are accessible as internal symbols in
PACKAGE.
\end{function}

\begin{function}{unuse-package}{packages-to-unuse \op package}
  Remove PACKAGES-TO-UNUSE from the USE list for PACKAGE.
\end{function}

\begin{function}{package-use-list}{x}
  
\end{function}

\begin{function}{package-used-by-list}{x}
  
\end{function}

\begin{function}{delete-package}{package-designator}
  Delete the package designated by PACKAGE-DESIGNATOR from the package
  system data structures.
\end{function}

\begin{function}{list-all-packages}{}
  Return a list of all existing packages.
\end{function}

\begin{function}{package-name}{package-designator}
  
\end{function}

\begin{function}{package-nicknames}{x}
  
\end{function}

\begin{function}{find-package}{package-designator}
  
\end{function}

\begin{function}{find-all-symbols}{string-or-symbol}
  Return a list of all symbols in the system having the specified name.
\end{function}

\begin{function}{intern}{name \op package}
  Return a symbol in PACKAGE having the specified NAME, creating it
  if necessary.
\end{function}

\begin{function}{intern-concat}{string-designators \op package}[cl-ext]
  
\end{function}

\begin{function}{find-symbol}{name \op package}
  Return the symbol named STRING in PACKAGE. If such a symbol is found
  then the second value is :INTERNAL, :EXTERNAL or :INHERITED to indicate
  how the symbol is accessible. If no symbol is found then both values
  are NIL.
\end{function}

\begin{function}{unintern}{symbol \op package}
  Makes SYMBOL no longer present in PACKAGE. If SYMBOL was present then T is
returned, otherwise NIL. If PACKAGE is SYMBOL's home package, then it is made
uninterned.
\end{function}

\begin{function}{import}{symbols \op package}
  Make SYMBOLS accessible as internal symbols in PACKAGE. If a symbol is
already accessible then it has no effect. If a name conflict would result from
the importation, then a correctable error is signalled.
\end{function}

\begin{function}{shadowing-import}{symbols \op package}
  Import SYMBOLS into package, disregarding any name conflict. If
  a symbol of the same name is present, then it is uninterned.
\end{function}

\begin{function}{shadow}{symbols \op package}
  Make an internal symbol in PACKAGE with the same name as each of the
specified SYMBOLS. If a symbol with the given name is already present in
PACKAGE, then the existing symbol is placed in the shadowing symbols list if
it is not already present.
\end{function}

\begin{function}{package-shadowing-symbols}{x}
  
\end{function}

\begin{function}{export}{symbols \op package}
  Exports SYMBOLS from PACKAGE, checking that no name conflicts result.
\end{function}

\begin{function}{unexport}{symbols \op package}
  Makes SYMBOLS no longer exported from PACKAGE.
\end{function}

\begin{macro}{do-symbols}{var \body body-decls}
  DO-SYMBOLS (VAR [PACKAGE [RESULT-FORM]]) {DECLARATION}* {TAG | FORM}*
   Executes the FORMs at least once for each symbol accessible in the given
   PACKAGE with VAR bound to the current symbol.
\end{macro}

\begin{macro}{do-external-symbols}{var \body body-decls}
  DO-EXTERNAL-SYMBOLS (VAR [PACKAGE [RESULT-FORM]]) {DECL}* {TAG | FORM}*
   Executes the FORMs once for each external symbol in the given PACKAGE with
   VAR bound to the current symbol.
\end{macro}

\begin{macro}{do-all-symbols}{var \body body-decls}
  DO-ALL-SYMBOLS (VAR [RESULT-FORM]) {DECLARATION}* {TAG | FORM}*
   Executes the FORMs once for each symbol in every package with VAR bound
   to the current symbol.
\end{macro}

\begin{macro}{with-package-iterator}{mname \body body}
  Within the lexical scope of the body forms, MNAME is defined via macrolet
such that successive invocations of (MNAME) will return the symbols, one by
one, from the packages in PACKAGE-LIST. SYMBOL-TYPES may be any
of :INHERITED :EXTERNAL :INTERNAL.
\end{macro}

\section{Modules}
\label{sec:modules}

\begin{variable}{*modules*}{}
  
\end{variable}

\begin{function}{provide}{module-name}
  Adds a new module name to *MODULES* indicating that it has been loaded.
   Module-name is a string designator
\end{function}

\begin{function}{require}{module-name \op pathnames}
  Loads a module, unless it already has been loaded. PATHNAMES, if supplied,
   is a designator for a list of pathnames to be loaded if the module
   needs to be. If PATHNAMES is not supplied, functions from the list
   *MODULE-PROVIDER-FUNCTIONS* are called in order with MODULE-NAME
   as an argument, until one of them returns non-NIL.  User code is
   responsible for calling PROVIDE to indicate a successful load of the
   module.
\end{function}

\section{Symbols}
\label{sec:symbols}

See also \accr{symbol-value} and \accr{symbol-function}.

\subsection{Print name}
\label{sec:print-name}

\begin{function}{symbol-name}{symbol}
  Return SYMBOL's name as a string.
\end{function}

\subsection{Creating symbols}
\label{sec:creating-symbols}

\begin{function}{make-symbol}{string}
  Make and return a new symbol with the STRING as its print name.
\end{function}

\begin{function}{ensure-symbol}{name \op package}[cl-ext]
  Returns a symbol with name designated by NAME, accessible in package
designated by PACKAGE. If symbol is not already accessible in PACKAGE, it is
interned there. Returns a secondary value reflecting the status of the symbol
in the package, which matches the secondary return value of INTERN.
\end{function}

\begin{function}{format-symbol}{package control \rest arguments}[cl-ext]
  Constructs a string by applying ARGUMENTS to CONTROL as if by FORMAT, and
then creates a symbol named by that string. If PACKAGE is NIL, returns an
uninterned symbol, if package is T, returns a symbol interned in the current
package, and otherwise returns a symbol interned in the package designated by
PACKAGE.
\end{function}

\begin{function}{symbolicate}{\rest things}[cl-ext]
  Concatenate together the names of some strings and symbols,
producing a symbol in the current package.
\end{function}

\begin{function}{make-keyword}{name}[cl-ext]
  Interns the string designated by NAME in the KEYWORD package.
\end{function}

\begin{function}{copy-symbol}{symbol \op copy-props \aux new-symbol}
  Make and return a new uninterned symbol with the same print name
  as SYMBOL. If COPY-PROPS is false, the new symbol is neither bound
  nor fbound and has no properties, else it has a copy of SYMBOL's
  function, value and property list.
\end{function}

\begin{function}{gensym}{\op thing}
  Creates a new uninterned symbol whose name is a prefix string (defaults
   to "G"), followed by a decimal number. Thing, when supplied, will
   alter the prefix if it is a string, or be used for the decimal number
   if it is a number, of this symbol. The default value of the number is
   the current value of *gensym-counter* which is incremented each time
   it is used.
\end{function}

\begin{function}{make-gensym}{name}[cl-ext]
  If NAME is a non-negative integer, calls GENSYM using it. Otherwise NAME
must be a string designator, in which case calls GENSYM using the designated
string as the argument.
\end{function}

\begin{function}{make-gensym-list}{length \op x}[cl-ext]
  Returns a list of LENGTH gensyms, each generated as if with a call to MAKE-GENSYM,
using the second (optional, defaulting to "G") argument.
\end{function}

\begin{variable}{*gensym-counter*}{}
  
\end{variable}

\begin{function}{gentemp}{\op prefix package}
  Creates a new symbol interned in package PACKAGE with the given PREFIX.
\end{function}

\begin{function}{symbol-package}{symbol}
  Return the package SYMBOL was interned in, or NIL if none.
\end{function}



\chapter{Conditions, restarts and Errors}
\label{cha:cond-rest-errors}

\begin{macro}{define-condition}{name \rest \rest \body options}
  DEFINE-CONDITION Name (Parent-Type*) (Slot-Spec*) Option*
   Define NAME as a condition type. This new type inherits slots and its
   report function from the specified PARENT-TYPEs. A slot spec is a list of:
     (slot-name :reader <rname> :initarg <iname> {Option Value}*

   The DEFINE-CLASS slot options :ALLOCATION, :INITFORM, [slot] :DOCUMENTATION
   and :TYPE and the overall options :DEFAULT-INITARGS and
   [type] :DOCUMENTATION are also allowed.

   The :REPORT option is peculiar to DEFINE-CONDITION. Its argument is either
   a string or a two-argument lambda or function name. If a function, the
   function is called with the condition and stream to report the condition.
   If a string, the string is printed.

   Condition types are classes, but (as allowed by ANSI and not as described in
   CLtL2) are neither STANDARD-OBJECTs nor STRUCTURE-OBJECTs. WITH-SLOTS and
   SLOT-VALUE may not be used on condition objects.
\end{macro}

\begin{function}{make-condition}{type \rest args}
  Make an instance of a condition object using the specified initargs.
\end{function}

\begin{function}{signal}{datum \rest arguments}
  Invokes the signal facility on a condition formed from DATUM and
   ARGUMENTS. If the condition is not handled, NIL is returned. If
   (TYPEP condition *BREAK-ON-SIGNALS*) is true, the debugger is invoked
   before any signalling is done.
\end{function}

\begin{function}{warn}{datum \rest arguments}
  Warn about a situation by signalling a condition formed by DATUM and
   ARGUMENTS. While the condition is being signaled, a MUFFLE-WARNING restart
   exists that causes WARN to immediately return NIL.
\end{function}

\begin{function}{error}{datum \rest arguments}
  Invoke the signal facility on a condition formed from DATUM and ARGUMENTS.
  If the condition is not handled, the debugger is invoked.
\end{function}

\begin{function}{cerror}{continue-string datum \rest arguments}
  
\end{function}

\begin{macro}{ignore-errors}{\rest forms}
  Execute FORMS handling ERROR conditions, returning the result of the last
  form, or (VALUES NIL the-ERROR-that-was-caught) if an ERROR was handled.
\end{macro}

\begin{macro}{ignore-some-conditions}{\rest \body body}[cl-ext]
  Similar to CL:IGNORE-ERRORS but the (unevaluated) CONDITIONS
list determines which specific conditions are to be ignored.
\end{macro}

\begin{function}{invoke-debugger}{condition}
  Enter the debugger.
\end{function}

\begin{macro}{assert}{test-form \op places datum \rest arguments}
  Signals an error if the value of test-form is nil. Continuing from this
   error using the CONTINUE restart will allow the user to alter the value of
   some locations known to SETF, starting over with test-form. Returns NIL.
\end{macro}

\begin{macro}{handler-case}{form \rest cases}
  (HANDLER-CASE form { (type ([var]) body) }* )

Execute FORM in a context with handlers established for the condition types. A
peculiar property allows type to be :NO-ERROR. If such a clause occurs, and
form returns normally, all its values are passed to this clause as if by
MULTIPLE-VALUE-CALL. The :NO-ERROR clause accepts more than one var
specification.
\end{macro}

\begin{macro}{handler-bind}{bindings \body forms}
  (HANDLER-BIND ( {(type handler)}* )  body)

Executes body in a dynamic context where the given handler bindings are in
effect. Each handler must take the condition being signalled as an argument.
The bindings are searched first to last in the event of a signalled
condition.
\end{macro}

\begin{macro}{with-simple-restart}{restart-name \body forms}
  (WITH-SIMPLE-RESTART (restart-name format-string format-arguments)
   body)
   If restart-name is not invoked, then all values returned by forms are
   returned. If control is transferred to this restart, it immediately
   returns the values NIL and T.
\end{macro}

\begin{macro}{restart-case}{expression \body clauses \env env}
  (RESTART-CASE form
   {(case-name arg-list {keyword value}* body)}*)
   The form is evaluated in a dynamic context where the clauses have special
   meanings as points to which control may be transferred (see INVOKE-RESTART).
   When clauses contain the same case-name, FIND-RESTART will find the first
   such clause. If Expression is a call to SIGNAL, ERROR, CERROR or WARN (or
   macroexpands into such) then the signalled condition will be associated with
   the new restarts.
\end{macro}

\begin{macro}{restart-bind}{bindings \body forms}
  Executes forms in a dynamic context where the given restart bindings are
   in effect. Users probably want to use RESTART-CASE. When clauses contain
   the same restart name, FIND-RESTART will find the first such clause.
\end{macro}

\begin{function}{invoke-restart}{restart \rest values}
  Calls the function associated with the given restart, passing any given
   arguments. If the argument restart is not a restart or a currently active
   non-nil restart name, then a CONTROL-ERROR is signalled.
\end{function}

\begin{function}{invoke-restart-interactively}{restart}
  Calls the function associated with the given restart, prompting for any
   necessary arguments. If the argument restart is not a restart or a
   currently active non-NIL restart name, then a CONTROL-ERROR is signalled.
\end{function}

\begin{function}{compute-restarts}{\op condition}
  Return a list of all the currently active restarts ordered from most recently
established to less recently established. If CONDITION is specified, then only
restarts associated with CONDITION (or with no condition) will be returned.
\end{function}

\begin{function}{find-restart}{identifier \op condition}
  Return the first restart identified by IDENTIFIER. If IDENTIFIER is a symbol,
then the innermost applicable restart with that name is returned. If IDENTIFIER
is a restart, it is returned if it is currently active. Otherwise NIL is
returned. If CONDITION is specified and not NIL, then only restarts associated
with that condition (or with no condition) will be returned.
\end{function}

\begin{function}{restart-name}{instance}
  Return the name of the given restart object.
\end{function}

\begin{function}{abort}{\op condition}
  Transfer control to a restart named ABORT, signalling a CONTROL-ERROR if
   none exists.
\end{function}

\begin{function}{muffle-warning}{\op condition}
  Transfer control to a restart named MUFFLE-WARNING, signalling a
   CONTROL-ERROR if none exists.
\end{function}

\begin{function}{continue}{\op condition}
  Transfer control to a restart named CONTINUE, or return NIL if none exists.
\end{function}

\begin{function}{store-value}{value \op condition}
  Transfer control and VALUE to a restart named STORE-VALUE, or return NIL if
   none exists.
\end{function}

\begin{function}{use-value}{value \op condition}
  Transfer control and VALUE to a restart named USE-VALUE, or return NIL if
   none exists.
\end{function}

\begin{macro}{with-condition-restarts}{condition-form restarts-form \body body}
  Evaluates the BODY in a dynamic environment where the restarts in the list
   RESTARTS-FORM are associated with the condition returned by CONDITION-FORM.
   This allows FIND-RESTART, etc., to recognize restarts that are not related
   to the error currently being debugged. See also RESTART-CASE.
\end{macro}

\begin{function}{required-argument}{\op name}[cl-ext]
  Signals an error for a missing argument of NAME. Intended for
use as an initialization form for structure and class-slots, and
a default value for required keyword arguments.
\end{function}

\begin{function}{arithmetic-error-operands}{condition}
  
\end{function}

\begin{function}{arithmetic-error-operation}{condition}
  
\end{function}

\begin{function}{cell-error-name}{condition}
  
\end{function}

\begin{function}{unbound-slot-instance}{condition}
  
\end{function}

\begin{function}{print-not-readable-object}{condition}
  
\end{function}

\begin{function}{package-error-package}{condition}
  
\end{function}

\begin{function}{file-error-pathname}{condition}
  
\end{function}

\begin{function}{stream-error-stream}{condition}
  
\end{function}

\begin{function}{type-error-datum}{condition}
  
\end{function}

\begin{function}{type-error-expected-type}{}
  
\end{function}

\begin{function}{simple-condition-format-arguments}{condition}
  
\end{function}

\begin{function}{simple-condition-format-control}{condition}
  
\end{function}

these functions also have conditions with the same name:

\begin{function}{simple-parse-error}{message \rest args}[cl-ext]
  
\end{function}

\begin{function}{simple-program-error}{message \rest args}[cl-ext]
  
\end{function}

\begin{function}{simple-reader-error}{stream message \rest args}[cl-ext]
  
\end{function}

\begin{function}{simple-style-warning}{message \rest args}[cl-ext]
  
\end{function}

\begin{variable}{*break-on-signals*}{}
  
\end{variable}

\begin{variable}{*debugger-hook*}{}
  
\end{variable}



\chapter{Time and Data}
\label{cha:time-data}

\begin{constant}{internal-time-units-per-second}{}
  
\end{constant}

\begin{function}{get-internal-real-time}{}
  Return the real time ("wallclock time") since startup in the internal
time format. (See INTERNAL-TIME-UNITS-PER-SECOND.)
\end{function}

\begin{function}{get-internal-run-time}{}
  Return the run time used by the process in the internal time format. (See
INTERNAL-TIME-UNITS-PER-SECOND.) This is useful for finding CPU usage.
Includes both "system" and "user" time.
\end{function}

\begin{function}{decode-universal-time}{universal-time \op time-zone}
  Converts a universal-time to decoded time format returning the following
   nine values: second, minute, hour, date, month, year, day of week (0 =
   Monday), T (daylight savings time) or NIL (standard time), and timezone.
   Completely ignores daylight-savings-time when time-zone is supplied.
\end{function}

\begin{function}{encode-universal-time}{second minute hour date month year \op time-zone}
  The time values specified in decoded format are converted to
   universal time, which is returned.
\end{function}

\begin{function}{get-decoded-time}{}
  Return nine values specifying the current time as follows:
   second, minute, hour, date, month, year, day of week (0 = Monday), T
   (daylight savings times) or NIL (standard time), and timezone.
\end{function}

\begin{function}{get-universal-time}{}
  Return a single integer for the current time of day in universal time
format.
\end{function}

\begin{function}{sleep}{n}
  This function causes execution to be suspended for N seconds. N may
  be any non-negative, non-complex number.
\end{function}



\chapter{Environment, Implementation and machine data}
\label{cha:impl-mach-data}

\begin{function}{quit}{\op exit-code}[cl-ext]
  
\end{function}

\begin{function}{getenv}{var}[cl-ext]
  can use setf
\end{function}

\begin{function}{argv}{var}[cl-ext]
  
\end{function}

\begin{function}{function-lambda-list}{function}[cl-ext]
  Return the signature of the function.
\end{function}

\begin{function}{lisp-implementation-type}{}
  
\end{function}

\begin{function}{lisp-implementation-version}{}
  
\end{function}

\begin{function}{machine-instance}{}
  Return a string giving the name of the local machine.
\end{function}

\begin{function}{machine-type}{}
  Return a string describing the type of the local machine.
\end{function}

\begin{function}{machine-version}{}
  Return a string describing the version of the computer hardware we
are running on, or NIL if we can't find any useful information.
\end{function}

\begin{function}{long-site-name}{}
  Return a string with the long form of the site name, or NIL if not known.
\end{function}

\begin{function}{short-site-name}{}
  Return a string with the abbreviated site name, or NIL if not known.
\end{function}

\begin{function}{software-type}{}
  Return a string describing the supporting software.
\end{function}

\begin{function}{software-version}{}
  Return a string describing version of the supporting software, or NIL
  if not available.
\end{function}

\begin{function}{sysinfo}{\op out}[cl-ext]
  Print information about the current computer environment to a
  stream.
\end{function}

\begin{function}{run-prog}{prog \rest opts \key args (wait t) \akeys}[cl-ext]
  Common interface to shell. Does not return anything useful.
\end{function}

\begin{function}{pipe-output}{prog \rest args}[cl-ext]
  Return an output stream which will go to the command.
\end{function}

\begin{function}{pipe-input}{prog \rest args}[cl-ext]
  Return an input stream from which the command output will be read.
\end{function}

\begin{function}{close-pipe}{stream}[cl-ext]
  
\end{function}

\begin{function}{with-open-pipe}{(pipe open) \body body}[cl-ext]
  
\end{function}

\begin{function}{gc}{}[cl-ext]
  Invoke the garbage collector.
\end{function}


\chapter{REPL, Debugging and Profiling}
\label{cha:debugging-profiling}

\section{REPL}
\label{sec:repl}

\begin{variable}{*}{\rest args}
  Return the product of its arguments. With no args, returns 1.
\end{variable}

\begin{variable}{**}{}
  
\end{variable}

\begin{variable}{***}{}
  
\end{variable}

\begin{variable}{+}{\rest args}
  Return the sum of its arguments. With no args, returns 0.
\end{variable}

\begin{variable}{++}{}
  
\end{variable}

\begin{variable}{+++}{}
  
\end{variable}

\begin{variable}{/}{}
  
\end{variable}

\begin{variable}{//}{}
  
\end{variable}

\begin{variable}{///}{}
  
\end{variable}

\begin{variable}{-}{}
  Form currently being evaluated by the REPL.
\end{variable}

\begin{function}{apropos}{string-designator \op package external-only}
  Briefly describe all symbols which contain the specified STRING.
  If PACKAGE is supplied then only describe symbols present in
  that package. If EXTERNAL-ONLY then only describe
  external symbols in the specified package.
\end{function}

\begin{function}{apropos-list}{string-designator \op package-designator external-only}
  Like APROPOS, except that it returns a list of the symbols found instead
  of describing them.
\end{function}

\begin{function}{dribble}{\op pathname \key if-exists}
  With a file name as an argument, dribble opens the file and sends a
  record of further I/O to that file. Without an argument, it closes
  the dribble file, and quits logging.
\end{function}

\begin{function}{ed}{\op x}
  Starts the editor (on a file or a function if named).  Functions
from the list *ED-FUNCTIONS* are called in order with X as an argument
until one of them returns non-NIL; these functions are responsible for
signalling a FILE-ERROR to indicate failure to perform an operation on
the file system.
\end{function}

\begin{function}{macroexpand}{form \op env}
  Repetitively call MACROEXPAND-1 until the form can no longer be expanded.
   Returns the final resultant form, and T if it was expanded. ENV is the
   lexical environment to expand in, or NIL (the default) for the null
   environment.
\end{function}

\begin{function}{macroexpand-1}{form \op env}
  If form is a macro (or symbol macro), expand it once. Return two values,
   the expanded form and a T-or-NIL flag indicating whether the form was, in
   fact, a macro. ENV is the lexical environment to expand in, which defaults
   to the null environment.
\end{function}

\begin{variable}{*macroexpand-hook*}{}
  
\end{variable}

\section{Debugging and Profiling}
\label{sec:debugging}

\begin{macro}{step}{form}
  The form is evaluated with single stepping enabled. Function calls
outside the lexical scope of the form can be stepped into only if the
functions in question have been compiled with sufficient DEBUG policy
to be at least partially steppable.
\end{macro}

\begin{function}{break}{\op datum \rest arguments}
  Print a message and invoke the debugger without allowing any possibility
  of condition handling occurring.
\end{function}

\begin{macro}{time}{form}
  Execute FORM and print timing information on *TRACE-OUTPUT*.

On some hardware platforms estimated processor cycle counts are
included in this output; this number is slightly inflated, since it
includes the pipeline involved in reading the cycle counter --
executing (TIME NIL) a few times will give you an idea of the
overhead, and its variance. The cycle counters are also per processor,
not per thread: if multiple threads are running on the same processor,
the reported counts will include cycles taken up by all threads
running on the processor where TIME was executed. Furthermore, if the
operating system migrates the thread to another processor between
reads of the cycle counter, the results will be completely bogus.
Finally, the counter is cycle counter, incremented by the hardware
even when the process is halted -- which is to say that cycles pass
normally during operations like SLEEP.
\end{macro}

\begin{function}{collect-timing}{lambda}[cl-ext]
  Executes LAMBDA and returns a timing-info object specifying
  how long execution took and how much memory was used.

NB: Not all implementations provide all information. See the
various \%collect-timing definitions for details.
\end{function}

\begin{macro}{trace}{\rest specs}
  TRACE {Option Global-Value}* {Name {Option Value}*}*

TRACE is a debugging tool that provides information when specified
functions are called. In its simplest form:

       (TRACE NAME-1 NAME-2 ...)

The NAMEs are not evaluated. Each may be a symbol, denoting an
individual function, or a string, denoting all functions fbound to
symbols whose home package is the package with the given name.

Options allow modification of the default behavior. Each option is a
pair of an option keyword and a value form. Global options are
specified before the first name, and affect all functions traced by a
given use of TRACE. Options may also be interspersed with function
names, in which case they act as local options, only affecting tracing
of the immediately preceding function name. Local options override
global options.

By default, TRACE causes a printout on \varr{*TRACE-OUTPUT*} each time
that one of the named functions is entered or returns. (This is the
basic, ANSI Common Lisp behavior of TRACE.) As an SBCL extension, the
:REPORT SB-EXT:PROFILE option can be used to instead cause information
to be silently recorded to be inspected later using the SB-EXT:PROFILE
function.

The following options are defined:

   :REPORT Report-Type
       If Report-Type is TRACE (the default) then information is reported
       by printing immediately. If Report-Type is SB-EXT:PROFILE, information
       is recorded for later summary by calls to SB-EXT:PROFILE. If
       Report-Type is NIL, then the only effect of the trace is to execute
       other options (e.g. PRINT or BREAK).

   :CONDITION Form
   :CONDITION-AFTER Form
   :CONDITION-ALL Form
       If :CONDITION is specified, then TRACE does nothing unless Form
       evaluates to true at the time of the call. :CONDITION-AFTER is
       similar, but suppresses the initial printout, and is tested when the
       function returns. :CONDITION-ALL tries both before and after.
       This option is not supported with :REPORT PROFILE.

   :BREAK Form
   :BREAK-AFTER Form
   :BREAK-ALL Form
       If specified, and Form evaluates to true, then the debugger is invoked
       at the start of the function, at the end of the function, or both,
       according to the respective option.

   :PRINT Form
   :PRINT-AFTER Form
   :PRINT-ALL Form
       In addition to the usual printout, the result of evaluating Form is
       printed at the start of the function, at the end of the function, or
       both, according to the respective option. Multiple print options cause
       multiple values to be printed.

   :WHEREIN Names
       If specified, Names is a function name or list of names. TRACE does
       nothing unless a call to one of those functions encloses the call to
       this function (i.e. it would appear in a backtrace.)  Anonymous
       functions have string names like "DEFUN FOO". This option is not
       supported with :REPORT PROFILE.

   :ENCAPSULATE {:DEFAULT | T | NIL}
       If T, the tracing is done via encapsulation (redefining the function
       name) rather than by modifying the function. :DEFAULT is the default,
       and means to use encapsulation for interpreted functions and funcallable
       instances, breakpoints otherwise. When encapsulation is used, forms are
       *not* evaluated in the function's lexical environment, but SB-DEBUG:ARG
       can still be used.

   :METHODS {T | NIL}
       If T, any function argument naming a generic function will have its
       methods traced in addition to the generic function itself.

   :FUNCTION Function-Form
       This is a not really an option, but rather another way of specifying
       what function to trace. The Function-Form is evaluated immediately,
       and the resulting function is instrumented, i.e. traced or profiled
       as specified in REPORT.

:CONDITION, :BREAK and :PRINT forms are evaluated in a context which
mocks up the lexical environment of the called function, so that
SB-DEBUG:VAR and SB-DEBUG:ARG can be used. The -AFTER and -ALL forms
are evaluated in the null environment.
\end{macro}

\begin{macro}{untrace}{\rest specs}
  Remove tracing from the specified functions. Untraces all
functions when called with no arguments.
\end{macro}

\begin{function}{describe}{x \op stream-designator}
  Print a description of the object X.
\end{function}

\begin{function}{inspect}{object}
  
\end{function}

\begin{function}{disassemble}{object \key stream use-labels}
  Disassemble the compiled code associated with OBJECT, which can be a
  function, a lambda expression, or a symbol with a function definition. If
  it is not already compiled, the compiler is called to produce something to
  disassemble.
\end{function}

\begin{generic}{describe-object}{x stream}
  
\end{generic}

\begin{generic}{documentation}{slotd doc-type}
  Return the documentation string of Doc-Type for X, or NIL if
  none exists. System doc-types are VARIABLE, FUNCTION, STRUCTURE, TYPE,
  SETF, and T.
\end{generic}

\begin{function}{room}{\op verbosity}
  Print to *STANDARD-OUTPUT* information about the state of internal
  storage and its management. The optional argument controls the
  verbosity of output. If it is T, ROOM prints out a maximal amount of
  information. If it is NIL, ROOM prints out a minimal amount of
  information. If it is :DEFAULT or it is not supplied, ROOM prints out
  an intermediate amount of information.
\end{function}


\chapter{Compilation and evaluation}
\label{cha:comp-eval}

\section{Predicates}
\label{sec:predicates-1}

See also \funr{special-operator-p}.

\begin{function}{compiled-function-p}{object}
  Return true if OBJECT is a COMPILED-FUNCTION, and NIL otherwise.
\end{function}

\section{Compilation}
\label{sec:compilation}

\begin{function}{compile}{name \op definition}
  Coerce DEFINITION (by default, the function whose name is NAME)
  to a compiled function, returning (VALUES THING WARNINGS-P FAILURE-P),
  where if NAME is NIL, THING is the result of compilation, and
  otherwise THING is NAME. When NAME is not NIL, the compiled function
  is also set into (MACRO-FUNCTION NAME) if NAME names a macro, or into
  (FDEFINITION NAME) otherwise.
\end{function}

\begin{function}{compile-file}{input-file \key output-file (verbose *compile-verbose*)
 (print *compile-print*) external-format trace-file
 (block-compile *block-compile-arg*)}
  Compile INPUT-FILE, producing a corresponding fasl file and
returning its filename.

  :PRINT
     If true, a message per non-macroexpanded top level form is printed
     to *STANDARD-OUTPUT*. Top level forms that whose subforms are
     processed as top level forms (eg. EVAL-WHEN, MACROLET, PROGN) receive
     no such message, but their subforms do.

     As an extension to ANSI, if :PRINT is :top-level-forms, a message
     per top level form after macroexpansion is printed to *STANDARD-OUTPUT*.
     For example, compiling an IN-PACKAGE form will result in a message about
     a top level SETQ in addition to the message about the IN-PACKAGE form'
     itself.

     Both forms of reporting obey the SB-EXT:*COMPILER-PRINT-VARIABLE-ALIST*.

  :BLOCK-COMPILE
     Though COMPILE-FILE accepts an additional :BLOCK-COMPILE
     argument, it is not currently supported. (non-standard)

  :TRACE-FILE
     If given, internal data structures are dumped to the specified
     file, or if a value of T is given, to a file of *.trace type
     derived from the input file name. (non-standard)
\end{function}

\begin{function}{compile-file-pathname}{input-file \key output-file \akeys}
  Return a pathname describing what file COMPILE-FILE would write to given
  these arguments.
\end{function}

\begin{function}{load}{pathspec \key verbose print if-does-not-exist external-format}
  Load the file given by FILESPEC into the Lisp environment, returning
   T on success.
\end{function}

\begin{variable}{*compile-file-pathname*}{}
  
\end{variable}

\begin{variable}{*compile-file-truename*}{}
  
\end{variable}

\begin{variable}{*compile-print*}{}
  
\end{variable}

\begin{variable}{*compile-verbose*}{}
  
\end{variable}

\begin{variable}{*load-pathname*}{}
  
\end{variable}

\begin{variable}{*load-print*}{}
  
\end{variable}

\begin{variable}{*load-truename*}{}
  
\end{variable}

\begin{variable}{*load-verbose*}{}
  
\end{variable}

\begin{specialop}{eval-when}{situations \rest forms}
  EVAL-WHEN (situation*) form*

Evaluate the FORMS in the specified SITUATIONS (any of :COMPILE-TOPLEVEL,
:LOAD-TOPLEVEL, or :EXECUTE, or (deprecated) COMPILE, LOAD, or EVAL).
\end{specialop}

\begin{macro}{with-compilation-unit}{options \body body}
  WITH-COMPILATION-UNIT ({Key Value}*) Form*
  This form affects compilations that take place within its dynamic extent. It
  is intended to be wrapped around the compilation of all files in the same
  system. These keywords are defined:

    :OVERRIDE Boolean-Form
        One of the effects of this form is to delay undefined warnings
        until the end of the form, instead of giving them at the end of each
        compilation. If OVERRIDE is NIL (the default), then the outermost
        WITH-COMPILATION-UNIT form grabs the undefined warnings. Specifying
        OVERRIDE true causes that form to grab any enclosed warnings, even if
        it is enclosed by another WITH-COMPILATION-UNIT.

    :SOURCE-PLIST Plist-Form
        Attaches the value returned by the Plist-Form to internal debug-source
        information of functions compiled in within the dynamic contour.
        Primarily for use by development environments, in order to eg. associate
        function definitions with editor-buffers. Can be accessed as
        SB-INTROSPECT:DEFINITION-SOURCE-PLIST. If multiple, nested
        WITH-COMPILATION-UNITs provide :SOURCE-PLISTs, they are appended
        togather, innermost left. If  Unaffected by :OVERRIDE.
\end{macro}

\begin{specialop}{load-time-value}{form \op read-only-p}
  Arrange for FORM to be evaluated at load-time and use the value produced
   as if it were a constant. If READ-ONLY-P is non-NIL, then the resultant
   object is guaranteed to never be modified, so it can be put in read-only
   storage.
\end{specialop}

\begin{generic}{make-load-form}{object \op environment}
  
\end{generic}

\begin{function}{make-load-form-saving-slots}{object \key slot-names environment}
  
\end{function}

\begin{accessor}{macro-function}{symbol \op env}
  If SYMBOL names a macro in ENV, returns the expansion function,
else returns NIL. If ENV is unspecified or NIL, use the global environment
only.
\end{accessor}

\begin{accessor}{compiler-macro-function}{name \op env}
  If NAME names a compiler-macro in ENV, return the expansion function, else
return NIL. Can be set with SETF when ENV is NIL.
\end{accessor}

\begin{function}{eval}{original-exp}
  Evaluate the argument in a null lexical environment, returning the
   result or results.
\end{function}

\begin{macro}{eval-always}{\body body}[cl-ext]
  
\end{macro}



\chapter{Declarations}
\label{cha:declarations}

\begin{function}{proclaim}{raw-form}
  
\end{function}

\begin{macro}{declaim}{\rest specs}
  DECLAIM Declaration*
  Do a declaration or declarations for the global environment.
\end{macro}

\begin{specialop}{the}{value-type form}
  Specifies that the values returned by FORM conform to the VALUE-TYPE.

CLHS specifies that the consequences are undefined if any result is
not of the declared type, but SBCL treats declarations as assertions
as long as SAFETY is at least 2, in which case incorrect type
information will result in a runtime type-error instead of leading to
eg. heap corruption. This is however expressly non-portable: use
CHECK-TYPE instead of THE to catch type-errors at runtime. THE is best
considered an optimization tool to inform the compiler about types it
is unable to derive from other declared types.
\end{specialop}

\chapter{Dealing with different implementations}
\label{cha:deal-with-diff}

the reader macro \texttt{\#+} and \texttt{\#-}

\begin{variable}{*features*}{}
  
\end{variable}

\begin{function}{featurep}{feature-expression}[cl-ext]
  Returns T if the argument matches the state of the *FEATURES*
list and NIL if it does not. FEATURE-EXPRESSION can be any atom
or list acceptable to the reader macros \#+ and \#-.
\end{function}

\part{Extension Libraries}
\label{part:libraries}


\chapter{HTML and XML processing}
\label{cha:html-xml-processing}

\section{Parsing XML}
\label{sec:parsing-xml}

Closure XML was written by Gilbert Baumann now maintained by David
Lichteblau. 

http://common-lisp.net/project/cxml/

S-XML is a simple XML parser implemented in Common Lisp. Originally it
was written by Sven Van Caekenberghe. It is now being maintained by
Sven Van Caekenberghe, Rudi Schlatte and Brian Mastenbrook. S-XML is
used by S-XML-RPC and CL-PREVALENCE.

http://common-lisp.net/project/s-xml/

\section{Parsing HTML}
\label{sec:parsing-html}

Closure HTML

Original author: Gilbert Baumann
Current maintainer: David Lichteblau 

http://www.cliki.net/closure-html

\libversion{2009-09-21}

\section{Generating HTML}
\label{sec:generating-html}

http://weitz.de/cl-who/
Edi Weitz

\section{HTML templates}
\label{sec:html-templates}

http://weitz.de/html-template/
Edi Weitz

\section{Generating Javascript}
\label{sec:gener-javascr}

http://common-lisp.net/project/parenscript/

\section{Generating CSS}
\label{sec:generating-css}

http://www.cliki.net/css-lite

\section{URI Templates}
\label{sec:uri-templates}

http://common-lisp.net/project/uri-template/



\chapter{Graphical user interfaces}
\label{cha:graph-user-interf}

\section{GUIs with TK}
\label{sec:guis-with-tk}

http://www.cliki.net/Ltk

\section{The ABLE lisp editor}
\label{sec:able-lisp-editor}



\chapter{Network programming}
\label{cha:network-programming}

http://common-lisp.net/project/usocket/

http://common-lisp.net/project/cl-plus-ssl/



\chapter{Internet data and protocols}
\label{cha:intern-data-prot}

\section{URI parsing}
\label{sec:uri-parsing}

Franz, Inc <http://www.franz.com>
Kevin Rosenberg <kevin@rosenberg.net>

http://puri.b9.com/

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

http://common-lisp.net/project/rfc2388/

  (:export
   #:parse-header
   #:header
   #:header-name
   #:header-value
   #:header-parameters

   #:content-type
   #:find-header
   #:find-parameter
   #:find-content-disposition-header
   #:get-file-name

   #:parse-mime
   #:mime-part
   #:mime-part-contents
   #:mime-part-headers
   #:make-mime-part))

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

http://www.cliki.net/CL-MIME
Robert Marlow

\section{Parsing email}
\label{sec:parsing-email}

http://www.cliki.net/mel-base
Jochen Schmidt

\section{Parsing JSON}
\label{sec:parsing-json}

http://common-lisp.net/project/cl-json/
Copyright (c) 2006-2008 Henrik Hjelte
Copyright (c) 2008 Hans Hübner (code from the program YASON)

\section{Base64}
\label{sec:base64}

http://www.cliki.net/cl-base64
Copyright (c) 2002-2003 by Kevin Rosenberg



\chapter{Internet Protocols and Support}
\label{cha:intern-prot-supp}

\section{XML-RPC}
\label{sec:xml-rpc}

S-XML-RPC is an implementation of XML-RPC in Common Lisp for both
client and server. Originally it was written by Sven Van Caekenberghe.
It is now being maintained by Sven Van Caekenberghe, Rudi Schlatte and
Brian Mastenbrook. S-XML-RPC is using S-XML as parser.

http://common-lisp.net/project/s-xml-rpc/

\section{SMTP client}
\label{sec:smtp-client}

http://www.cliki.net/CL-SMTP



\chapter{Multimedia}
\label{cha:multimedia}

\section{MIDI}
\label{sec:midi}

http://www.cliki.net/midi


\chapter{Strings}
\label{cha:strings-1}

\section{Regular expressions}
\label{sec:regular-expressions}

http://weitz.de/cl-ppcre/

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

http://common-lisp.net/project/babel/

   ;; types
   #:unicode-char
   #:unicode-char-code-limit
   #:unicode-string
   #:simple-unicode-string
   ;; fixed sharp-backslash reader
   #:enable-sharp-backslash-syntax
   #:set-sharp-backslash-syntax-in-readtable
   ;; external formats
   #:external-format
   #:make-external-format
   #:ensure-external-format
   #:external-format-encoding
   #:external-format-eol-style
   #:external-format-equal
   #:*default-eol-style*
   ;; general user API
   #:*default-character-encoding*
   #:list-character-encodings
   #:string-to-octets
   #:octets-to-string
   #:concatenate-strings-to-octets
   #:string-size-in-octets
   #:vector-size-in-chars
   ;; errors
   #:character-coding-error
   #:character-coding-error-encoding    ; accessor
   #:character-coding-error-buffer      ; accessor
   #:character-coding-error-position    ; accessor
   #:character-decoding-error
   #:character-decoding-error-octets    ; accessor
   #:character-encoding-error
   #:character-encoding-error-code      ; accessor
   #:end-of-input-in-character
   #:character-out-of-range
   #:invalid-utf8-starter-byte
   #:invalid-utf8-continuation-byte
   #:overlong-utf8-sequence

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

http://www.cliki.net/cl-qprint
Robert Marlow

\section{Difflib}
\label{sec:difflib}

http://www.cliki.net/CL-DIFFLIB

\section{Unicode}
\label{sec:unicode}

http://weitz.de/cl-unicode/

\section{String interpolation}
\label{sec:string-interpolation}

http://weitz.de/cl-interpol/



\chapter{OOP extensions}
\label{cha:oop-extensions}

http://common-lisp.net/project/closer/closer-mop.html



\chapter{Data persistance and Database}
\label{cha:data-persistance}

http://www.cliki.net/cl-store

http://www.cliki.net/CLSQL



\chapter{Data Compression and Archiving}
\label{cha:data-compr-arch}

http://www.xach.com/lisp/salza2/



\chapter{Operating System Services}
\label{cha:oper-syst-serv}

\section{Streams}
\label{sec:streams-1}

Copyright (c) 2005 David Lichteblau

http://www.cliki.net/trivial-gray-streams

1. Use the package TRIVIAL-GRAY-STREAMS instead of whatever
   implementation-specific package you would have to use otherwise to
   get at gray stream symbols.
2. For STREAM-READ-SEQUENCE and STREAM-WRITE-SEQUENCE, notice that we
   use two required arguments and allow additional keyword arguments.
   So the lambda list when defining a method on either function should look
   like this:
     (stream sequence start end \&key)
3. In order for (2) to work on all Lisps, make sure to subclass all your
   stream classes from TRIVIAL-GRAY-STREAM-MIXIN if you intend to define
   methods on those two generic functions.

\begin{class}{trivial-gray-stream-mixin}{}[lib]
          
\end{class}

\begin{function}{stream-read-sequence}{stream sequence start end \key}[lib]
  
\end{function}

\begin{function}{stream-write-sequence}{stream sequence start end \key}[lib]
  
\end{function}

\begin{function}{stream-file-position}{stream}[lib]
  
\end{function}

Dr. Edmund Weitz
http://weitz.de/flexi-streams/

\section{Interface with C}
\label{sec:interface-with-c}

http://www.cliki.net/CFFI
http://common-lisp.net/project/cffi/



\chapter{Cryptographic services}
\label{cha:crypt-serv}

http://www.cliki.net/MD5

http://method-combination.net/lisp/ironclad/


\chapter{Development tools}
\label{cha:development-tools}

\section{Portability}
\label{sec:portability}

Copyright (C) 2007, Luis Oliveira  <loliveira@common-lisp.net>

http://www.cliki.net/trivial-features

=============
Specification

* ENDIANNESS

Either :LITTLE-ENDIAN or :BIG-ENDIAN should present in *FEATURES*.
For the time being, we will not concern ourselves with other
orderings, switchable endianness, etc.


* OPERATING SYSTEM

On Windows, :WINDOWS should be present in *FEATURES*.

On POSIX systems, the "sysname" information from uname(3) should be
used to push the appropriate symbol to *FEATURES* by upcasing that
string (or downcasing for the "modern" lisps) and interning it in the
keyword package.

Examples:

  :DARWIN
  :LINUX
  :NETBSD
  :OPENBSD
  :FREEBSD

For convenience, :UNIX should be pushed when running on
POSIX/UNIX-like operating system (that doesn't include Windows) and
:BSD should be present when running on BSD-based systems (that
includes Darwin)

[add :MACH too?]


* CPU

These features should be mutually exclusive:

  :X86
  :X86-64
  :PPC
  :PPC64
  :MIPS
  :ALPHA
  :SPARC
  :SPARC64
  :HPPA
  :HPPA64

[add more ...]

[note: it's debatable whether :X86 shouldn't also be exported on
x86-64, and :PPC on ppc64.  SBCL doesn't.  Other ways
to handle, for example, the x86/x86-64 case would be to export
something like :PC386 in both cases or have an additional :X86-32. Or
finally, have just :X86, :PPC, etc, and add :32-BIT-CPU and
:64-BIT-CPU features.]

\printindex

\bibliographystyle{plain}
\bibliography{bibliography}
\end{document}

 	

%%% Local Variables:
%%% TeX-source-specials-mode: 1
%%% End:

