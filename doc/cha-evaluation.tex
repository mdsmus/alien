\chapter{Compilation and evaluation}

\section{Compilation}

\section{Declarations}

\begin{accessor}{compiler-macro-function}{name \op env}
  If NAME names a compiler-macro in ENV, return the expansion function, else
return NIL. Can be set with SETF when ENV is NIL.
\end{accessor}

\begin{accessor}{macro-function}{symbol \op env}
  If SYMBOL names a macro in ENV, returns the expansion function,
else returns NIL. If ENV is unspecified or NIL, use the global environment
only.
\end{accessor}

\begin{function}{compile}{name \op definition}
  Coerce DEFINITION (by default, the function whose name is NAME)
  to a compiled function, returning (VALUES THING WARNINGS-P FAILURE-P),
  where if NAME is NIL, THING is the result of compilation, and
  otherwise THING is NAME. When NAME is not NIL, the compiled function
  is also set into (MACRO-FUNCTION NAME) if NAME names a macro, or into
  (FDEFINITION NAME) otherwise.
\end{function}

\begin{function}{constantp}{form \op environment}
  True of any FORM that has a constant value: self-evaluating objects,
keywords, defined constants, quote forms. Additionally the
constant-foldability of some function calls special forms is recognized. If
ENVIRONMENT is provided the FORM is first macroexpanded in it.
\end{function}

\begin{function}{eval}{original-exp}
  Evaluate the argument in a null lexical environment, returning the
   result or results.
\end{function}

\begin{function}{macroexpand}{form \op env}
  Repetitively call MACROEXPAND-1 until the form can no longer be expanded.
   Returns the final resultant form, and T if it was expanded. ENV is the
   lexical environment to expand in, or NIL (the default) for the null
   environment.
\end{function}

\begin{function}{macroexpand-1}{form \op env}
  If form is a macro (or symbol macro), expand it once. Return two values,
   the expanded form and a T-or-NIL flag indicating whether the form was, in
   fact, a macro. ENV is the lexical environment to expand in, which defaults
   to the null environment.
\end{function}

\begin{function}{proclaim}{raw-form}
  
\end{function}

\begin{function}{special-operator-p}{symbol}
  If the symbol globally names a special form, return T, otherwise NIL.
\end{function}

\begin{macro}{declaim}{\rest specs}
  DECLAIM Declaration*
  Do a declaration or declarations for the global environment.
\end{macro}

\begin{macro}{define-compiler-macro}{name lambda-list \body body}
  Define a compiler-macro for NAME.
\end{macro}

\begin{macro}{define-symbol-macro}{name expansion}
  
\end{macro}

\begin{macro}{defmacro}{name lambda-list \rest body}
  
\end{macro}

\begin{macro}{lambda}{\whole whole args \body body}
  
\end{macro}

\begin{specialop}{eval-when}{situations \rest forms}
  EVAL-WHEN (situation*) form*

Evaluate the FORMS in the specified SITUATIONS (any of :COMPILE-TOPLEVEL,
:LOAD-TOPLEVEL, or :EXECUTE, or (deprecated) COMPILE, LOAD, or EVAL).
\end{specialop}

\begin{specialop}{load-time-value}{form \op read-only-p}
  Arrange for FORM to be evaluated at load-time and use the value produced
   as if it were a constant. If READ-ONLY-P is non-NIL, then the resultant
   object is guaranteed to never be modified, so it can be put in read-only
   storage.
\end{specialop}

\begin{specialop}{locally}{\body body}
  LOCALLY declaration* form*

Sequentially evaluate the FORMS in a lexical environment where the
DECLARATIONS have effect. If LOCALLY is a top level form, then the FORMS are
also processed as top level forms.
\end{specialop}

\begin{specialop}{quote}{thing}
  QUOTE value

Return VALUE without evaluating it.
\end{specialop}

\begin{specialop}{symbol-macrolet}{macrobindings \body body}
  SYMBOL-MACROLET ({(name expansion)}*) decl* form*

Define the NAMES as symbol macros with the given EXPANSIONS. Within the
body, references to a NAME will effectively be replaced with the EXPANSION.
\end{specialop}

\begin{specialop}{the}{value-type form}
  Specifies that the values returned by FORM conform to the VALUE-TYPE.

CLHS specifies that the consequences are undefined if any result is
not of the declared type, but SBCL treats declarations as assertions
as long as SAFETY is at least 2, in which case incorrect type
information will result in a runtime type-error instead of leading to
eg. heap corruption. This is however expressly non-portable: use
CHECK-TYPE instead of THE to catch type-errors at runtime. THE is best
considered an optimization tool to inform the compiler about types it
is unable to derive from other declared types.
\end{specialop}

\begin{variable}{*macroexpand-hook*}{}
  
\end{variable}

\section{Extensions}
\label{sec:extensions}

\begin{macro}{eval-always}{\body body}[cl-ext]
  
\end{macro}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: cl-dist-manual.tex
%%% End:
