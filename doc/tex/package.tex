\chapter{Packages and Symbols}

\section{Packages}

\begin{function}{delete-package}{package-designator}{}{}
  Delete the package designated by PACKAGE-DESIGNATOR from the package
  system data structures.
\end{function}

\begin{function}{export}{symbols \op package}{}{}
  Exports SYMBOLS from PACKAGE, checking that no name conflicts result.
\end{function}

\begin{function}{find-all-symbols}{string-or-symbol}{}{}
  Return a list of all symbols in the system having the specified name.
\end{function}

\begin{function}{find-package}{package-designator}{}{}
  
\end{function}

\begin{function}{find-symbol}{name \op package}{}{}
  Return the symbol named STRING in PACKAGE. If such a symbol is found
  then the second value is :INTERNAL, :EXTERNAL or :INHERITED to indicate
  how the symbol is accessible. If no symbol is found then both values
  are NIL.
\end{function}

\begin{function}{import}{symbols \op package}{}{}
  Make SYMBOLS accessible as internal symbols in PACKAGE. If a symbol is
already accessible then it has no effect. If a name conflict would result from
the importation, then a correctable error is signalled.
\end{function}

\begin{function}{intern}{name \op package}{}{}
  Return a symbol in PACKAGE having the specified NAME, creating it
  if necessary.
\end{function}

\begin{function}{list-all-packages}{}{}{}
  Return a list of all existing packages.
\end{function}

\begin{function}{make-package}{name \key use nicknames internal-symbols external-symbols}{}{}
  Make a new package having the specified NAME, NICKNAMES, and USE
list. :INTERNAL-SYMBOLS and :EXTERNAL-SYMBOLS are estimates for the number of
internal and external symbols which will ultimately be present in the package.
The default value of USE is implementation-dependent, and in this
implementation it is NIL.
\end{function}

\begin{function}{package-error-package}{condition}{}{}
  
\end{function}

\begin{function}{package-name}{package-designator}{}{}
  
\end{function}

\begin{function}{package-nicknames}{x}{}{}
  
\end{function}

\begin{function}{package-shadowing-symbols}{x}{}{}
  
\end{function}

\begin{function}{package-use-list}{x}{}{}
  
\end{function}

\begin{function}{package-used-by-list}{x}{}{}
  
\end{function}

\begin{function}{packagep}{object}{}{}
  
\end{function}

\begin{function}{rename-package}{package name \op nicknames}{}{}
  Changes the name and nicknames for a package.
\end{function}

\begin{function}{shadow}{symbols \op package}{}{}
  Make an internal symbol in PACKAGE with the same name as each of the
specified SYMBOLS. If a symbol with the given name is already present in
PACKAGE, then the existing symbol is placed in the shadowing symbols list if
it is not already present.
\end{function}

\begin{function}{shadowing-import}{symbols \op package}{}{}
  Import SYMBOLS into package, disregarding any name conflict. If
  a symbol of the same name is present, then it is uninterned.
\end{function}

\begin{function}{unexport}{symbols \op package}{}{}
  Makes SYMBOLS no longer exported from PACKAGE.
\end{function}

\begin{function}{unintern}{symbol \op package}{}{}
  Makes SYMBOL no longer present in PACKAGE. If SYMBOL was present then T is
returned, otherwise NIL. If PACKAGE is SYMBOL's home package, then it is made
uninterned.
\end{function}

\begin{function}{unuse-package}{packages-to-unuse \op package}{}{}
  Remove PACKAGES-TO-UNUSE from the USE list for PACKAGE.
\end{function}

\begin{function}{use-package}{packages-to-use \op package}{}{}
  Add all the PACKAGES-TO-USE to the use list for PACKAGE so that the
external symbols of the used packages are accessible as internal symbols in
PACKAGE.
\end{function}

\begin{macro}{defpackage}{package \rest options}{}{}
  Defines a new package called PACKAGE. Each of OPTIONS should be one of the
   following: 
    (NICKNAMES {package-name}*)
    (SIZE <integer>)
    (SHADOW {symbol-name}*)
    (SHADOWING-IMPORT-FROM <package-name> {symbol-name}*)
    (USE {package-name}*)
    (IMPORT-FROM <package-name> {symbol-name}*)
    (INTERN {symbol-name}*)
    (EXPORT {symbol-name}*)
    (IMPLEMENT {package-name}*)
    (LOCK boolean)
    (DOCUMENTATION doc-string)
   All options except SIZE, LOCK, and :DOCUMENTATION can be used multiple
   times.
\end{macro}

\begin{macro}{do-all-symbols}{var \body body-decls}{}{}
  DO-ALL-SYMBOLS (VAR [RESULT-FORM]) {DECLARATION}* {TAG | FORM}*
   Executes the FORMs once for each symbol in every package with VAR bound
   to the current symbol.
\end{macro}

\begin{macro}{do-external-symbols}{var \body body-decls}{}{}
  DO-EXTERNAL-SYMBOLS (VAR [PACKAGE [RESULT-FORM]]) {DECL}* {TAG | FORM}*
   Executes the FORMs once for each external symbol in the given PACKAGE with
   VAR bound to the current symbol.
\end{macro}

\begin{macro}{do-symbols}{var \body body-decls}{}{}
  DO-SYMBOLS (VAR [PACKAGE [RESULT-FORM]]) {DECLARATION}* {TAG | FORM}*
   Executes the FORMs at least once for each symbol accessible in the given
   PACKAGE with VAR bound to the current symbol.
\end{macro}

\begin{macro}{in-package}{string-designator}{}{}
  
\end{macro}

\begin{macro}{with-package-iterator}{mname \body body}{}{}
  Within the lexical scope of the body forms, MNAME is defined via macrolet
such that successive invocations of (MNAME) will return the symbols, one by
one, from the packages in PACKAGE-LIST. SYMBOL-TYPES may be any
of :INHERITED :EXTERNAL :INTERNAL.
\end{macro}

\begin{class}{package}{}{}{}
  
\end{class}

\begin{variable}{*package*}{}{}{}
  
\end{variable}

\section{system}

\begin{function}{compile-file}{input-file \key output-file (verbose *compile-verbose*)
 (print *compile-print*) external-format trace-file
 (block-compile *block-compile-arg*)}{}{}
  Compile INPUT-FILE, producing a corresponding fasl file and
returning its filename.

  :PRINT
     If true, a message per non-macroexpanded top level form is printed
     to *STANDARD-OUTPUT*. Top level forms that whose subforms are
     processed as top level forms (eg. EVAL-WHEN, MACROLET, PROGN) receive
     no such message, but their subforms do.

     As an extension to ANSI, if :PRINT is :top-level-forms, a message
     per top level form after macroexpansion is printed to *STANDARD-OUTPUT*.
     For example, compiling an IN-PACKAGE form will result in a message about
     a top level SETQ in addition to the message about the IN-PACKAGE form'
     itself.

     Both forms of reporting obey the SB-EXT:*COMPILER-PRINT-VARIABLE-ALIST*.

  :BLOCK-COMPILE
     Though COMPILE-FILE accepts an additional :BLOCK-COMPILE
     argument, it is not currently supported. (non-standard)

  :TRACE-FILE
     If given, internal data structures are dumped to the specified
     file, or if a value of T is given, to a file of *.trace type
     derived from the input file name. (non-standard)
\end{function}

\begin{function}{compile-file-pathname}{input-file \key output-file \akeys}{}{}
  Return a pathname describing what file COMPILE-FILE would write to given
   these arguments.
\end{function}

\begin{function}{load}{pathspec \key verbose print if-does-not-exist external-format}{}{}
  Load the file given by FILESPEC into the Lisp environment, returning
   T on success.
\end{function}

\begin{function}{provide}{module-name}{}{}
  Adds a new module name to *MODULES* indicating that it has been loaded.
   Module-name is a string designator
\end{function}

\begin{function}{require}{module-name \op pathnames}{}{}
  Loads a module, unless it already has been loaded. PATHNAMES, if supplied,
   is a designator for a list of pathnames to be loaded if the module
   needs to be. If PATHNAMES is not supplied, functions from the list
   *MODULE-PROVIDER-FUNCTIONS* are called in order with MODULE-NAME
   as an argument, until one of them returns non-NIL.  User code is
   responsible for calling PROVIDE to indicate a successful load of the
   module.
\end{function}

\begin{macro}{with-compilation-unit}{options \body body}{}{}
  WITH-COMPILATION-UNIT ({Key Value}*) Form*
  This form affects compilations that take place within its dynamic extent. It
  is intended to be wrapped around the compilation of all files in the same
  system. These keywords are defined:

    :OVERRIDE Boolean-Form
        One of the effects of this form is to delay undefined warnings
        until the end of the form, instead of giving them at the end of each
        compilation. If OVERRIDE is NIL (the default), then the outermost
        WITH-COMPILATION-UNIT form grabs the undefined warnings. Specifying
        OVERRIDE true causes that form to grab any enclosed warnings, even if
        it is enclosed by another WITH-COMPILATION-UNIT.

    :SOURCE-PLIST Plist-Form
        Attaches the value returned by the Plist-Form to internal debug-source
        information of functions compiled in within the dynamic contour.
        Primarily for use by development environments, in order to eg. associate
        function definitions with editor-buffers. Can be accessed as
        SB-INTROSPECT:DEFINITION-SOURCE-PLIST. If multiple, nested
        WITH-COMPILATION-UNITs provide :SOURCE-PLISTs, they are appended
        togather, innermost left. If  Unaffected by :OVERRIDE.
\end{macro}

\begin{variable}{*compile-file-pathname*}{}{}{}
  
\end{variable}

\begin{variable}{*compile-file-truename*}{}{}{}
  
\end{variable}

\begin{variable}{*compile-print*}{}{}{}
  
\end{variable}

\begin{variable}{*compile-verbose*}{}{}{}
  
\end{variable}

\begin{variable}{*features*}{}{}{}
  
\end{variable}

\begin{variable}{*load-pathname*}{}{}{}
  
\end{variable}

\begin{variable}{*load-print*}{}{}{}
  
\end{variable}

\begin{variable}{*load-truename*}{}{}{}
  
\end{variable}

\begin{variable}{*load-verbose*}{}{}{}
  
\end{variable}

\begin{variable}{*modules*}{}{}{}
  
\end{variable}

\section{Symbols}

\begin{accessor}{get}{symbol indicator \op default}{}{}
  Look on the property list of SYMBOL for the specified INDICATOR. If this
  is found, return the associated value, else return DEFAULT.
\end{accessor}

\begin{accessor}{symbol-function}{symbol}{}{}
  Return SYMBOL's current function definition. Settable with SETF.
\end{accessor}

\begin{accessor}{symbol-plist}{symbol}{}{}
  Return SYMBOL's property list.
\end{accessor}

\begin{accessor}{symbol-value}{symbol}{}{}
  Return SYMBOL's current bound value.
\end{accessor}

\begin{function}{boundp}{symbol}{}{}
  Return non-NIL if SYMBOL is bound to a value.
\end{function}

\begin{function}{copy-symbol}{symbol \op copy-props \aux new-symbol}{}{}
  Make and return a new uninterned symbol with the same print name
  as SYMBOL. If COPY-PROPS is false, the new symbol is neither bound
  nor fbound and has no properties, else it has a copy of SYMBOL's
  function, value and property list.
\end{function}

\begin{function}{gensym}{\op thing}{}{}
  Creates a new uninterned symbol whose name is a prefix string (defaults
   to "G"), followed by a decimal number. Thing, when supplied, will
   alter the prefix if it is a string, or be used for the decimal number
   if it is a number, of this symbol. The default value of the number is
   the current value of *gensym-counter* which is incremented each time
   it is used.
\end{function}

\begin{function}{gentemp}{\op prefix package}{}{}
  Creates a new symbol interned in package PACKAGE with the given PREFIX.
\end{function}

\begin{function}{keywordp}{object}{}{}
  Return true if Object is a symbol in the "KEYWORD" package.
\end{function}

\begin{function}{make-symbol}{string}{}{}
  Make and return a new symbol with the STRING as its print name.
\end{function}

\begin{function}{makunbound}{symbol}{}{}
  Make SYMBOL unbound, removing any value it may currently have.
\end{function}

\begin{function}{remprop}{symbol indicator}{}{}
  Look on property list of SYMBOL for property with specified
  INDICATOR. If found, splice this indicator and its value out of
  the plist, and return the tail of the original list starting with
  INDICATOR. If not found, return () with no side effects.

  NOTE: The ANSI specification requires REMPROP to return true (not false)
  or false (the symbol NIL). Portable code should not rely on any other value.
\end{function}

\begin{function}{set}{symbol new-value}{}{}
  Set SYMBOL's value cell to NEW-VALUE.
\end{function}

\begin{function}{symbol-name}{symbol}{}{}
  Return SYMBOL's name as a string.
\end{function}

\begin{function}{symbol-package}{symbol}{}{}
  Return the package SYMBOL was interned in, or NIL if none.
\end{function}

\begin{function}{symbolp}{object}{}{}
  Return true if OBJECT is a SYMBOL, and NIL otherwise.
\end{function}

\begin{class}{symbol}{}{}{}
  
\end{class}

\begin{variable}{*gensym-counter*}{}{}{}
  
\end{variable}

\section{Extensions}
\label{sec:extensions}

\begin{function}{featurep}{feature-expression}{alexandria}{}
  Returns T if the argument matches the state of the *FEATURES*
list and NIL if it does not. FEATURE-EXPRESSION can be any atom
or list acceptable to the reader macros \#+ and \#-.
\end{function}

\begin{function}{ensure-symbol}{name \op package}{alexandria}{}
  Returns a symbol with name designated by NAME, accessible in package
designated by PACKAGE. If symbol is not already accessible in PACKAGE, it is
interned there. Returns a secondary value reflecting the status of the symbol
in the package, which matches the secondary return value of INTERN.
\end{function}

\begin{function}{format-symbol}{package control \rest arguments}{alexandria}{}
  Constructs a string by applying ARGUMENTS to CONTROL as if by FORMAT, and
then creates a symbol named by that string. If PACKAGE is NIL, returns an
uninterned symbol, if package is T, returns a symbol interned in the current
package, and otherwise returns a symbol interned in the package designated by
PACKAGE.
\end{function}

\begin{function}{make-keyword}{name}{alexandria}{}
  Interns the string designated by NAME in the KEYWORD package.
\end{function}

\begin{function}{make-gensym}{name}{alexandria}{}
  If NAME is a non-negative integer, calls GENSYM using it. Otherwise NAME
must be a string designator, in which case calls GENSYM using the designated
string as the argument.
\end{function}

\begin{function}{make-gensym-list}{length \op x}{alexandria}{}
  Returns a list of LENGTH gensyms, each generated as if with a call to MAKE-GENSYM,
using the second (optional, defaulting to "G") argument.
\end{function}

\begin{function}{symbolicate}{\rest things}{alexandria}{}
  Concatenate together the names of some strings and symbols,
producing a symbol in the current package.
\end{function}

