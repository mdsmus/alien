\chapter{Functions}

\section{Extensions}
\label{sec:fun-extensions}

\begin{function}{ensure-function}{function-designator}[cl-ext]
  Returns the function designated by FUNCTION-DESIGNATOR:
if FUNCTION-DESIGNATOR is a function, it is returned, otherwise
it must be a function name and its FDEFINITION is returned.
\end{function}

\begin{function}{disjoin}{predicate \rest more-predicates}[cl-ext]
  Returns a function that applies each of PREDICATE and MORE-PREDICATE
functions in turn to its arguments, returning the primary value of the first
predicate that returns true, without calling the remaining predicates.
If none of the predicates returns true, NIL is returned.
\end{function}

\begin{function}{conjoin}{predicate \rest more-predicates}[cl-ext]
  Returns a function that applies each of PREDICATE and MORE-PREDICATE
functions in turn to its arguments, returning NIL if any of the predicates
returns false, without calling the remaining predicates. If none of the
predicates returns false, returns the primary value of the last predicate.
\end{function}

\begin{function}{compose}{function \rest more-functions}[cl-ext]
  Returns a function composed of FUNCTION and MORE-FUNCTIONS that applies its
arguments to to each in turn, starting from the rightmost of MORE-FUNCTIONS,
and then calling the next one with the primary value of the last.
\end{function}

\begin{function}{multiple-value-compose}{function \rest more-functions}[cl-ext]
  Returns a function composed of FUNCTION and MORE-FUNCTIONS that applies
its arguments to to each in turn, starting from the rightmost of
MORE-FUNCTIONS, and then calling the next one with all the return values of
the last.
\end{function}

\begin{function}{curry}{function \rest arguments}[cl-ext]
  Returns a function that applies ARGUMENTS and the arguments
it is called with to FUNCTION.
\end{function}

\begin{function}{rcurry}{function \rest arguments}[cl-ext]
  Returns a function that applies the arguments it is called
with and ARGUMENTS to FUNCTION.
\end{function}

\begin{macro}{named-lambda}{name lambda-list \body body}[cl-ext]
  Expands into a lambda-expression within whose BODY NAME denotes the
  corresponding function. Just like lambda except BODY can make recursive
  calls to the lambda by calling the function NAME.
\end{macro}

\begin{function}{make-reducer}{function \op initial-value}[cl-ext]
  Create a function which, starting with INITIAL-VALUE, reduces
any other values into a single final value.

FUNCTION will be called with two values: the current value and
the new value, in that order. FUNCTION should return exactly one
value.

The reducing function can be called with n arguments which will
be applied to FUNCTION one after the other (left to right) and
will return the new value.

If the reducing function is called with no arguments it will
return the current value.
\end{function}

\begin{macro}{with-reducer}{name \body body}[cl-ext]
  Locally bind NAME to a reducing function. The arguments
FUNCTION and INITIAL-VALUE are passed directly to MAKE-REDUCER.
\end{macro}

\begin{function}{make-collector}{\op initial-value}[cl-ext]
  Create a collector function.

A Collector function will collect, into a list, all the values
passed to it in the order in which they were passed. If the
callector function is called without arguments it returns the
current list of values.
\end{function}

\begin{macro}{with-collector}{name \body body}[cl-ext]
  Bind NAME to a collector function and execute BODY. If
  FROM-END is true the collector will actually be a pusher, (see
  MAKE-PUSHER), otherwise NAME will be bound to a collector,
  (see MAKE-COLLECTOR).
\end{macro}

\begin{macro}{with-collectors}{names \body body}[cl-ext]
  Bind multiple collectors. Each element of NAMES should be a
  list as per WITH-COLLECTOR's first orgument.
\end{macro}

\begin{function}{mapcar2}{function1 function2 list}[cl-ext]
  Utility function to apply to functions to each element of a list.
\end{function}

