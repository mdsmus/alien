\chapter{Hash Tables}

\begin{accessor}{gethash}{key hash-table \op default}{}{}
  Finds the entry in HASH-TABLE whose key is KEY and returns the
associated value and T as multiple values, or returns DEFAULT and NIL
if there is no such entry. Entries can be added using SETF.
\end{accessor}

\begin{function}{clrhash}{hash-table}{}{}
  This removes all the entries from HASH-TABLE and returns the hash
table itself.
\end{function}

\begin{function}{hash-table-count}{hash-table}{}{}
  Return the number of entries in the given HASH-TABLE.
\end{function}

\begin{function}{hash-table-p}{object}{}{}
  
\end{function}

\begin{function}{hash-table-rehash-size}{instance}{}{}
  Return the rehash-size HASH-TABLE was created with.
\end{function}

\begin{function}{hash-table-rehash-threshold}{instance}{}{}
  Return the rehash-threshold HASH-TABLE was created with.
\end{function}

\begin{function}{hash-table-size}{hash-table}{}{}
  Return a size that can be used with MAKE-HASH-TABLE to create a hash
   table that can hold however many entries HASH-TABLE can hold without
   having to be grown.
\end{function}

\begin{function}{hash-table-test}{instance}{}{}
  Return the test HASH-TABLE was created with.
\end{function}

\begin{function}{make-hash-table}{\key test size rehash-size rehash-threshold weakness synchronized}{}{}
  Create and return a new hash table. The keywords are as follows:
     :TEST -- Indicates what kind of test to use.
     :SIZE -- A hint as to how many elements will be put in this hash
       table.
     :REHASH-SIZE -- Indicates how to expand the table when it fills up.
       If an integer, add space for that many elements. If a floating
       point number (which must be greater than 1.0), multiply the size
       by that amount.
     :REHASH-THRESHOLD -- Indicates how dense the table can become before
       forcing a rehash. Can be any positive number <=1, with density
       approaching zero as the threshold approaches 0. Density 1 means an
       average of one entry per bucket.
     :WEAKNESS -- If NIL (the default) it is a normal non-weak hash table.
       If one of :KEY, :VALUE, :KEY-AND-VALUE, :KEY-OR-VALUE it is a weak
       hash table.
       Depending on the type of weakness the lack of references to the
       key and the value may allow for removal of the entry. If WEAKNESS
       is :KEY and the key would otherwise be garbage the entry is eligible
       for removal from the hash table. Similarly, if WEAKNESS is :VALUE
       the life of an entry depends on its value's references. If WEAKNESS
       is :KEY-AND-VALUE and either the key or the value would otherwise be
       garbage the entry can be removed. If WEAKNESS is :KEY-OR-VALUE and
       both the key and the value would otherwise be garbage the entry can
       be removed.
     :SYNCHRONIZED -- If NIL (the default), the hash-table may have
       multiple concurrent readers, but results are undefined if a
       thread writes to the hash-table concurrently with another
       reader or writer. If T, all concurrent accesses are safe, but
       note that CLHS 3.6 (Traversal Rules and Side Effects) remains
       in force. See also: SB-EXT:WITH-LOCKED-HASH-TABLE. This keyword
       argument is experimental, and may change incompatibly or be
       removed in the future.
\end{function}

\begin{function}{maphash}{function-designator hash-table}{}{}
  For each entry in HASH-TABLE, call the designated two-argument function on
the key and value of the entry. Return NIL.

Consequences are undefined if HASH-TABLE is mutated during the call to
MAPHASH, except for changing or removing elements corresponding to the
current key. The applies to all threads, not just the current one --
even for synchronized hash-tables. If the table may be mutated by
another thread during iteration, use eg. SB-EXT:WITH-LOCKED-HASH-TABLE
to protect the MAPHASH call.
\end{function}

\begin{function}{remhash}{key hash-table}{}{}
  Remove the entry in HASH-TABLE associated with KEY. Return T if
there was such an entry, or NIL if not.
\end{function}

\begin{function}{sxhash}{x}{}{}
  
\end{function}

\begin{macro}{with-hash-table-iterator}{name \body body}{}{}
  WITH-HASH-TABLE-ITERATOR ((name hash-table) \&body body)

Provides a method of manually looping over the elements of a hash-table. NAME
is bound to a generator-macro that, within the scope of the invocation,
returns one or three values. The first value tells whether any objects remain
in the hash table. When the first value is non-NIL, the second and third
values are the key and the value of the next object.

Consequences are undefined if HASH-TABLE is mutated during execution of BODY,
except for changing or removing elements corresponding to the current key. The
applies to all threads, not just the curren one -- even for synchronized
hash-tables. If the table may be mutated by another thread during iteration,
use eg. SB-EXT:WITH-LOCKED-HASH-TABLE to protect the WITH-HASH-TABLE-ITERATOR
for.
\end{macro}

\begin{class}{hash-table}{}{}{}
  
\end{class}
