\chapter{Lists}

\section{conses}

\begin{accessor}{caaaar}{list}{}{}
  Return the car of the caaar of a list.
\end{accessor}

\begin{accessor}{caaadr}{list}{}{}
  Return the car of the caadr of a list.
\end{accessor}

\begin{accessor}{caaar}{list}{}{}
  Return the 1st object in the caar of a list.
\end{accessor}

\begin{accessor}{caadar}{list}{}{}
  Return the car of the cadar of a list.
\end{accessor}

\begin{accessor}{caaddr}{list}{}{}
  Return the car of the caddr of a list.
\end{accessor}

\begin{accessor}{caadr}{list}{}{}
  Return the 1st object in the cadr of a list.
\end{accessor}

\begin{accessor}{caar}{list}{}{}
  Return the car of the 1st sublist.
\end{accessor}

\begin{accessor}{cadaar}{list}{}{}
  Return the car of the cdaar of a list.
\end{accessor}

\begin{accessor}{cadadr}{list}{}{}
  Return the car of the cdadr of a list.
\end{accessor}

\begin{accessor}{cadar}{list}{}{}
  Return the car of the cdar of a list.
\end{accessor}

\begin{accessor}{caddar}{list}{}{}
  Return the car of the cddar of a list.
\end{accessor}

\begin{accessor}{cadddr}{list}{}{}
  Return the car of the cdddr of a list.
\end{accessor}

\begin{accessor}{caddr}{list}{}{}
  Return the 1st object in the cddr of a list.
\end{accessor}

\begin{accessor}{cadr}{list}{}{}
  Return the 2nd object in a list.
\end{accessor}

\begin{accessor}{car}{list}{}{}
  Return the 1st object in a list.
\end{accessor}

\begin{accessor}{cdaaar}{list}{}{}
  Return the cdr of the caaar of a list.
\end{accessor}

\begin{accessor}{cdaadr}{list}{}{}
  Return the cdr of the caadr of a list.
\end{accessor}

\begin{accessor}{cdaar}{list}{}{}
  Return the cdr of the caar of a list.
\end{accessor}

\begin{accessor}{cdadar}{list}{}{}
  Return the cdr of the cadar of a list.
\end{accessor}

\begin{accessor}{cdaddr}{list}{}{}
  Return the cdr of the caddr of a list.
\end{accessor}

\begin{accessor}{cdadr}{list}{}{}
  Return the cdr of the cadr of a list.
\end{accessor}

\begin{accessor}{cdar}{list}{}{}
  Return the cdr of the 1st sublist.
\end{accessor}

\begin{accessor}{cddaar}{list}{}{}
  Return the cdr of the cdaar of a list.
\end{accessor}

\begin{accessor}{cddadr}{list}{}{}
  Return the cdr of the cdadr of a list.
\end{accessor}

\begin{accessor}{cddar}{list}{}{}
  Return the cdr of the cdar of a list.
\end{accessor}

\begin{accessor}{cdddar}{list}{}{}
  Return the cdr of the cddar of a list.
\end{accessor}

\begin{accessor}{cddddr}{list}{}{}
  Return the cdr of the cdddr of a list.
\end{accessor}

\begin{accessor}{cdddr}{list}{}{}
  Return the cdr of the cddr of a list.
\end{accessor}

\begin{accessor}{cddr}{list}{}{}
  Return all but the 1st two objects of a list.
\end{accessor}

\begin{accessor}{cdr}{list}{}{}
  Return all but the first object in a list.
\end{accessor}

\begin{accessor}{eighth}{list}{}{}
  Return the 8th object in a list or NIL if there is no 8th object.
\end{accessor}

\begin{accessor}{fifth}{list}{}{}
  Return the 5th object in a list or NIL if there is no 5th object.
\end{accessor}

\begin{accessor}{first}{list}{}{}
  Return the 1st object in a list or NIL if the list is empty.
\end{accessor}

\begin{accessor}{fourth}{list}{}{}
  Return the 4th object in a list or NIL if there is no 4th object.
\end{accessor}

\begin{accessor}{getf}{place indicator \op default}{}{}
  Search the property list stored in Place for an indicator EQ to INDICATOR.
  If one is found, return the corresponding value, else return DEFAULT.
\end{accessor}

\begin{accessor}{ninth}{list}{}{}
  Return the 9th object in a list or NIL if there is no 9th object.
\end{accessor}

\begin{accessor}{nth}{n list}{}{}
  Return the nth object in a list where the car is the zero-th element.
\end{accessor}

\begin{accessor}{rest}{list}{}{}
  Means the same as the cdr of a list.
\end{accessor}

\begin{accessor}{second}{list}{}{}
  Return the 2nd object in a list or NIL if there is no 2nd object.
\end{accessor}

\begin{accessor}{seventh}{list}{}{}
  Return the 7th object in a list or NIL if there is no 7th object.
\end{accessor}

\begin{accessor}{sixth}{list}{}{}
  Return the 6th object in a list or NIL if there is no 6th object.
\end{accessor}

\begin{accessor}{tenth}{list}{}{}
  Return the 10th object in a list or NIL if there is no 10th object.
\end{accessor}

\begin{accessor}{third}{list}{}{}
  Return the 3rd object in a list or NIL if there is no 3rd object.
\end{accessor}

\begin{function}{acons}{key datum alist}{}{}
  Construct a new alist by adding the pair (KEY . DATUM) to ALIST.
\end{function}

\begin{function}{adjoin}{item list \key key test test-not}{}{}
  Add ITEM to LIST unless it is already a member
\end{function}

\begin{function}{append}{\rest lists}{}{}
  Construct a new list by concatenating the list arguments
\end{function}

\begin{function}{assoc}{item alist \key key test test-not}{}{}
  Return the cons in ALIST whose car is equal (by a given test or EQL) to
   the ITEM.
\end{function}

\begin{function}{assoc-if}{predicate alist \key key}{}{}
  Return the first cons in ALIST whose CAR satisfies PREDICATE. If
   KEY is supplied, apply it to the CAR of each cons before testing.
\end{function}

\begin{function}{assoc-if-not}{predicate alist \key key}{}{}
  Return the first cons in ALIST whose CAR does not satisfy PREDICATE.
  If KEY is supplied, apply it to the CAR of each cons before testing.
\end{function}

\begin{function}{atom}{object}{}{}
  Return true if OBJECT is an ATOM, and NIL otherwise.
\end{function}

\begin{function}{butlast}{list \op n}{}{}
  
\end{function}

\begin{function}{cons}{se1 se2}{}{}
  Return a list with SE1 as the CAR and SE2 as the CDR.
\end{function}

\begin{function}{consp}{object}{}{}
  Return true if OBJECT is a CONS, and NIL otherwise.
\end{function}

\begin{function}{copy-alist}{alist}{}{}
  Return a new association list which is EQUAL to ALIST.
\end{function}

\begin{function}{copy-list}{list}{}{}
  Return a new list which is EQUAL to LIST. LIST may be improper.
\end{function}

\begin{function}{copy-tree}{object}{}{}
  Recursively copy trees of conses.
\end{function}

\begin{function}{endp}{object}{}{}
  This is the recommended way to test for the end of a proper list. It
   returns true if OBJECT is NIL, false if OBJECT is a CONS, and an error
   for any other type of OBJECT.
\end{function}

\begin{function}{get-properties}{place indicator-list}{}{}
  Like GETF, except that INDICATOR-LIST is a list of indicators which will
  be looked for in the property list stored in PLACE. Three values are
  returned, see manual for details.
\end{function}

\begin{function}{intersection}{list1 list2 \key key test test-not}{}{}
  Return the intersection of LIST1 and LIST2.
\end{function}

\begin{function}{last}{list \op n}{}{}
  Return the last N conses (not the last element!) of a list.
\end{function}

\begin{function}{ldiff}{list object}{}{}
  Return a new list, whose elements are those of LIST that appear before
   OBJECT. If OBJECT is not a tail of LIST, a copy of LIST is returned.
   LIST must be a proper list or a dotted list.
\end{function}

\begin{function}{list}{\rest args}{}{}
  Return constructs and returns a list of its arguments.
\end{function}

\begin{function}{list*}{arg \rest others}{}{}
  Return a list of the arguments with last cons a dotted pair.
\end{function}

\begin{function}{list-length}{list}{}{}
  Return the length of the given List, or Nil if the List is circular.
\end{function}

\begin{function}{listp}{object}{}{}
  Return true if OBJECT is a LIST, and NIL otherwise.
\end{function}

\begin{function}{make-list}{size \key initial-element}{}{}
  Constructs a list with size elements each set to value
\end{function}

\begin{function}{mapc}{function list \rest more-lists}{}{}
  Apply FUNCTION to successive elements of lists. Return the second argument.
\end{function}

\begin{function}{mapcan}{function list \rest more-lists}{}{}
  Apply FUNCTION to successive elements of LIST. Return NCONC of FUNCTION
   results.
\end{function}

\begin{function}{mapcar}{function list \rest more-lists}{}{}
  Apply FUNCTION to successive elements of LIST. Return list of FUNCTION
   return values.
\end{function}

\begin{function}{mapcon}{function list \rest more-lists}{}{}
  Apply FUNCTION to successive CDRs of lists. Return NCONC of results.
\end{function}

\begin{function}{mapl}{function list \rest more-lists}{}{}
  Apply FUNCTION to successive CDRs of list. Return NIL.
\end{function}

\begin{function}{maplist}{function list \rest more-lists}{}{}
  Apply FUNCTION to successive CDRs of list. Return list of results.
\end{function}

\begin{function}{member}{item list \key key test test-not}{}{}
  Return the tail of LIST beginning with first element satisfying EQLity,
   :TEST, or :TEST-NOT with the given ITEM.
\end{function}

\begin{function}{member-if}{test list \key key}{}{}
  Return tail of LIST beginning with first element satisfying TEST.
\end{function}

\begin{function}{member-if-not}{test list \key key}{}{}
  Return tail of LIST beginning with first element not satisfying TEST.
\end{function}

\begin{function}{nbutlast}{list \op n}{}{}
  
\end{function}

\begin{function}{nconc}{\rest lists}{}{}
  Concatenates the lists given as arguments (by changing them)
\end{function}

\begin{function}{nintersection}{list1 list2 \key key test test-not}{}{}
  Destructively return the intersection of LIST1 and LIST2.
\end{function}

\begin{function}{nreconc}{x y}{}{}
  Return (NCONC (NREVERSE X) Y).
\end{function}

\begin{function}{nset-difference}{list1 list2 \key key test test-not}{}{}
  Destructively return the elements of LIST1 which are not in LIST2.
\end{function}

\begin{function}{nset-exclusive-or}{list1 list2 \key key test test-not}{}{}
  Destructively return a list with elements which appear but once in LIST1
   and LIST2.
\end{function}

\begin{function}{nsublis}{alist tree \key key test test-not}{}{}
  Substitute from ALIST into TRUE destructively.
\end{function}

\begin{function}{nsubst}{new old tree \key key test test-not}{}{}
  Substitute NEW for subtrees matching OLD.
\end{function}

\begin{function}{nsubst-if}{new test tree \key key}{}{}
  Substitute NEW for subtrees of TREE for which TEST is true.
\end{function}

\begin{function}{nsubst-if-not}{new test tree \key key}{}{}
  Substitute NEW for subtrees of TREE for which TEST is false.
\end{function}

\begin{function}{nthcdr}{n list}{}{}
  Performs the cdr function n times on a list.
\end{function}

\begin{function}{null}{object}{}{}
  Return true if OBJECT is a NULL, and NIL otherwise.
\end{function}

\begin{function}{nunion}{list1 list2 \key key test test-not}{}{}
  Destructively return the union of LIST1 and LIST2.
\end{function}

\begin{function}{pairlis}{keys data \op alist}{}{}
  Construct an association list from KEYS and DATA (adding to ALIST).
\end{function}

\begin{function}{rassoc}{item alist \key key test test-not}{}{}
  Return the cons in ALIST whose CDR is equal (by a given test or EQL) to
   the ITEM.
\end{function}

\begin{function}{rassoc-if}{predicate alist \key key}{}{}
  Return the first cons in ALIST whose CDR satisfies PREDICATE. If KEY
  is supplied, apply it to the CDR of each cons before testing.
\end{function}

\begin{function}{rassoc-if-not}{predicate alist \key key}{}{}
  Return the first cons in ALIST whose CDR does not satisfy PREDICATE.
  If KEY is supplied, apply it to the CDR of each cons before testing.
\end{function}

\begin{function}{revappend}{x y}{}{}
  Return (append (reverse x) y).
\end{function}

\begin{function}{rplaca}{cons x}{}{}
  Change the CAR of CONS to X and return the CONS.
\end{function}

\begin{function}{rplacd}{cons x}{}{}
  Change the CDR of CONS to X and return the CONS.
\end{function}

\begin{function}{set-difference}{list1 list2 \key key test test-not}{}{}
  Return the elements of LIST1 which are not in LIST2.
\end{function}

\begin{function}{set-exclusive-or}{list1 list2 \key key test test-not}{}{}
  Return new list of elements appearing exactly once in LIST1 and LIST2.
\end{function}

\begin{function}{sublis}{alist tree \key key test test-not}{}{}
  Substitute from ALIST into TREE nondestructively.
\end{function}

\begin{function}{subsetp}{list1 list2 \key key test test-not}{}{}
  Return T if every element in LIST1 is also in LIST2.
\end{function}

\begin{function}{subst}{new old tree \key key test test-not}{}{}
  Substitutes new for subtrees matching old.
\end{function}

\begin{function}{subst-if}{new test tree \key key}{}{}
  Substitutes new for subtrees for which test is true.
\end{function}

\begin{function}{subst-if-not}{new test tree \key key}{}{}
  Substitutes new for subtrees for which test is false.
\end{function}

\begin{function}{tailp}{object list}{}{}
  Return true if OBJECT is the same as some tail of LIST, otherwise
   returns false. LIST must be a proper list or a dotted list.
\end{function}

\begin{function}{tree-equal}{x y \key test test-not}{}{}
  Return T if X and Y are isomorphic trees with identical leaves.
\end{function}

\begin{function}{union}{list1 list2 \key key test test-not}{}{}
  Return the union of LIST1 and LIST2.
\end{function}

\begin{macro}{pop}{place \env env}{}{}
  The argument is a location holding a list. Pops one item off the front
  of the list and returns it.
\end{macro}

\begin{macro}{push}{obj place \env env}{}{}
  Takes an object and a location holding a list. Conses the object onto
  the list, returning the modified list. OBJ is evaluated before PLACE.
\end{macro}

\begin{macro}{pushnew}{obj place \rest keys \key key test test-not \env env}{}{}
  Takes an object and a location holding a list. If the object is
  already in the list, does nothing; otherwise, conses the object onto
  the list. Returns the modified list. If there is a :TEST keyword, this
  is used for the comparison.
\end{macro}

\begin{macro}{remf}{place indicator \env env}{}{}
  Place may be any place expression acceptable to SETF, and is expected
  to hold a property list or (). This list is destructively altered to
  remove the property specified by the indicator. Returns T if such a
  property was present, NIL if not.
\end{macro}

\begin{class}{cons}{se1 se2}{}{}
  Return a list with SE1 as the CAR and SE2 as the CDR.
\end{class}

\begin{class}{list}{\rest args}{}{}
  Return constructs and returns a list of its arguments.
\end{class}

\begin{class}{null}{object}{}{}
  Return true if OBJECT is a NULL, and NIL otherwise.
\end{class}

\section{Lists extensions}
\label{sec:lists-extensions}

\begin{function}{range}{[start] end [step]}{}{}
  Return a list of numbers from \var{start} to \var{end}, inclusive,
  by \var{step}. With only one argument it will return a list of
  numbers from 0 to \var{end}. Numeric contagion from \var{step} and
  \var{start} is applied to the other numbers.
\begin{devnote}
  The function RANGE here is similar to python's range in the way it
  handle arguments and to bash's seq.
\end{devnote}
\end{function}

\begin{function}{map-range}{function start end \op step}{cl-ext}{}
  Return a list with numbers from \var{min} to \var{max} by \var{step}
  and apply \var{function} to each element of the list.
\end{function}

\begin{macro}{do-range}{(index \op min max step return value) \body body}{cl-ext}{}
  
\end{macro}

\begin{function}{iota}{n \key start step}{cl-ext}{}
  Return a list of n numbers, starting from START (with numeric
  contagion from STEP applied), each consequtive number being the sum
  of the previous one and STEP. START defaults to 0 and STEP to 1.
\end{function}

\begin{function}{map-iota}{function n \key start step}{cl-ext}{}
  Calls FUNCTION with N numbers, starting from START (with numeric contagion
from STEP applied), each consequtive number being the sum of the previous one
and STEP. START defaults to 0 and STEP to 1. Returns N.
\end{function}

\begin{function}{plist-to-alist}{plist}{cl-ext}{}
  Returns an association list containing the same keys and values as the
property list PLIST in the same order.
\end{function}

\begin{function}{alist-to-plist}{alist}{cl-ext}{}
  Returns a property list containing the same keys and values as the
association list ALIST in the same order.
\end{function}

\begin{macro}{doplist}{key \body body}{cl-ext}{}
  Iterates over elements of PLIST. BODY can be preceded by
declarations, and is like a TAGBODY. RETURN may be used to terminate
the iteration early. If RETURN is not used, returns VALUES.
\end{macro}

\begin{macro}{appendf}{place \rest lists \env env}{cl-ext}{}
  Modify-macro for APPEND. Appends LISTS to the place designated by the first
argument.
\end{macro}

\begin{macro}{nconcf}{place \rest lists \env env}{cl-ext}{}
  Modify-macro for NCONC. Concatenates LISTS to place designated by the first
argument.
\end{macro}

\begin{macro}{unionf}{place list \env env}{cl-ext}{}
  Modify-macro for UNION. Saves the union of LIST and the contents of the
place designated by the first argument to the designated place.
\end{macro}

\begin{macro}{nunionf}{place list \env env}{cl-ext}{}
  Modify-macro for NUNION. Saves the union of LIST and the contents of the
place designated by the first argument to the designated place. May modify
either argument.
\end{macro}

\begin{function}{circular-list}{\rest elements}{cl-ext}{}
  Creates a circular list of ELEMENTS.
\end{function}

\begin{function}{circular-list-p}{object}{cl-ext}{}
  Returns true if OBJECT is a circular list, NIL otherwise.
\end{function}

\begin{function}{circular-tree-p}{object}{cl-ext}{}
  Returns true if OBJECT is a circular tree, NIL otherwise.
\end{function}

\begin{type}{circular-list}{}{cl-ext}{}
  
\end{type}

\begin{type}{proper-list}{}{cl-ext}{}
  
\end{type}

\begin{function}{proper-list-p}{object}{cl-ext}{}
  Returns true if OBJECT is a proper list.
\end{function}

\begin{function}{lastcar}{list}{cl-ext}{}
  Returns the last element of LIST. Signals a type-error if LIST is not a
proper list.
\end{function}

\begin{function}{make-circular-list}{length \key initial-element}{cl-ext}{}
  Creates a circular list of LENGTH with the given INITIAL-ELEMENT.
\end{function}

\begin{function}{ensure-car}{thing}{cl-ext}{}
  If THING is a CONS, its CAR is returned. Otherwise THING is returned.
\end{function}

\begin{function}{ensure-cons}{cons}{cl-ext}{}
  If CONS is a cons, it is returned. Otherwise returns a fresh cons with CONS
  in the car, and NIL in the cdr.
\end{function}

\begin{function}{ensure-list}{thing}{cl-ext}{}
  Returns THING as a list.

If THING is already a list (as per listp) it is returned,
otherwise a one element list containing THING is returned.
\end{function}

\begin{function}{remove-from-plist}{plist \rest keys}{cl-ext}{}
  Returns a propery-list with same keys and values as PLIST, except that keys
in the list designated by KEYS and values corresponding to them are removed.
The returned property-list may share structure with the PLIST, but PLIST is
not destructively modified. Keys are compared using EQ.
\end{function}

\begin{macro}{remove-from-plistf}{place \rest keys \env env}{cl-ext}{}
  
\end{macro}

\begin{function}{delete-from-plist}{plist \rest keys}{cl-ext}{}
  Just like REMOVE-FROM-PLIST, but this version may destructively modify the
provided plist.
\end{function}

\begin{macro}{delete-from-plistf}{place \rest keys \env env}{cl-ext}{}
  
\end{macro}

\begin{function}{mappend}{function \rest lists}{cl-ext}{}
  Applies FUNCTION to respective element(s) of each LIST, appending all the
all the result list to a single list. FUNCTION must return a list.
\end{function}

\begin{function}{set-equal}{list1 list2 \key test key}{cl-ext}{}
  Returns true if every element of LIST1 matches some element of LIST2 and
every element of LIST2 matches some element of LIST1. Otherwise returns false.
\end{function}

\begin{function}{setp}{object \key test key}{cl-ext}{}
  Returns true if OBJECT is a list that denotes a set, NIL otherwise. A list
denotes a set if each element of the list is unique under KEY and TEST.
\end{function}

\begin{function}{map-product}{function list \rest more-lists}{cl-ext}{}
  Returns a list containing the results of calling FUNCTION with one argument
from LIST, and one from each of MORE-LISTS for each combination of arguments.
In other words, returns the product of LIST and MORE-LISTS using FUNCTION.
\end{function}

\begin{function}{flatten}{tree}{cl-ext}{}
  Traverses the tree in order, collecting non-null leaves into a list.
\end{function}

\begin{macro}{dolist*}{iterator \body body}{cl-ext}{}
  Like DOLIST but destructuring-binds the elements of LIST.

If ITERATOR is a symbol then dolist* is just like dolist EXCEPT
that it creates a fresh binding.
\end{macro}

\begin{function}{partition}{list \rest lambdas}{cl-ext}{}
  Split LIST into sub lists according to LAMBDAS. Each element of LIST
  will be passed to each element of LAMBDAS, the first function in
  LAMBDAS which returns T will cause that element to be collected into
  the corresponding list.
\end{function}

\begin{macro}{dotree}{name \body body}{cl-ext}{}
  Evaluate BODY with NAME bound to every element in TREE. Return RET-VAL.
\end{macro}

\begin{macro}{push*}{place \rest items \env env}{cl-ext}{}
  Pushes every element of ITEMS onto LIST. Equivalent to calling PUSH
  with each element of ITEMS.
\end{macro}

\begin{function}{append1}{\rest itens}{cl-ext}{}
  Append itens in the same list regardless if itens are lists or
  symbols.
\end{function}

\begin{function}{length=1}{list}{paip}{}
  Is x a list of length 1?
\end{function}

\begin{function}{partitionx}{list \rest lambdas}{cl-ext}{}

  used by fiveam
\end{function}

\begin{function}{make-pairs}{list}{}{}
  Break a list into pairs. 
\end{function}

