\chapter{Control Structures}

\begin{accessor}{fdefinition}{name}{}{}
  Return name's global function definition taking care to respect any
   encapsulations and to return the innermost encapsulated definition.
   This is SETF'able.
\end{accessor}

\begin{accessor}{values}{\rest values}{}{}
  Return all arguments, in order, as values.
\end{accessor}

\begin{constant}{call-arguments-limit}{}{}{}
  
\end{constant}

\begin{constant}{lambda-list-keywords}{}{}{}
  
\end{constant}

\begin{constant}{lambda-parameters-limit}{}{}{}
  
\end{constant}

\begin{constant}{multiple-values-limit}{}{}{}
  
\end{constant}

\begin{constant}{nil}{}{}{}
  
\end{constant}

\begin{constant}{t}{}{}{}
  
\end{constant}

\begin{function}{apply}{function arg \rest arguments}{}{}
  Apply FUNCTION to a list of arguments produced by evaluating ARGUMENTS in
  the manner of LIST*. That is, a list is made of the values of all but the
  last argument, appended to the value of the last argument, which must be a
  list.
\end{function}

\begin{function}{compiled-function-p}{object}{}{}
  Return true if OBJECT is a COMPILED-FUNCTION, and NIL otherwise.
\end{function}

\begin{function}{complement}{function}{}{}
  Return a new function that returns T whenever FUNCTION returns NIL and
   NIL whenever FUNCTION returns non-NIL.
\end{function}

\begin{function}{constantly}{value}{}{}
  Return a function that always returns VALUE.
\end{function}

\begin{function}{eq}{obj1 obj2}{}{}
  Return T if OBJ1 and OBJ2 are the same object, otherwise NIL.
\end{function}

\begin{function}{eql}{x y}{}{}
  
\end{function}

\begin{function}{equal}{x y}{}{}
  Return T if X and Y are EQL or if they are structured components whose
elements are EQUAL. Strings and bit-vectors are EQUAL if they are the same
length and have identical components. Other arrays must be EQ to be EQUAL.
\end{function}

\begin{function}{equalp}{x y}{}{}
  
\end{function}

\begin{function}{every}{pred first-seq \rest more-seqs}{}{}
  Apply PREDICATE to the 0-indexed elements of the sequences, then
   possibly to those with index 1, and so on. Return NIL as soon
   as any invocation of PREDICATE returns NIL, or T if every invocation
   is non-NIL.
\end{function}

\begin{function}{fboundp}{name}{}{}
  Return true if name has a global function definition.
\end{function}

\begin{function}{fmakunbound}{name}{}{}
  Make NAME have no global function definition.
\end{function}

\begin{function}{funcall}{function \rest arguments}{}{}
  Call FUNCTION with the given ARGUMENTS.
\end{function}

\begin{function}{function-lambda-expression}{fun}{}{}
  Return (VALUES DEFINING-LAMBDA-EXPRESSION CLOSURE-P NAME), where
  DEFINING-LAMBDA-EXPRESSION is NIL if unknown, or a suitable argument
  to COMPILE otherwise, CLOSURE-P is non-NIL if the function's definition
  might have been enclosed in some non-null lexical environment, and
  NAME is some name (for debugging only) or NIL if there is no name.
\end{function}

\begin{function}{functionp}{object}{}{}
  Return true if OBJECT is a FUNCTION, and NIL otherwise.
\end{function}

\begin{function}{get-setf-expansion}{form \op environment}{}{}
  Return five values needed by the SETF machinery: a list of temporary
   variables, a list of values with which to fill them, a list of temporaries
   for the new values, the setting function, and the accessing function.
\end{function}

\begin{function}{identity}{thing}{}{}
  This function simply returns what was passed to it.
\end{function}

\begin{function}{not}{object}{}{}
  Return T if X is NIL, otherwise return NIL.
\end{function}

\begin{function}{notany}{pred first-seq \rest more-seqs}{}{}
  Apply PREDICATE to the 0-indexed elements of the sequences, then
   possibly to those with index 1, and so on. Return NIL as soon
   as any invocation of PREDICATE returns a non-NIL value, or T if the end
   of any sequence is reached.
\end{function}

\begin{function}{notevery}{pred first-seq \rest more-seqs}{}{}
  Apply PREDICATE to 0-indexed elements of the sequences, then
   possibly to those with index 1, and so on. Return T as soon
   as any invocation of PREDICATE returns NIL, or NIL if every invocation
   is non-NIL.
\end{function}

\begin{function}{some}{pred first-seq \rest more-seqs}{}{}
  Apply PREDICATE to the 0-indexed elements of the sequences, then
   possibly to those with index 1, and so on. Return the first
   non-NIL value encountered, or NIL if the end of any sequence is reached.
\end{function}

\begin{function}{values-list}{list}{}{}
  Return all of the elements of LIST, in order, as values.
\end{function}

\begin{macro}{and}{\rest forms}{}{}
  
\end{macro}

\begin{macro}{case}{keyform \body cases}{}{}
  CASE Keyform {({(Key*) | Key} Form*)}*
  Evaluates the Forms in the first clause with a Key EQL to the value of
  Keyform. If a singleton key is T then the clause is a default clause.
\end{macro}

\begin{macro}{ccase}{keyform \body cases}{}{}
  CCASE Keyform {({(Key*) | Key} Form*)}*
  Evaluates the Forms in the first clause with a Key EQL to the value of
  Keyform. If none of the keys matches then a correctable error is
  signalled.
\end{macro}

\begin{macro}{cond}{\rest clauses}{}{}
  
\end{macro}

\begin{macro}{ctypecase}{keyform \body cases}{}{}
  CTYPECASE Keyform {(Type Form*)}*
  Evaluates the Forms in the first clause for which TYPEP of Keyform and Type
  is true. If no form is satisfied then a correctable error is signalled.
\end{macro}

\begin{macro}{defconstant}{name value \op documentation}{}{}
  Define a global constant, saying that the value is constant and may be
  compiled into code. If the variable already has a value, and this is not
  EQL to the new value, the code is not portable (undefined behavior). The
  third argument is an optional documentation string for the variable.
\end{macro}

\begin{macro}{define-modify-macro}{name lambda-list function \op doc-string}{}{}
  Creates a new read-modify-write macro like PUSH or INCF.
\end{macro}

\begin{macro}{define-setf-expander}{access-fn lambda-list \body body}{}{}
  Syntax like DEFMACRO, but creates a setf expander function. The body
  of the definition must be a form that returns five appropriate values.
\end{macro}

\begin{macro}{defparameter}{var val \op doc}{}{}
  Define a parameter that is not normally changed by the program,
  but that may be changed without causing an error. Declare the
  variable special and sets its value to VAL, overwriting any
  previous value. The third argument is an optional documentation
  string for the parameter.
\end{macro}

\begin{macro}{defsetf}{access-fn \rest rest}{}{}
  Associates a SETF update function or macro with the specified access
  function or macro. The format is complex. See the manual for details.
\end{macro}

\begin{macro}{defun}{\env env name args \body body}{}{}
  Define a function at top level.
\end{macro}

\begin{macro}{defvar}{var \op val doc}{}{}
  Define a global variable at top level. Declare the variable
  SPECIAL and, optionally, initialize it. If the variable already has a
  value, the old value is not clobbered. The third argument is an optional
  documentation string for the variable.
\end{macro}

\begin{macro}{destructuring-bind}{lambda-list expression \body body}{}{}
  Bind the variables in LAMBDA-LIST to the corresponding values in the
tree structure resulting from the evaluation of EXPRESSION.
\end{macro}

\begin{macro}{ecase}{keyform \body cases}{}{}
  ECASE Keyform {({(Key*) | Key} Form*)}*
  Evaluates the Forms in the first clause with a Key EQL to the value of
  Keyform. If none of the keys matches then an error is signalled.
\end{macro}

\begin{macro}{etypecase}{keyform \body cases}{}{}
  ETYPECASE Keyform {(Type Form*)}*
  Evaluates the Forms in the first clause for which TYPEP of Keyform and Type
  is true. If no form is satisfied then an error is signalled.
\end{macro}

\begin{macro}{multiple-value-bind}{vars value-form \body body}{}{}
  
\end{macro}

\begin{macro}{multiple-value-list}{value-form}{}{}
  
\end{macro}

\begin{macro}{multiple-value-setq}{vars value-form}{}{}
  
\end{macro}

\begin{macro}{nth-value}{n form}{}{}
  Evaluate FORM and return the Nth value (zero based). This involves no
  consing when N is a trivial constant integer.
\end{macro}

\begin{macro}{or}{\rest forms}{}{}
  
\end{macro}

\begin{macro}{prog}{varlist \body body-decls}{}{}
  
\end{macro}

\begin{macro}{prog*}{varlist \body body-decls}{}{}
  
\end{macro}

\begin{macro}{prog1}{result \body body}{}{}
  
\end{macro}

\begin{macro}{prog2}{form1 result \body body}{}{}
  
\end{macro}

\begin{macro}{psetf}{\rest args \env env}{}{}
  This is to SETF as PSETQ is to SETQ. Args are alternating place
  expressions and values to go into those places. All of the subforms and
  values are determined, left to right, and only then are the locations
  updated. Returns NIL.
\end{macro}

\begin{macro}{psetq}{\rest pairs}{}{}
  PSETQ {var value}*
   Set the variables to the values, like SETQ, except that assignments
   happen in parallel, i.e. no assignments take place until all the
   forms have been evaluated.
\end{macro}

\begin{macro}{return}{\op value}{}{}
  
\end{macro}

\begin{macro}{rotatef}{\rest args \env env}{}{}
  Takes any number of SETF-style place expressions. Evaluates all of the
   expressions in turn, then assigns to each place the value of the form to
   its right. The rightmost form gets the value of the leftmost.
   Returns NIL.
\end{macro}

\begin{macro}{setf}{\rest args \env env}{}{}
  Takes pairs of arguments like SETQ. The first is a place and the second
  is the value that is supposed to go into that place. Returns the last
  value. The place argument may be any of the access forms for which SETF
  knows a corresponding setting form.
\end{macro}

\begin{macro}{shiftf}{\whole form \rest args \env env}{}{}
  One or more SETF-style place expressions, followed by a single
   value expression. Evaluates all of the expressions in turn, then
   assigns the value of each expression to the place on its left,
   returning the value of the leftmost.
\end{macro}

\begin{macro}{typecase}{keyform \body cases}{}{}
  TYPECASE Keyform {(Type Form*)}*
  Evaluates the Forms in the first clause for which TYPEP of Keyform and Type
  is true.
\end{macro}

\begin{macro}{unless}{test \body forms}{}{}
  If the first argument is not true, the rest of the forms are
evaluated as a PROGN.
\end{macro}

\begin{macro}{when}{test \body forms}{}{}
  If the first argument is true, the rest of the forms are
evaluated as a PROGN.
\end{macro}

\begin{specialop}{block}{name \rest forms}{}{}
  BLOCK name form*

Evaluate the FORMS as a PROGN. Within the lexical scope of the body,
RETURN-FROM can be used to exit the form.
\end{specialop}

\begin{specialop}{catch}{tag \body body}{}{}
  CATCH tag form*

Evaluate TAG and instantiate it as a catcher while the body forms are
evaluated in an implicit PROGN. If a THROW is done to TAG within the dynamic
scope of the body, then control will be transferred to the end of the body and
the thrown values will be returned.
\end{specialop}

\begin{specialop}{flet}{definitions \body body}{}{}
  FLET ({(name lambda-list declaration* form*)}*) declaration* body-form*

Evaluate the BODY-FORMS with local function definitions. The bindings do
not enclose the definitions; any use of NAME in the FORMS will refer to the
lexically apparent function definition in the enclosing environment.
\end{specialop}

\begin{specialop}{function}{thing}{}{}
  FUNCTION name

Return the lexically apparent definition of the function NAME. NAME may also
be a lambda expression.
\end{specialop}

\begin{specialop}{go}{tag}{}{}
  GO tag

Transfer control to the named TAG in the lexically enclosing TAGBODY. This is
constrained to be used only within the dynamic extent of the TAGBODY.
\end{specialop}

\begin{specialop}{if}{test then \op else}{}{}
  IF predicate then [else]

If PREDICATE evaluates to false, evaluate THEN and return its values,
otherwise evaluate ELSE and return its values. ELSE defaults to NIL.
\end{specialop}

\begin{specialop}{labels}{definitions \body body}{}{}
  LABELS ({(name lambda-list declaration* form*)}*) declaration* body-form*

Evaluate the BODY-FORMS with local function definitions. The bindings enclose
the new definitions, so the defined functions can call themselves or each
other.
\end{specialop}

\begin{specialop}{let}{bindings \body body}{}{}
  LET ({(var [value]) | var}*) declaration* form*

During evaluation of the FORMS, bind the VARS to the result of evaluating the
VALUE forms. The variables are bound in parallel after all of the VALUES forms
have been evaluated.
\end{specialop}

\begin{specialop}{let*}{bindings \body body}{}{}
  LET* ({(var [value]) | var}*) declaration* form*

Similar to LET, but the variables are bound sequentially, allowing each VALUE
form to reference any of the previous VARS.
\end{specialop}

\begin{specialop}{macrolet}{definitions \rest body}{}{}
  MACROLET ({(name lambda-list form*)}*) body-form*

Evaluate the BODY-FORMS in an environment with the specified local macros
defined. Name is the local macro name, LAMBDA-LIST is a DEFMACRO style
destructuring lambda list, and the FORMS evaluate to the expansion.
\end{specialop}

\begin{specialop}{multiple-value-call}{fun \rest args}{}{}
  MULTIPLE-VALUE-CALL function values-form*

Call FUNCTION, passing all the values of each VALUES-FORM as arguments,
values from the first VALUES-FORM making up the first argument, etc.
\end{specialop}

\begin{specialop}{multiple-value-prog1}{values-form \rest forms}{}{}
  MULTIPLE-VALUE-PROG1 values-form form*

Evaluate VALUES-FORM and then the FORMS, but return all the values of
VALUES-FORM.
\end{specialop}

\begin{specialop}{progn}{\rest forms}{}{}
  PROGN form*

Evaluates each FORM in order, returning the values of the last form. With no
forms, returns NIL.
\end{specialop}

\begin{specialop}{progv}{vars vals \body body}{}{}
  
\end{specialop}

\begin{specialop}{return-from}{name \op value}{}{}
  RETURN-FROM block-name value-form

Evaluate the VALUE-FORM, returning its values from the lexically enclosing
block BLOCK-NAME. This is constrained to be used only within the dynamic
extent of the block.
\end{specialop}

\begin{specialop}{tagbody}{\rest statements}{}{}
  TAGBODY {tag | statement}*

Define tags for use with GO. The STATEMENTS are evaluated in order ,skipping
TAGS, and NIL is returned. If a statement contains a GO to a defined TAG
within the lexical scope of the form, then control is transferred to the next
statement following that tag. A TAG must an integer or a symbol. A STATEMENT
must be a list. Other objects are illegal within the body.
\end{specialop}

\begin{specialop}{throw}{tag result}{}{}
  THROW tag form

Do a non-local exit, return the values of FORM from the CATCH whose tag is EQ
to TAG.
\end{specialop}

\begin{specialop}{unwind-protect}{protected \body cleanup}{}{}
  UNWIND-PROTECT protected cleanup*

Evaluate the form PROTECTED, returning its values. The CLEANUP forms are
evaluated whenever the dynamic scope of the PROTECTED form is exited (either
due to normal completion or a non-local exit such as THROW).
\end{specialop}

\section{Extensions}
\label{sec:extensions}

\begin{macro}{if-let}{bindings \body then-form}{alexandria}{}
  Creates new variable bindings, and conditionally executes either
THEN-FORM or ELSE-FORM. ELSE-FORM defaults to NIL.

BINDINGS must be either single binding of the form:

 (variable initial-form)

or a list of bindings of the form:

 ((variable-1 initial-form-1)
  (variable-2 initial-form-2)
  ...
  (variable-n initial-form-n))

All initial-forms are executed sequentially in the specified order. Then all
the variables are bound to the corresponding values.

If all variables were bound to true values, the THEN-FORM is executed with the
bindings in effect, otherwise the ELSE-FORM is executed with the bindings in
effect.
\end{macro}

\begin{macro}{when-let}{bindings \body forms}{alexandria}{}
  Creates new variable bindings, and conditionally executes FORMS.

BINDINGS must be either single binding of the form:

 (variable initial-form)

or a list of bindings of the form:

 ((variable-1 initial-form-1)
  (variable-2 initial-form-2)
  ...
  (variable-n initial-form-n))

All initial-forms are executed sequentially in the specified order. Then all
the variables are bound to the corresponding values.

If all variables were bound to true values, then FORMS are executed as an
implicit PROGN.
\end{macro}

\begin{macro}{when-let*}{bindings \body forms}{alexandria}{}
  Creates new variable bindings, and conditionally executes FORMS.

BINDINGS must be either single binding of the form:

 (variable initial-form)

or a list of bindings of the form:

 ((variable-1 initial-form-1)
  (variable-2 initial-form-2)
  ...
  (variable-n initial-form-n))

Each initial-form is executed in turn, and the variable bound to the
corresponding value. Initial-form expressions can refer to variables
previously bound by the WHEN-LET*.

Execution of WHEN-LET* stops immediately if any initial-form evaluates to NIL.
If all initial-forms evaluate to true, then FORMS are executed as an implicit
PROGN.
\end{macro}

\begin{macro}{cswitch}{\whole whole object \body clauses}{alexandria}{}
  Like SWITCH, but signals a continuable error if no key matches.
\end{macro}

\begin{macro}{eswitch}{\whole whole object \body clauses}{alexandria}{}
  Like SWITCH, but signals an error if no key matches.
\end{macro}

\begin{macro}{switch}{\whole whole object \body clauses}{alexandria}{}
  Evaluates first matching clause, returning its values, or evaluates and
returns the values of DEFAULT if no keys match.
\end{macro}

\begin{macro}{xor}{\rest datums}{alexandria}{}
  Evaluates its argument one at a time, from left to right. If more then one
argument evaluates to a true value no further DATUMS are evaluated, and NIL is
returned as both primary and secondary value. If exactly one argument
evaluates to true, its value is returned as the primary value after all the
arguments have been evaluated, and T is returned as the secondary value. If no
arguments evaluate to true NIL is retuned as primary, and T as secondary
value.
\end{macro}

\begin{macro}{nth-value-or}{nth-value \body forms}{alexandria}{}
  Evaluates FORM arguments one at a time, until the NTH-VALUE returned by one
of the forms is non-NIL. It then returns all the values returned by evaluating
that form. If none of the forms return a non-nil nth value, this form returns
NIL.
\end{macro}

\begin{macro}{define-constant}{name initial-value \key test documentation}{alexandria}{}
  Ensures that the global variable named by NAME is a constant with a value
that is equal under TEST to the result of evaluating INITIAL-VALUE. TEST is a
/function designator/ that defaults to EQL. If DOCUMENTATION is given, it
becomes the documentation string of the constant.

Signals an error if NAME is already a bound non-constant variable.

Signals an error if NAME is already a constant variable whose value is not
equal under TEST to result of evaluating INITIAL-VALUE.
\end{macro}

\begin{macro}{whichever}{\rest possibilities \env env}{alexandria}{}
  Evaluates exactly one of POSSIBILITIES, chosen at random.
\end{macro}

