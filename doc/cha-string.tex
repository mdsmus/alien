\chapter{Strings}
\label{cha:strings}

See also the chapter on sequences () for functions to split strings and
since strings are array see also the chapter on arrays.

\begin{type}{string-designator}{}[cl-ext]
  A string designator type. A string designator is either a string, a
  symbol, or a character.
\end{type}

\section{Predicates}
\label{sec:string-predicates}

See also string-greaterp, \funr{string-lessp},
\funr{string-not-greaterp}, and \funr{string-not-lessp}.

\begin{function}{stringp}{object}
  Return true if OBJECT is a STRING, and NIL otherwise.
\end{function}

\begin{function}{simple-string-p}{object}
  Return true if OBJECT is a SIMPLE-STRING, and NIL otherwise.
\end{function}

\begin{function}{empty-string-p}{string}[cl-ext]
  Indicates, if a given string is empty (or being nil)
\end{function}

\section{String constants}
\label{sec:string-constants}

\begin{constant}{+lower-case-ascii-alphabet+}{}[cl-ext]
  All the lower case letters in 7 bit ASCII.
\end{constant}

\begin{constant}{+upper-case-ascii-alphabet+}{}[cl-ext]
  All the upper case letters in 7 bit ASCII.
\end{constant}

\begin{constant}{+alphanumeric-ascii-alphabet+}{}[cl-ext]
  All the letters and numbers in 7 bit ASCII.
\end{constant}

\begin{constant}{+ascii-alphabet+}{}[cl-ext]
  All letters in 7 bit ASCII.
\end{constant}

\begin{constant}{+base64-alphabet+}{}[cl-ext]
  All the characters allowed in base64 encoding.
\end{constant}

\section{String access}
\label{sec:string-access}

\begin{accessor}{char}{string index}
  Given a string and a non-negative integer index less than the length of
  the string, returns the character object representing the character at
  that position in the string.
\end{accessor}

\begin{accessor}{schar}{string index}
  SCHAR returns the character object at an indexed position in a string
   just as CHAR does, except the string must be a simple-string.
\end{accessor}

\section{Comparison}
\label{sec:string-comparison}

\begin{function}{string/=}{string1 string2 \key start1 end1 start2 end2}
  Given two strings, if the first string is not lexicographically equal
  to the second string, returns the longest common prefix (using char=)
  of the two strings. Otherwise, returns ().
\end{function}

\begin{function}{string<}{string1 string2 \key start1 end1 start2 end2}
  Given two strings, if the first string is lexicographically less than
  the second string, returns the longest common prefix (using char=)
  of the two strings. Otherwise, returns ().
\end{function}

\begin{function}{string<=}{string1 string2 \key start1 end1 start2 end2}
  Given two strings, if the first string is lexicographically less than
  or equal to the second string, returns the longest common prefix
  (using char=) of the two strings. Otherwise, returns ().
\end{function}

\begin{function}{string=}{string1 string2 \key start1 end1 start2 end2}
  Given two strings (string1 and string2), and optional integers start1,
  start2, end1 and end2, compares characters in string1 to characters in
  string2 (using char=).
\end{function}

\begin{function}{string>}{string1 string2 \key start1 end1 start2 end2}
  Given two strings, if the first string is lexicographically greater than
  the second string, returns the longest common prefix (using char=)
  of the two strings. Otherwise, returns ().
\end{function}

\begin{function}{string>=}{string1 string2 \key start1 end1 start2 end2}
  Given two strings, if the first string is lexicographically greater
  than or equal to the second string, returns the longest common prefix
  (using char=) of the two strings. Otherwise, returns ().
\end{function}

The following functions are just like \fun{string<}, \fun{string>}, \fun{string<=},
\fun{string>=}, and \fun{string/=} except they are case insensitive.

\begin{function}{string-equal}{string1 string2 \key start1 end1 start2 end2}
  Given two strings (string1 and string2), and optional integers start1,
  start2, end1 and end2, compares characters in string1 to characters in
  string2 (using char-equal).
\end{function}

\begin{function}{string-greaterp}{string1 string2 \key start1 end1 start2 end2}
  Given two strings, if the first string is lexicographically greater than
  the second string, returns the longest common prefix (using char-equal)
  of the two strings. Otherwise, returns ().
\end{function}

\begin{function}{string-lessp}{string1 string2 \key start1 end1 start2 end2}
  Given two strings, if the first string is lexicographically less than
  the second string, returns the longest common prefix (using char-equal)
  of the two strings. Otherwise, returns ().
\end{function}

\begin{function}{string-not-equal}{string1 string2 \key start1 end1 start2 end2}
  Given two strings, if the first string is not lexicographically equal
  to the second string, returns the longest common prefix (using char-equal)
  of the two strings. Otherwise, returns ().
\end{function}

\begin{function}{string-not-greaterp}{string1 string2 \key start1 end1 start2 end2}
  Given two strings, if the first string is lexicographically less than
  or equal to the second string, returns the longest common prefix
  (using char-equal) of the two strings. Otherwise, returns ().
\end{function}

\begin{function}{string-not-lessp}{string1 string2 \key start1 end1 start2 end2}
  Given two strings, if the first string is lexicographically greater
  than or equal to the second string, returns the longest common prefix
  (using char-equal) of the two strings. Otherwise, returns ().
\end{function}

\section{Construction and manipulation}
\label{sec:constr-manip}

\begin{function}{string}{x}
  Coerces X into a string. If X is a string, X is returned. If X is a
   symbol, X's pname is returned. If X is a character then a one element
   string containing that character is returned. If X cannot be coerced
   into a string, an error occurs.
\end{function}

\begin{function}{make-string}{count \key element-type (initial-element fill-char)}
  Given a character count and an optional fill character, makes and returns a
new string COUNT long filled with the fill character.
\end{function}

\begin{function}{random-string}{\op length alphabet}[cl-ext]
  Returns a random alphabetic string. The returned string will contain
  LENGTH characters chosen from the vector ALPHABET.
\end{function}

\begin{function}{string-trim}{char-bag string}
  
\end{function}

\begin{function}{string-left-trim}{char-bag string}
  
\end{function}

\begin{function}{string-right-trim}{char-bag string}
  
\end{function}

\begin{function}{string-downcase}{string \key start end}
  
\end{function}

\begin{function}{string-upcase}{string \key start end}
  
\end{function}

\begin{function}{string-capitalize}{string \key start end}
  
\end{function}

\begin{function}{nstring-downcase}{string \key start end}
  
\end{function}

\begin{function}{nstring-upcase}{string \key start end}
  
\end{function}

\begin{function}{nstring-capitalize}{string \key start end}
  
\end{function}

\begin{function}{strcat}{\rest items}[cl-ext]
  Returns a fresh string consisting of ITEMS concat'd together.
\end{function}

\begin{function}{strcat*}{string-designators}[cl-ext]
  Concatenate all the strings in STRING-DESIGNATORS.
\end{function}

\begin{function}{join-strings}{strings}[cl-ext]
  Concatenate strings. It's a fast shorthand for \code{(concatenate
    'string string1 \ldots stringn)}.
\end{function}

\begin{function}{fold-strings}{}[cl-ext]
  
\end{function}

\begin{function}{split-tabs}{string}[cl-ext]
  Utility function to split a string by tabs and remove empty
  subsequences.
\end{function}

\begin{function}{split-newline}{string}[cl-ext]
  Utility function to split a string by newlines and remove empty
  subsequences.
\end{function}

\begin{function}{replace-all}{part string replacement \key test}[cl-ext]
  Returns a new string in which all the occurences of the part is
  replaced with replacement. It was taken from the cl-cookbook, it's
  not as optimized as cl-ppcre, but if you just want to replace
  strings it may be faster in some cases.
\end{function}

\begin{function}{string-from-array}{array \key start end}[cl-ext]
  Assuming ARRAY is an array of ASCII chars encoded as bytes return
the corresponding string. Respect the C convention of null terminating
strings. START and END specify the zero indexed offsets of a sub range
of ARRAY.
\end{function}

\begin{function}{octets-to-string}{octets encoding}[cl-ext]
  
\end{function}

\begin{function}{string-to-octets}{string encoding}[cl-ext]
  Convert STRING, a list string, a vector of bytes according to ENCODING.

ENCODING is a keyword representing the desired character
encoding. We gurantee that :UTF-8, :UTF-16 and :ISO-8859-1 will
work as expected. Any other values are simply passed to the
underlying lisp's function and the results are implementation
dependant.

On CLISP we intern the ENCODING symbol in the CHARSET package and
pass that. On SBCL we simply pass the keyword.
\end{function}

\begin{function}{encoding-keyword-to-native}{encoding}[cl-ext]
  Convert ENCODING, a keyword, to an object the native list
accepts as an encoding.

ENCODING can be: :UTF-8, :UTF-16, or :US-ASCII and specify the
corresponding encodings. Any other keyword is passed, as is, to
the underlying lisp.
\end{function}

\section{String reading}
\label{sec:string-reading}

\begin{function}{parse-integer}{string \key start end radix junk-allowed}
  Examine the substring of string delimited by start and end
  (default to the beginning and end of the string)  It skips over
  whitespace characters and then tries to parse an integer. The
  radix parameter must be between 2 and 36.
\end{function}

\begin{function}{parse-float}{float-string \key start end radix junk-allowed type decimal-character}[cl-ext]
\end{function}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: cl-dist-manual.tex
%%% End:
