\chapter{Input and Output}

\section{Reader}

\begin{accessor}{readtable-case}{readtable}
  
\end{accessor}

\begin{function}{copy-readtable}{\op from-readtable to-readtable}
  
\end{function}

\begin{function}{get-dispatch-macro-character}{disp-char sub-char \op rt-designator}
  Return the macro character function for SUB-CHAR under DISP-CHAR
   or NIL if there is no associated function.
\end{function}

\begin{function}{get-macro-character}{char \op rt-designator}
  Return the function associated with the specified CHAR which is a macro
  character, or NIL if there is no such function. As a second value, return
  T if CHAR is a macro character which is non-terminating, i.e. which can
  be embedded in a symbol name.
\end{function}

\begin{function}{make-dispatch-macro-character}{char \op non-terminating-p rt}
  Cause CHAR to become a dispatching macro character in readtable (which
   defaults to the current readtable). If NON-TERMINATING-P, the char will
   be non-terminating.
\end{function}

\begin{function}{read}{\op stream eof-error-p eof-value recursive-p}
  Read the next Lisp value from STREAM, and return it.
\end{function}

\begin{function}{read-delimited-list}{endchar \op input-stream recursive-p}
  Read Lisp values from INPUT-STREAM until the next character after a
   value's representation is ENDCHAR, and return the objects as a list.
\end{function}

\begin{function}{read-from-string}{string \op eof-error-p eof-value \key start end preserve-whitespace}
  The characters of string are successively given to the lisp reader
   and the lisp object built by the reader is returned. Macro chars
   will take effect.
\end{function}

\begin{function}{read-preserving-whitespace}{\op stream eof-error-p eof-value recursive-p}
  Read from STREAM and return the value read, preserving any whitespace
   that followed the object.
\end{function}

\begin{function}{readtablep}{object}
  
\end{function}

\begin{function}{set-dispatch-macro-character}{disp-char sub-char function \op rt-designator}
  Cause FUNCTION to be called whenever the reader reads DISP-CHAR
   followed by SUB-CHAR.
\end{function}

\begin{function}{set-macro-character}{char function \op non-terminatingp rt-designator}
  Causes CHAR to be a macro character which invokes FUNCTION when seen
   by the reader. The NON-TERMINATINGP flag can be used to make the macro
   character non-terminating, i.e. embeddable in a symbol name.
\end{function}

\begin{function}{set-syntax-from-char}{to-char from-char \op to-readtable from-readtable}
  Causes the syntax of TO-CHAR to be the same as FROM-CHAR in the optional
readtable (defaults to the current readtable). The FROM-TABLE defaults to the
standard Lisp readtable when NIL.
\end{function}

\begin{macro}{with-standard-io-syntax}{\body body}
  Bind the reader and printer control variables to values that enable READ
   to reliably read the results of PRINT. These values are:
       *PACKAGE*                        the COMMON-LISP-USER package
       *PRINT-ARRAY*                    T
       *PRINT-BASE*                     10
       *PRINT-CASE*                     :UPCASE
       *PRINT-CIRCLE*                   NIL
       *PRINT-ESCAPE*                   T
       *PRINT-GENSYM*                   T
       *PRINT-LENGTH*                   NIL
       *PRINT-LEVEL*                    NIL
       *PRINT-LINES*                    NIL
       *PRINT-MISER-WIDTH*              NIL
       *PRINT-PRETTY*                   NIL
       *PRINT-RADIX*                    NIL
       *PRINT-READABLY*                 T
       *PRINT-RIGHT-MARGIN*             NIL
       *READ-BASE*                      10
       *READ-DEFAULT-FLOAT-FORMAT*      SINGLE-FLOAT
       *READ-EVAL*                      T
       *READ-SUPPRESS*                  NIL
       *READTABLE*                      the standard readtable
\end{macro}

\begin{class}{readtable}{}
  
\end{class}

\begin{variable}{*read-base*}{}
  
\end{variable}

\begin{variable}{*read-default-float-format*}{}
  
\end{variable}

\begin{variable}{*read-eval*}{}
  
\end{variable}

\begin{variable}{*read-suppress*}{}
  
\end{variable}

\begin{variable}{*readtable*}{}
  
\end{variable}

\section{Printer}

\begin{function}{copy-pprint-dispatch}{\op table}
  
\end{function}

\begin{function}{format}{destination control-string \rest format-arguments}
  Provides various facilities for formatting output.
  CONTROL-STRING contains a string to be output, possibly with embedded
  directives, which are flagged with the escape character "\~{}\%". Directives
  generally expand into additional text to be output, usually consuming one
  or more of the FORMAT-ARGUMENTS in the process. A few useful directives
  are:
        \~{}\%A or \~{}\%nA   Prints one argument as if by PRINC
        \~{}\%S or \~{}\%nS   Prints one argument as if by PRIN1
        \~{}\%D or \~{}\%nD   Prints one argument as a decimal integer
        \~{}\%\%          Does a TERPRI
        \~{}\%\&          Does a FRESH-LINE
  where n is the width of the field in which the object is printed.

  DESTINATION controls where the result will go. If DESTINATION is T, then
  the output is sent to the standard output stream. If it is NIL, then the
  output is returned in a string as the value of the call. Otherwise,
  DESTINATION must be a stream to which the output will be sent.

  Example:   (FORMAT NIL "The answer is \~{}\%D." 10) => "The answer is 10."

  FORMAT has many additional capabilities not described here. Consult the
  manual for details.
\end{function}

\begin{function}{pprint}{object \op stream}
  Prettily output OBJECT preceded by a newline.
\end{function}

\begin{function}{pprint-dispatch}{object \op table}
  
\end{function}

\begin{function}{pprint-fill}{stream list \op colon? atsign?}
  Output LIST to STREAM putting :FILL conditional newlines between each
   element. If COLON? is NIL (defaults to T), then no parens are printed
   around the output. ATSIGN? is ignored (but allowed so that PPRINT-FILL
   can be used with the \~{}\%/.../ format directive.
\end{function}

\begin{function}{pprint-indent}{relative-to n \op stream}
  Specify the indentation to use in the current logical block if
STREAM (which defaults to *STANDARD-OUTPUT*) is a pretty-printing
stream and do nothing if not. (See PPRINT-LOGICAL-BLOCK.) N is the
indentation to use (in ems, the width of an ``m'') and RELATIVE-TO can
be either:

     :BLOCK - Indent relative to the column the current logical block
        started on.

     :CURRENT - Indent relative to the current column.

The new indentation value does not take effect until the following
line break.
\end{function}

\begin{function}{pprint-linear}{stream list \op colon? atsign?}
  Output LIST to STREAM putting :LINEAR conditional newlines between each
   element. If COLON? is NIL (defaults to T), then no parens are printed
   around the output. ATSIGN? is ignored (but allowed so that PPRINT-LINEAR
   can be used with the \~{}\%/.../ format directive.
\end{function}

\begin{function}{pprint-newline}{kind \op stream}
  Output a conditional newline to STREAM (which defaults to
   *STANDARD-OUTPUT*) if it is a pretty-printing stream, and do
   nothing if not. KIND can be one of:
     :LINEAR - A line break is inserted if and only if the immediatly
        containing section cannot be printed on one line.
     :MISER - Same as LINEAR, but only if ``miser-style'' is in effect.
        (See *PRINT-MISER-WIDTH*.)
     :FILL - A line break is inserted if and only if either:
       (a) the following section cannot be printed on the end of the
           current line,
       (b) the preceding section was not printed on a single line, or
       (c) the immediately containing section cannot be printed on one
           line and miser-style is in effect.
     :MANDATORY - A line break is always inserted.
   When a line break is inserted by any type of conditional newline, any
   blanks that immediately precede the conditional newline are ommitted
   from the output and indentation is introduced at the beginning of the
   next line. (See PPRINT-INDENT.)
\end{function}

\begin{function}{pprint-tab}{kind colnum colinc \op stream}
  If STREAM (which defaults to *STANDARD-OUTPUT*) is a pretty-printing
   stream, perform tabbing based on KIND, otherwise do nothing. KIND can
   be one of:
     :LINE - Tab to column COLNUM. If already past COLNUM tab to the next
       multiple of COLINC.
     :SECTION - Same as :LINE, but count from the start of the current
       section, not the start of the line.
     :LINE-RELATIVE - Output COLNUM spaces, then tab to the next multiple of
       COLINC.
     :SECTION-RELATIVE - Same as :LINE-RELATIVE, but count from the start
       of the current section, not the start of the line.
\end{function}

\begin{function}{pprint-tabular}{stream list \op colon? atsign? tabsize}
  Output LIST to STREAM tabbing to the next column that is an even multiple
   of TABSIZE (which defaults to 16) between each element. :FILL style
   conditional newlines are also output between each element. If COLON? is
   NIL (defaults to T), then no parens are printed around the output.
   ATSIGN? is ignored (but allowed so that PPRINT-TABULAR can be used with
   the \~{}\%/.../ format directive.
\end{function}

\begin{function}{prin1}{object \op stream}
  Output a mostly READable printed representation of OBJECT on the specified
  STREAM.
\end{function}

\begin{function}{prin1-to-string}{object}
  Return the printed representation of OBJECT as a string with
   slashification on.
\end{function}

\begin{function}{princ}{object \op stream}
  Output an aesthetic but not necessarily READable printed representation
  of OBJECT on the specified STREAM.
\end{function}

\begin{function}{princ-to-string}{object}
  Return the printed representation of OBJECT as a string with
  slashification off.
\end{function}

\begin{function}{print}{object \op stream}
  Output a newline, the mostly READable printed representation of OBJECT, and
  space to the specified STREAM.
\end{function}

\begin{function}{print-not-readable-object}{condition}
  
\end{function}

\begin{function}{set-pprint-dispatch}{type function \op priority table}
  
\end{function}

\begin{function}{write}{object \key (stream stream) (escape *print-escape*) (radix *print-radix*)
 (base *print-base*) (circle *print-circle*) (pretty *print-pretty*)
 (level *print-level*) (length *print-length*) (case *print-case*)
 (array *print-array*) (gensym *print-gensym*) (readably *print-readably*)
 (right-margin *print-right-margin*) (miser-width *print-miser-width*)
 (lines *print-lines*) (pprint-dispatch *print-pprint-dispatch*)}
  Output OBJECT to the specified stream, defaulting to *STANDARD-OUTPUT*
\end{function}

\begin{function}{write-to-string}{object \key (escape *print-escape*) (radix *print-radix*) (base *print-base*)
 (circle *print-circle*) (pretty *print-pretty*) (level *print-level*)
 (length *print-length*) (case *print-case*) (array *print-array*)
 (gensym *print-gensym*) (readably *print-readably*)
 (right-margin *print-right-margin*) (miser-width *print-miser-width*)
 (lines *print-lines*) (pprint-dispatch *print-pprint-dispatch*)}
  Return the printed representation of OBJECT as a string.
\end{function}

\begin{generic}{print-object}{object stream}
  
\end{generic}

\begin{macro}{formatter}{control-string}
  
\end{macro}

\begin{macro}{pprint-logical-block}{stream-symbol \body body \env env}
  Group some output into a logical block. STREAM-SYMBOL should be either a
   stream, T (for *TERMINAL-IO*), or NIL (for *STANDARD-OUTPUT*). The printer
   control variable *PRINT-LEVEL* is automatically handled.
\end{macro}

\begin{macro}{print-unreadable-object}{object \body body}
  Output OBJECT to STREAM with "\#<" prefix, ">" suffix, optionally
  with object-type prefix and object-identity suffix, and executing the
  code in BODY to provide possible further output.
\end{macro}

\begin{variable}{*print-array*}{}
  
\end{variable}

\begin{variable}{*print-base*}{}
  
\end{variable}

\begin{variable}{*print-case*}{}
  
\end{variable}

\begin{variable}{*print-circle*}{}
  
\end{variable}

\begin{variable}{*print-escape*}{}
  
\end{variable}

\begin{variable}{*print-gensym*}{}
  
\end{variable}

\begin{variable}{*print-length*}{}
  
\end{variable}

\begin{variable}{*print-level*}{}
  
\end{variable}

\begin{variable}{*print-lines*}{}
  
\end{variable}

\begin{variable}{*print-miser-width*}{}
  
\end{variable}

\begin{variable}{*print-pprint-dispatch*}{}
  
\end{variable}

\begin{variable}{*print-pretty*}{}
  
\end{variable}

\begin{variable}{*print-radix*}{}
  
\end{variable}

\begin{variable}{*print-readably*}{}
  
\end{variable}

\begin{variable}{*print-right-margin*}{}
  
\end{variable}

\section{Format}

\section{Streams}

\begin{function}{broadcast-stream-streams}{instance}
  
\end{function}

\begin{function}{clear-input}{\op stream}
  
\end{function}

\begin{function}{clear-output}{\op stream}
  
\end{function}

\begin{function}{close}{stream \key abort}
  Close the given STREAM. No more I/O may be performed, but
  inquiries may still be made. If :ABORT is true, an attempt is made
  to clean up the side effects of having created the stream.
\end{function}

\begin{function}{concatenated-stream-streams}{instance}
  
\end{function}

\begin{function}{echo-stream-input-stream}{instance}
  
\end{function}

\begin{function}{echo-stream-output-stream}{instance}
  
\end{function}

\begin{function}{file-length}{stream}
  
\end{function}

\begin{function}{file-position}{stream \op position}
  
\end{function}

\begin{function}{file-string-length}{stream object}
  
\end{function}

\begin{function}{finish-output}{\op stream}
  
\end{function}

\begin{function}{force-output}{\op stream}
  
\end{function}

\begin{function}{fresh-line}{\op stream}
  
\end{function}

\begin{function}{get-output-stream-string}{stream}
  
\end{function}

\begin{function}{input-stream-p}{stream}
  Can STREAM perform input operations?
\end{function}

\begin{function}{interactive-stream-p}{stream}
  Is STREAM an interactive stream?
\end{function}

\begin{function}{listen}{\op stream}
  
\end{function}

\begin{function}{make-broadcast-stream}{\rest streams}
  
\end{function}

\begin{function}{make-concatenated-stream}{\rest streams}
  Return a stream which takes its input from each of the streams in turn,
   going on to the next at EOF.
\end{function}

\begin{function}{make-echo-stream}{input-stream output-stream}
  Return a bidirectional stream which gets its input from INPUT-STREAM and
   sends its output to OUTPUT-STREAM. In addition, all input is echoed to
   the output stream.
\end{function}

\begin{function}{make-string-input-stream}{string \op start end}
  Return an input stream which will supply the characters of STRING between
  START and END in order.
\end{function}

\begin{function}{make-string-output-stream}{\key element-type \aux buffer}
  Return an output stream which will accumulate all output given it for the
benefit of the function GET-OUTPUT-STREAM-STRING.
\end{function}

\begin{function}{make-synonym-stream}{symbol}
  
\end{function}

\begin{function}{make-two-way-stream}{input-stream output-stream}
  Return a bidirectional stream which gets its input from INPUT-STREAM and
   sends its output to OUTPUT-STREAM.
\end{function}

\begin{function}{open}{filename \key direction element-type if-exists if-does-not-exist
 external-format \aux direction if-does-not-exist if-exists}
  Return a stream which reads from or writes to FILENAME.
  Defined keywords:
   :DIRECTION - one of :INPUT, :OUTPUT, :IO, or :PROBE
   :ELEMENT-TYPE - the type of object to read or write, default BASE-CHAR
   :IF-EXISTS - one of :ERROR, :NEW-VERSION, :RENAME, :RENAME-AND-DELETE,
                       :OVERWRITE, :APPEND, :SUPERSEDE or NIL
   :IF-DOES-NOT-EXIST - one of :ERROR, :CREATE or NIL
  See the manual for details.
\end{function}

\begin{function}{open-stream-p}{stream}
  Return true if STREAM is not closed. A default method is provided
  by class FUNDAMENTAL-STREAM which returns true if CLOSE has not been
  called on the stream.
\end{function}

\begin{function}{output-stream-p}{stream}
  Can STREAM perform output operations?
\end{function}

\begin{function}{peek-char}{\op peek-type stream eof-error-p eof-value recursive-p}
  
\end{function}

\begin{function}{read-byte}{stream \op eof-error-p eof-value}
  
\end{function}

\begin{function}{read-char}{\op stream eof-error-p eof-value recursive-p}
  
\end{function}

\begin{function}{read-char-no-hang}{\op stream eof-error-p eof-value recursive-p}
  
\end{function}

\begin{function}{read-line}{\op stream eof-error-p eof-value recursive-p}
  
\end{function}

\begin{function}{read-sequence}{seq stream \key start end}
  Destructively modify SEQ by reading elements from STREAM.
  That part of SEQ bounded by START and END is destructively modified by
  copying successive elements into it from STREAM. If the end of file
  for STREAM is reached before copying all elements of the subsequence,
  then the extra elements near the end of sequence are not updated, and
  the index of the next element is returned.
\end{function}

\begin{function}{stream-element-type}{stream}
  Return a type specifier for the kind of object returned by the
  STREAM. The class FUNDAMENTAL-CHARACTER-STREAM provides a default method
  which returns CHARACTER.
\end{function}

\begin{function}{stream-error-stream}{condition}
  
\end{function}

\begin{function}{stream-external-format}{stream}
  
\end{function}

\begin{function}{streamp}{stream}
  
\end{function}

\begin{function}{synonym-stream-symbol}{instance}
  
\end{function}

\begin{function}{terpri}{\op stream}
  
\end{function}

\begin{function}{two-way-stream-input-stream}{instance}
  
\end{function}

\begin{function}{two-way-stream-output-stream}{instance}
  
\end{function}

\begin{function}{unread-char}{character \op stream}
  
\end{function}

\begin{function}{write-byte}{integer stream}
  
\end{function}

\begin{function}{write-char}{character \op stream}
  
\end{function}

\begin{function}{write-line}{string \op stream \key start end}
  
\end{function}

\begin{function}{write-sequence}{seq stream \key start end}
  Write the elements of SEQ bounded by START and END to STREAM.
\end{function}

\begin{function}{write-string}{string \op stream \key start end}
  
\end{function}

\begin{function}{y-or-n-p}{\op format-string \rest arguments}
  Y-OR-N-P prints the message, if any, and reads characters from
   *QUERY-IO* until the user enters y or Y as an affirmative, or either
   n or N as a negative answer. It asks again if you enter any other
   characters.
\end{function}

\begin{function}{yes-or-no-p}{\op format-string \rest arguments}
  YES-OR-NO-P is similar to Y-OR-N-P, except that it clears the
   input buffer, beeps, and uses READ-LINE to get the strings
   YES or NO.
\end{function}

\begin{macro}{with-input-from-string}{var \body forms-decls}
  
\end{macro}

\begin{macro}{with-open-file}{stream \body body}
  
\end{macro}

\begin{macro}{with-open-stream}{var \body forms-decls}
  
\end{macro}

\begin{macro}{with-output-to-string}{var \body forms-decls}
  
\end{macro}

\begin{class}{broadcast-stream}{}
  
\end{class}

\begin{class}{concatenated-stream}{}
  
\end{class}

\begin{class}{echo-stream}{}
  
\end{class}

\begin{class}{file-stream}{}
  
\end{class}

\begin{class}{stream}{}
  
\end{class}

\begin{class}{string-stream}{}
  
\end{class}

\begin{class}{synonym-stream}{}
  
\end{class}

\begin{class}{two-way-stream}{}
  
\end{class}

\begin{variable}{*debug-io*}{}
  
\end{variable}

\begin{variable}{*error-output*}{}
  
\end{variable}

\begin{variable}{*query-io*}{}
  
\end{variable}

\begin{variable}{*standard-input*}{}
  
\end{variable}

\begin{variable}{*standard-output*}{}
  
\end{variable}

\begin{variable}{*terminal-io*}{}
  
\end{variable}

\begin{variable}{*trace-output*}{}
  
\end{variable}

\section{Extensions}
\label{sec:extensions}

\begin{macro}{with-input-from-file}{stream-name file-name \rest args
    \key direction \akeys \body body}[cl-ext]
  Evaluate BODY with STREAM-NAME bound to an input-stream from file
FILE-NAME. ARGS is passed directly to open.
\end{macro}

\begin{macro}{with-output-to-file}{stream-name file-name \rest args
    \key direction \akeys \body body}[cl-ext]
  Evaluate BODY with STREAM-NAME to an output stream on the file
FILE-NAME. ARGS is sent as is to the call te open. It will supersed
file-name if it exists.
\begin{devnote}
  The supersed thing is not originaly in alexandria, but I think it's
  more useful.
\end{devnote}
\end{macro}

\begin{function}{write-string-into-file}{string pathname \key if-exists if-does-not-exist external-format}[cl-ext]
  Write STRING to PATHNAME.

The EXTERNAL-FORMAT parameter will be passed to
ENCODING-KEYWORD-TO-NATIVE, see ENCODING-KEYWORD-TO-NATIVE to
possible values.
\end{function}

\begin{function}{read-file-into-string}{pathname \key buffer-size external-format}[cl-ext]
  Return the contents of PATHNAME as a fresh string.

The file specified by PATHNAME will be read one ELEMENT-TYPE
element at a time, the EXTERNAL-FORMAT and ELEMENT-TYPEs must be
compatible.

The EXTERNAL-FORMAT parameter will be passed to
ENCODING-KEYWORD-TO-NATIVE, see ENCODING-KEYWORD-TO-NATIVE to
possible values.
\end{function}

\begin{function}{copy-file}{from to \key if-to-exists element-type}[cl-ext]
  
\end{function}

\begin{function}{copy-stream}{input output \op element-type}[cl-ext]
  Reads data from FROM and writes it to TO. Both FROM and TO must be streams,
they will be passed to read-sequence/write-sequence and must have compatable
element-types.
\end{function}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: cl-dist-manual.tex
%%% End:
